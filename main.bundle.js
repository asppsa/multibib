System.registerDynamic("npm:core-js@1.2.6/library/modules/core.is-iterable.js", ["npm:core-js@1.2.6/library/modules/$.classof.js", "npm:core-js@1.2.6/library/modules/$.wks.js", "npm:core-js@1.2.6/library/modules/$.iterators.js", "npm:core-js@1.2.6/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var classof = $__require('npm:core-js@1.2.6/library/modules/$.classof.js'),
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('iterator'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core.js').isIterable = function(it) {
    var O = Object(it);
    return O[ITERATOR] !== undefined || '@@iterator' in O || Iterators.hasOwnProperty(classof(O));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/is-iterable.js", ["npm:core-js@1.2.6/library/modules/web.dom.iterable.js", "npm:core-js@1.2.6/library/modules/es6.string.iterator.js", "npm:core-js@1.2.6/library/modules/core.is-iterable.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('npm:core-js@1.2.6/library/modules/web.dom.iterable.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.string.iterator.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/core.is-iterable.js');
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.38/core-js/is-iterable.js", ["npm:core-js@1.2.6/library/fn/is-iterable.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/is-iterable.js'),
    __esModule: true
  };
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.38/helpers/sliced-to-array.js", ["npm:babel-runtime@5.8.38/core-js/get-iterator.js", "npm:babel-runtime@5.8.38/core-js/is-iterable.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _getIterator = $__require('npm:babel-runtime@5.8.38/core-js/get-iterator.js')["default"];
  var _isIterable = $__require('npm:babel-runtime@5.8.38/core-js/is-iterable.js')["default"];
  exports["default"] = (function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = _getIterator(arr),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (_isIterable(Object(arr))) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  })();
  exports.__esModule = true;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.set-proto.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.is-object.js", "npm:core-js@1.2.6/library/modules/$.an-object.js", "npm:core-js@1.2.6/library/modules/$.ctx.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var getDesc = $__require('npm:core-js@1.2.6/library/modules/$.js').getDesc,
      isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object.js'),
      anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object.js');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.same-value.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.species-constructor.js", ["npm:core-js@1.2.6/library/modules/$.an-object.js", "npm:core-js@1.2.6/library/modules/$.a-function.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object.js'),
      aFunction = $__require('npm:core-js@1.2.6/library/modules/$.a-function.js'),
      SPECIES = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('species');
  module.exports = function(O, D) {
    var C = anObject(O).constructor,
        S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.invoke.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.html.js", ["npm:core-js@1.2.6/library/modules/$.global.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.global.js').document && document.documentElement;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.dom-create.js", ["npm:core-js@1.2.6/library/modules/$.is-object.js", "npm:core-js@1.2.6/library/modules/$.global.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object.js'),
      document = $__require('npm:core-js@1.2.6/library/modules/$.global.js').document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.task.js", ["npm:core-js@1.2.6/library/modules/$.ctx.js", "npm:core-js@1.2.6/library/modules/$.invoke.js", "npm:core-js@1.2.6/library/modules/$.html.js", "npm:core-js@1.2.6/library/modules/$.dom-create.js", "npm:core-js@1.2.6/library/modules/$.global.js", "npm:core-js@1.2.6/library/modules/$.cof.js", "github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    var ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js'),
        invoke = $__require('npm:core-js@1.2.6/library/modules/$.invoke.js'),
        html = $__require('npm:core-js@1.2.6/library/modules/$.html.js'),
        cel = $__require('npm:core-js@1.2.6/library/modules/$.dom-create.js'),
        global = $__require('npm:core-js@1.2.6/library/modules/$.global.js'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('npm:core-js@1.2.6/library/modules/$.cof.js')(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.microtask.js", ["npm:core-js@1.2.6/library/modules/$.global.js", "npm:core-js@1.2.6/library/modules/$.task.js", "npm:core-js@1.2.6/library/modules/$.cof.js", "github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    var global = $__require('npm:core-js@1.2.6/library/modules/$.global.js'),
        macrotask = $__require('npm:core-js@1.2.6/library/modules/$.task.js').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = $__require('npm:core-js@1.2.6/library/modules/$.cof.js')(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain,
          fn;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        fn = head.fn;
        if (domain)
          domain.enter();
        fn();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else if (Promise && Promise.resolve) {
      notify = function() {
        Promise.resolve().then(flush);
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.promise.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.library.js", "npm:core-js@1.2.6/library/modules/$.global.js", "npm:core-js@1.2.6/library/modules/$.ctx.js", "npm:core-js@1.2.6/library/modules/$.classof.js", "npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.is-object.js", "npm:core-js@1.2.6/library/modules/$.an-object.js", "npm:core-js@1.2.6/library/modules/$.a-function.js", "npm:core-js@1.2.6/library/modules/$.strict-new.js", "npm:core-js@1.2.6/library/modules/$.for-of.js", "npm:core-js@1.2.6/library/modules/$.set-proto.js", "npm:core-js@1.2.6/library/modules/$.same-value.js", "npm:core-js@1.2.6/library/modules/$.wks.js", "npm:core-js@1.2.6/library/modules/$.species-constructor.js", "npm:core-js@1.2.6/library/modules/$.microtask.js", "npm:core-js@1.2.6/library/modules/$.descriptors.js", "npm:core-js@1.2.6/library/modules/$.redefine-all.js", "npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js", "npm:core-js@1.2.6/library/modules/$.set-species.js", "npm:core-js@1.2.6/library/modules/$.core.js", "npm:core-js@1.2.6/library/modules/$.iter-detect.js", "github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    'use strict';
    var $ = $__require('npm:core-js@1.2.6/library/modules/$.js'),
        LIBRARY = $__require('npm:core-js@1.2.6/library/modules/$.library.js'),
        global = $__require('npm:core-js@1.2.6/library/modules/$.global.js'),
        ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js'),
        classof = $__require('npm:core-js@1.2.6/library/modules/$.classof.js'),
        $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js'),
        isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object.js'),
        anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object.js'),
        aFunction = $__require('npm:core-js@1.2.6/library/modules/$.a-function.js'),
        strictNew = $__require('npm:core-js@1.2.6/library/modules/$.strict-new.js'),
        forOf = $__require('npm:core-js@1.2.6/library/modules/$.for-of.js'),
        setProto = $__require('npm:core-js@1.2.6/library/modules/$.set-proto.js').set,
        same = $__require('npm:core-js@1.2.6/library/modules/$.same-value.js'),
        SPECIES = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('species'),
        speciesConstructor = $__require('npm:core-js@1.2.6/library/modules/$.species-constructor.js'),
        asap = $__require('npm:core-js@1.2.6/library/modules/$.microtask.js'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var USE_NATIVE = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('npm:core-js@1.2.6/library/modules/$.descriptors.js')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var PromiseCapability = function(C) {
      var resolve,
          reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined)
          throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve), this.reject = aFunction(reject);
    };
    var perform = function(exec) {
      try {
        exec();
      } catch (e) {
        return {error: e};
      }
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(reaction) {
          var handler = ok ? reaction.ok : reaction.fail,
              resolve = reaction.resolve,
              reject = reaction.reject,
              result,
              then;
          try {
            if (handler) {
              if (!ok)
                record.h = true;
              result = handler === true ? value : handler(value);
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else
                resolve(result);
            } else
              reject(value);
          } catch (e) {
            reject(e);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise._d,
          chain = record.a || record.c,
          i = 0,
          reaction;
      if (record.h)
        return false;
      while (chain.length > i) {
        reaction = chain[i++];
        if (reaction.fail || !isUnhandled(reaction.promise))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (record.p === value)
          throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!USE_NATIVE) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = this._d = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('npm:core-js@1.2.6/library/modules/$.redefine-all.js')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var reaction = new PromiseCapability(speciesConstructor(this, P)),
              promise = reaction.promise,
              record = this._d;
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          record.c.push(reaction);
          if (record.a)
            record.a.push(reaction);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
    $__require('npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js')(P, PROMISE);
    $__require('npm:core-js@1.2.6/library/modules/$.set-species.js')(PROMISE);
    Wrapper = $__require('npm:core-js@1.2.6/library/modules/$.core.js')[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, {reject: function reject(r) {
        var capability = new PromiseCapability(this),
            $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      }});
    $export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        if (x instanceof P && sameConstructor(x.constructor, this))
          return x;
        var capability = new PromiseCapability(this),
            $$resolve = capability.resolve;
        $$resolve(x);
        return capability.promise;
      }});
    $export($export.S + $export.F * !(USE_NATIVE && $__require('npm:core-js@1.2.6/library/modules/$.iter-detect.js')(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [];
        var abrupt = perform(function() {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              var alreadyCalled = false;
              C.resolve(promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                results[index] = value;
                --remaining || resolve(results);
              }, reject);
            });
          else
            resolve(results);
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            reject = capability.reject;
        var abrupt = perform(function() {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      }
    });
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/promise.js", ["npm:core-js@1.2.6/library/modules/es6.object.to-string.js", "npm:core-js@1.2.6/library/modules/es6.string.iterator.js", "npm:core-js@1.2.6/library/modules/web.dom.iterable.js", "npm:core-js@1.2.6/library/modules/es6.promise.js", "npm:core-js@1.2.6/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('npm:core-js@1.2.6/library/modules/es6.object.to-string.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.string.iterator.js');
  $__require('npm:core-js@1.2.6/library/modules/web.dom.iterable.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.promise.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core.js').Promise;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.38/core-js/promise.js", ["npm:core-js@1.2.6/library/fn/promise.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/promise.js'),
    __esModule: true
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-object.js", ["npm:core-js@1.2.6/library/modules/$.defined.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var defined = $__require('npm:core-js@1.2.6/library/modules/$.defined.js');
  module.exports = function(it) {
    return Object(defined(it));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-detect.js", ["npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.array.from.js", ["npm:core-js@1.2.6/library/modules/$.ctx.js", "npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.to-object.js", "npm:core-js@1.2.6/library/modules/$.iter-call.js", "npm:core-js@1.2.6/library/modules/$.is-array-iter.js", "npm:core-js@1.2.6/library/modules/$.to-length.js", "npm:core-js@1.2.6/library/modules/core.get-iterator-method.js", "npm:core-js@1.2.6/library/modules/$.iter-detect.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js'),
      $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js'),
      toObject = $__require('npm:core-js@1.2.6/library/modules/$.to-object.js'),
      call = $__require('npm:core-js@1.2.6/library/modules/$.iter-call.js'),
      isArrayIter = $__require('npm:core-js@1.2.6/library/modules/$.is-array-iter.js'),
      toLength = $__require('npm:core-js@1.2.6/library/modules/$.to-length.js'),
      getIterFn = $__require('npm:core-js@1.2.6/library/modules/core.get-iterator-method.js');
  $export($export.S + $export.F * !$__require('npm:core-js@1.2.6/library/modules/$.iter-detect.js')(function(iter) {
    Array.from(iter);
  }), 'Array', {from: function from(arrayLike) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          $$ = arguments,
          $$len = $$.length,
          mapfn = $$len > 1 ? $$[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping)
        mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) {
          result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          result[index] = mapping ? mapfn(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/array/from.js", ["npm:core-js@1.2.6/library/modules/es6.string.iterator.js", "npm:core-js@1.2.6/library/modules/es6.array.from.js", "npm:core-js@1.2.6/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('npm:core-js@1.2.6/library/modules/es6.string.iterator.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.array.from.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core.js').Array.from;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.38/core-js/array/from.js", ["npm:core-js@1.2.6/library/fn/array/from.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/array/from.js'),
    __esModule: true
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/core.get-iterator.js", ["npm:core-js@1.2.6/library/modules/$.an-object.js", "npm:core-js@1.2.6/library/modules/core.get-iterator-method.js", "npm:core-js@1.2.6/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object.js'),
      get = $__require('npm:core-js@1.2.6/library/modules/core.get-iterator-method.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core.js').getIterator = function(it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function')
      throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/get-iterator.js", ["npm:core-js@1.2.6/library/modules/web.dom.iterable.js", "npm:core-js@1.2.6/library/modules/es6.string.iterator.js", "npm:core-js@1.2.6/library/modules/core.get-iterator.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('npm:core-js@1.2.6/library/modules/web.dom.iterable.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.string.iterator.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/core.get-iterator.js');
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.38/core-js/get-iterator.js", ["npm:core-js@1.2.6/library/fn/get-iterator.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/get-iterator.js'),
    __esModule: true
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.map.js", ["npm:core-js@1.2.6/library/modules/$.collection-strong.js", "npm:core-js@1.2.6/library/modules/$.collection.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var strong = $__require('npm:core-js@1.2.6/library/modules/$.collection-strong.js');
  $__require('npm:core-js@1.2.6/library/modules/$.collection.js')('Map', function(get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    set: function set(key, value) {
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es7.map.to-json.js", ["npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.collection-to-json.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js');
  $export($export.P, 'Map', {toJSON: $__require('npm:core-js@1.2.6/library/modules/$.collection-to-json.js')('Map')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/map.js", ["npm:core-js@1.2.6/library/modules/es6.object.to-string.js", "npm:core-js@1.2.6/library/modules/es6.string.iterator.js", "npm:core-js@1.2.6/library/modules/web.dom.iterable.js", "npm:core-js@1.2.6/library/modules/es6.map.js", "npm:core-js@1.2.6/library/modules/es7.map.to-json.js", "npm:core-js@1.2.6/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('npm:core-js@1.2.6/library/modules/es6.object.to-string.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.string.iterator.js');
  $__require('npm:core-js@1.2.6/library/modules/web.dom.iterable.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.map.js');
  $__require('npm:core-js@1.2.6/library/modules/es7.map.to-json.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core.js').Map;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.38/core-js/map.js", ["npm:core-js@1.2.6/library/fn/map.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/map.js'),
    __esModule: true
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.to-string.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.string-at.js", ["npm:core-js@1.2.6/library/modules/$.to-integer.js", "npm:core-js@1.2.6/library/modules/$.defined.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toInteger = $__require('npm:core-js@1.2.6/library/modules/$.to-integer.js'),
      defined = $__require('npm:core-js@1.2.6/library/modules/$.defined.js');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.string.iterator.js", ["npm:core-js@1.2.6/library/modules/$.string-at.js", "npm:core-js@1.2.6/library/modules/$.iter-define.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $at = $__require('npm:core-js@1.2.6/library/modules/$.string-at.js')(true);
  $__require('npm:core-js@1.2.6/library/modules/$.iter-define.js')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.add-to-unscopables.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function() {};
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iobject.js", ["npm:core-js@1.2.6/library/modules/$.cof.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var cof = $__require('npm:core-js@1.2.6/library/modules/$.cof.js');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-iobject.js", ["npm:core-js@1.2.6/library/modules/$.iobject.js", "npm:core-js@1.2.6/library/modules/$.defined.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var IObject = $__require('npm:core-js@1.2.6/library/modules/$.iobject.js'),
      defined = $__require('npm:core-js@1.2.6/library/modules/$.defined.js');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.array.iterator.js", ["npm:core-js@1.2.6/library/modules/$.add-to-unscopables.js", "npm:core-js@1.2.6/library/modules/$.iter-step.js", "npm:core-js@1.2.6/library/modules/$.iterators.js", "npm:core-js@1.2.6/library/modules/$.to-iobject.js", "npm:core-js@1.2.6/library/modules/$.iter-define.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var addToUnscopables = $__require('npm:core-js@1.2.6/library/modules/$.add-to-unscopables.js'),
      step = $__require('npm:core-js@1.2.6/library/modules/$.iter-step.js'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators.js'),
      toIObject = $__require('npm:core-js@1.2.6/library/modules/$.to-iobject.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.iter-define.js')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/web.dom.iterable.js", ["npm:core-js@1.2.6/library/modules/es6.array.iterator.js", "npm:core-js@1.2.6/library/modules/$.iterators.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('npm:core-js@1.2.6/library/modules/es6.array.iterator.js');
  var Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators.js');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.defined.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.library.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = true;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-create.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.property-desc.js", "npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js", "npm:core-js@1.2.6/library/modules/$.hide.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js'),
      descriptor = $__require('npm:core-js@1.2.6/library/modules/$.property-desc.js'),
      setToStringTag = $__require('npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js'),
      IteratorPrototype = {};
  $__require('npm:core-js@1.2.6/library/modules/$.hide.js')(IteratorPrototype, $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-define.js", ["npm:core-js@1.2.6/library/modules/$.library.js", "npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.redefine.js", "npm:core-js@1.2.6/library/modules/$.hide.js", "npm:core-js@1.2.6/library/modules/$.has.js", "npm:core-js@1.2.6/library/modules/$.iterators.js", "npm:core-js@1.2.6/library/modules/$.iter-create.js", "npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js", "npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var LIBRARY = $__require('npm:core-js@1.2.6/library/modules/$.library.js'),
      $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js'),
      redefine = $__require('npm:core-js@1.2.6/library/modules/$.redefine.js'),
      hide = $__require('npm:core-js@1.2.6/library/modules/$.hide.js'),
      has = $__require('npm:core-js@1.2.6/library/modules/$.has.js'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators.js'),
      $iterCreate = $__require('npm:core-js@1.2.6/library/modules/$.iter-create.js'),
      setToStringTag = $__require('npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js'),
      getProto = $__require('npm:core-js@1.2.6/library/modules/$.js').getProto,
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-step.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.set-species.js", ["npm:core-js@1.2.6/library/modules/$.core.js", "npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.descriptors.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var core = $__require('npm:core-js@1.2.6/library/modules/$.core.js'),
      $ = $__require('npm:core-js@1.2.6/library/modules/$.js'),
      DESCRIPTORS = $__require('npm:core-js@1.2.6/library/modules/$.descriptors.js'),
      SPECIES = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('species');
  module.exports = function(KEY) {
    var C = core[KEY];
    if (DESCRIPTORS && C && !C[SPECIES])
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.collection-strong.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.hide.js", "npm:core-js@1.2.6/library/modules/$.redefine-all.js", "npm:core-js@1.2.6/library/modules/$.ctx.js", "npm:core-js@1.2.6/library/modules/$.strict-new.js", "npm:core-js@1.2.6/library/modules/$.defined.js", "npm:core-js@1.2.6/library/modules/$.for-of.js", "npm:core-js@1.2.6/library/modules/$.iter-define.js", "npm:core-js@1.2.6/library/modules/$.iter-step.js", "npm:core-js@1.2.6/library/modules/$.uid.js", "npm:core-js@1.2.6/library/modules/$.has.js", "npm:core-js@1.2.6/library/modules/$.is-object.js", "npm:core-js@1.2.6/library/modules/$.set-species.js", "npm:core-js@1.2.6/library/modules/$.descriptors.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js'),
      hide = $__require('npm:core-js@1.2.6/library/modules/$.hide.js'),
      redefineAll = $__require('npm:core-js@1.2.6/library/modules/$.redefine-all.js'),
      ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js'),
      strictNew = $__require('npm:core-js@1.2.6/library/modules/$.strict-new.js'),
      defined = $__require('npm:core-js@1.2.6/library/modules/$.defined.js'),
      forOf = $__require('npm:core-js@1.2.6/library/modules/$.for-of.js'),
      $iterDefine = $__require('npm:core-js@1.2.6/library/modules/$.iter-define.js'),
      step = $__require('npm:core-js@1.2.6/library/modules/$.iter-step.js'),
      ID = $__require('npm:core-js@1.2.6/library/modules/$.uid.js')('id'),
      $has = $__require('npm:core-js@1.2.6/library/modules/$.has.js'),
      isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object.js'),
      setSpecies = $__require('npm:core-js@1.2.6/library/modules/$.set-species.js'),
      DESCRIPTORS = $__require('npm:core-js@1.2.6/library/modules/$.descriptors.js'),
      isExtensible = Object.isExtensible || isObject,
      SIZE = DESCRIPTORS ? '_s' : 'size',
      id = 0;
  var fastKey = function(it, create) {
    if (!isObject(it))
      return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!$has(it, ID)) {
      if (!isExtensible(it))
        return 'F';
      if (!create)
        return 'E';
      hide(it, ID, ++id);
    }
    return 'O' + it[ID];
  };
  var getEntry = function(that, key) {
    var index = fastKey(key),
        entry;
    if (index !== 'F')
      return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key)
        return entry;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = $.create(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        clear: function clear() {
          for (var that = this,
              data = that._i,
              entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p)
              entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function(key) {
          var that = this,
              entry = getEntry(that, key);
          if (entry) {
            var next = entry.n,
                prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev)
              prev.n = next;
            if (next)
              next.p = prev;
            if (that._f == entry)
              that._f = next;
            if (that._l == entry)
              that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
              entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r)
              entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if (DESCRIPTORS)
        $.setDesc(C.prototype, 'size', {get: function() {
            return defined(this[SIZE]);
          }});
      return C;
    },
    def: function(that, key, value) {
      var entry = getEntry(that, key),
          prev,
          index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f)
          that._f = entry;
        if (prev)
          prev.n = entry;
        that[SIZE]++;
        if (index !== 'F')
          that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function(C, NAME, IS_MAP) {
      $iterDefine(C, NAME, function(iterated, kind) {
        this._t = iterated;
        this._k = kind;
        this._l = undefined;
      }, function() {
        var that = this,
            kind = that._k,
            entry = that._l;
        while (entry && entry.r)
          entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return step(1);
        }
        if (kind == 'keys')
          return step(0, entry.k);
        if (kind == 'values')
          return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      setSpecies(NAME);
    }
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.property-desc.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.hide.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.property-desc.js", "npm:core-js@1.2.6/library/modules/$.descriptors.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js'),
      createDesc = $__require('npm:core-js@1.2.6/library/modules/$.property-desc.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.descriptors.js') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.redefine.js", ["npm:core-js@1.2.6/library/modules/$.hide.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.hide.js');
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.redefine-all.js", ["npm:core-js@1.2.6/library/modules/$.redefine.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var redefine = $__require('npm:core-js@1.2.6/library/modules/$.redefine.js');
  module.exports = function(target, src) {
    for (var key in src)
      redefine(target, key, src[key]);
    return target;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.strict-new.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.has.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.has.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var def = $__require('npm:core-js@1.2.6/library/modules/$.js').setDesc,
      has = $__require('npm:core-js@1.2.6/library/modules/$.has.js'),
      TAG = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.fails.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.descriptors.js", ["npm:core-js@1.2.6/library/modules/$.fails.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = !$__require('npm:core-js@1.2.6/library/modules/$.fails.js')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.collection.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.global.js", "npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.fails.js", "npm:core-js@1.2.6/library/modules/$.hide.js", "npm:core-js@1.2.6/library/modules/$.redefine-all.js", "npm:core-js@1.2.6/library/modules/$.for-of.js", "npm:core-js@1.2.6/library/modules/$.strict-new.js", "npm:core-js@1.2.6/library/modules/$.is-object.js", "npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js", "npm:core-js@1.2.6/library/modules/$.descriptors.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js'),
      global = $__require('npm:core-js@1.2.6/library/modules/$.global.js'),
      $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js'),
      fails = $__require('npm:core-js@1.2.6/library/modules/$.fails.js'),
      hide = $__require('npm:core-js@1.2.6/library/modules/$.hide.js'),
      redefineAll = $__require('npm:core-js@1.2.6/library/modules/$.redefine-all.js'),
      forOf = $__require('npm:core-js@1.2.6/library/modules/$.for-of.js'),
      strictNew = $__require('npm:core-js@1.2.6/library/modules/$.strict-new.js'),
      isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object.js'),
      setToStringTag = $__require('npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js'),
      DESCRIPTORS = $__require('npm:core-js@1.2.6/library/modules/$.descriptors.js');
  module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function() {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
    } else {
      C = wrapper(function(target, iterable) {
        strictNew(target, C, NAME);
        target._c = new Base;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, target[ADDER], target);
      });
      $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','), function(KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear'))
          hide(C.prototype, KEY, function(a, b) {
            if (!IS_ADDER && IS_WEAK && !isObject(a))
              return KEY == 'get' ? undefined : false;
            var result = this._c[KEY](a === 0 ? 0 : a, b);
            return IS_ADDER ? this : result;
          });
      });
      if ('size' in proto)
        $.setDesc(C.prototype, 'size', {get: function() {
            return this._c.size;
          }});
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F, O);
    if (!IS_WEAK)
      common.setStrong(C, NAME, IS_MAP);
    return C;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.set.js", ["npm:core-js@1.2.6/library/modules/$.collection-strong.js", "npm:core-js@1.2.6/library/modules/$.collection.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var strong = $__require('npm:core-js@1.2.6/library/modules/$.collection-strong.js');
  $__require('npm:core-js@1.2.6/library/modules/$.collection.js')('Set', function(get) {
    return function Set() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {add: function add(value) {
      return strong.def(this, value = value === 0 ? 0 : value, value);
    }}, strong);
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.export.js", ["npm:core-js@1.2.6/library/modules/$.global.js", "npm:core-js@1.2.6/library/modules/$.core.js", "npm:core-js@1.2.6/library/modules/$.ctx.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = $__require('npm:core-js@1.2.6/library/modules/$.global.js'),
      core = $__require('npm:core-js@1.2.6/library/modules/$.core.js'),
      ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? (function(C) {
        var F = function(param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.a-function.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.ctx.js", ["npm:core-js@1.2.6/library/modules/$.a-function.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var aFunction = $__require('npm:core-js@1.2.6/library/modules/$.a-function.js');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-call.js", ["npm:core-js@1.2.6/library/modules/$.an-object.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object.js');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.is-array-iter.js", ["npm:core-js@1.2.6/library/modules/$.iterators.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators.js'),
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('iterator'),
      ArrayProto = Array.prototype;
  module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.is-object.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.an-object.js", ["npm:core-js@1.2.6/library/modules/$.is-object.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object.js');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-integer.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-length.js", ["npm:core-js@1.2.6/library/modules/$.to-integer.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toInteger = $__require('npm:core-js@1.2.6/library/modules/$.to-integer.js'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iterators.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {};
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/core.get-iterator-method.js", ["npm:core-js@1.2.6/library/modules/$.classof.js", "npm:core-js@1.2.6/library/modules/$.wks.js", "npm:core-js@1.2.6/library/modules/$.iterators.js", "npm:core-js@1.2.6/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var classof = $__require('npm:core-js@1.2.6/library/modules/$.classof.js'),
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('iterator'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core.js').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.for-of.js", ["npm:core-js@1.2.6/library/modules/$.ctx.js", "npm:core-js@1.2.6/library/modules/$.iter-call.js", "npm:core-js@1.2.6/library/modules/$.is-array-iter.js", "npm:core-js@1.2.6/library/modules/$.an-object.js", "npm:core-js@1.2.6/library/modules/$.to-length.js", "npm:core-js@1.2.6/library/modules/core.get-iterator-method.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js'),
      call = $__require('npm:core-js@1.2.6/library/modules/$.iter-call.js'),
      isArrayIter = $__require('npm:core-js@1.2.6/library/modules/$.is-array-iter.js'),
      anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object.js'),
      toLength = $__require('npm:core-js@1.2.6/library/modules/$.to-length.js'),
      getIterFn = $__require('npm:core-js@1.2.6/library/modules/core.get-iterator-method.js');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.cof.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.shared.js", ["npm:core-js@1.2.6/library/modules/$.global.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = $__require('npm:core-js@1.2.6/library/modules/$.global.js'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.uid.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.global.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.wks.js", ["npm:core-js@1.2.6/library/modules/$.shared.js", "npm:core-js@1.2.6/library/modules/$.uid.js", "npm:core-js@1.2.6/library/modules/$.global.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var store = $__require('npm:core-js@1.2.6/library/modules/$.shared.js')('wks'),
      uid = $__require('npm:core-js@1.2.6/library/modules/$.uid.js'),
      Symbol = $__require('npm:core-js@1.2.6/library/modules/$.global.js').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.classof.js", ["npm:core-js@1.2.6/library/modules/$.cof.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var cof = $__require('npm:core-js@1.2.6/library/modules/$.cof.js'),
      TAG = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.collection-to-json.js", ["npm:core-js@1.2.6/library/modules/$.for-of.js", "npm:core-js@1.2.6/library/modules/$.classof.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var forOf = $__require('npm:core-js@1.2.6/library/modules/$.for-of.js'),
      classof = $__require('npm:core-js@1.2.6/library/modules/$.classof.js');
  module.exports = function(NAME) {
    return function toJSON() {
      if (classof(this) != NAME)
        throw TypeError(NAME + "#toJSON isn't generic");
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    };
  };
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es7.set.to-json.js", ["npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.collection-to-json.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js');
  $export($export.P, 'Set', {toJSON: $__require('npm:core-js@1.2.6/library/modules/$.collection-to-json.js')('Set')});
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.core.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/set.js", ["npm:core-js@1.2.6/library/modules/es6.object.to-string.js", "npm:core-js@1.2.6/library/modules/es6.string.iterator.js", "npm:core-js@1.2.6/library/modules/web.dom.iterable.js", "npm:core-js@1.2.6/library/modules/es6.set.js", "npm:core-js@1.2.6/library/modules/es7.set.to-json.js", "npm:core-js@1.2.6/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('npm:core-js@1.2.6/library/modules/es6.object.to-string.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.string.iterator.js');
  $__require('npm:core-js@1.2.6/library/modules/web.dom.iterable.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.set.js');
  $__require('npm:core-js@1.2.6/library/modules/es7.set.to-json.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core.js').Set;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.38/core-js/set.js", ["npm:core-js@1.2.6/library/fn/set.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/set.js'),
    __esModule: true
  };
  return module.exports;
});

System.registerDynamic("github:juris-m/citeproc-js@1.1.101/citeproc.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    var CSL = this["CSL"];
    var CSL_IS_NODEJS = this["CSL_IS_NODEJS"];
    var CSL_NODEJS = this["CSL_NODEJS"];
    "format global";
    if (!Array.indexOf) {
      Array.prototype.indexOf = function(obj) {
        var i,
            len;
        for (i = 0, len = this.length; i < len; i += 1) {
          if (this[i] === obj) {
            return i;
          }
        }
        return -1;
      };
    }
    var CSL = {
      PROCESSOR_VERSION: "1.1.101",
      CONDITION_LEVEL_TOP: 1,
      CONDITION_LEVEL_BOTTOM: 2,
      PLAIN_HYPHEN_REGEX: /(?:[^\\]-|\u2013)/,
      LOCATOR_LABELS_REGEXP: new RegExp("^((art|ch|subch|col|fig|l|n|no|op|p|pp|para|subpara|pt|r|sec|subsec|sv|sch|tit|vrs|vol)\\.)\\s+(.*)"),
      STATUTE_SUBDIV_GROUPED_REGEX: /((?:^| )(?:art|bk|ch|subch|col|fig|fol|l|n|no|op|p|pp|para|subpara|pt|r|sec|subsec|sv|sch|tit|vrs|vol)\. *)/g,
      STATUTE_SUBDIV_PLAIN_REGEX: /(?:(?:^| )(?:art|bk|ch|subch|col|fig|fol|l|n|no|op|p|pp|para|subpara|pt|r|sec|subsec|sv|sch|tit|vrs|vol)\. *)/,
      STATUTE_SUBDIV_STRINGS: {
        "art.": "article",
        "bk.": "book",
        "ch.": "chapter",
        "subch.": "subchapter",
        "p.": "page",
        "pp.": "page",
        "para.": "paragraph",
        "subpara.": "subparagraph",
        "pt.": "part",
        "r.": "rule",
        "sec.": "section",
        "subsec.": "subsection",
        "sch.": "schedule",
        "tit.": "title",
        "col.": "column",
        "fig.": "figure",
        "fol.": "folio",
        "l.": "line",
        "n.": "note",
        "no.": "issue",
        "op.": "opus",
        "sv.": "sub-verbo",
        "vrs.": "verse",
        "vol.": "volume"
      },
      STATUTE_SUBDIV_STRINGS_REVERSE: {
        "article": "art.",
        "book": "bk.",
        "chapter": "ch.",
        "subchapter": "subch.",
        "page": "p.",
        "paragraph": "para.",
        "subparagraph": "subpara.",
        "part": "pt.",
        "rule": "r.",
        "section": "sec.",
        "subsection": "subsec.",
        "schedule": "sch.",
        "title": "tit.",
        "column": "col.",
        "figure": "fig.",
        "folio": "fol.",
        "line": "l.",
        "note": "n.",
        "issue": "no.",
        "opus": "op.",
        "sub-verbo": "sv.",
        "sub verbo": "sv.",
        "verse": "vrs.",
        "volume": "vol."
      },
      LOCATOR_LABELS_MAP: {
        "art": "article",
        "bk": "book",
        "ch": "chapter",
        "subch": "subchapter",
        "col": "column",
        "fig": "figure",
        "fol": "folio",
        "l": "line",
        "n": "note",
        "no": "issue",
        "op": "opus",
        "p": "page",
        "pp": "page",
        "para": "paragraph",
        "subpara": "subparagraph",
        "pt": "part",
        "r": "rule",
        "sec": "section",
        "subsec": "subsection",
        "sv": "sub-verbo",
        "sch": "schedule",
        "tit": "title",
        "vrs": "verse",
        "vol": "volume"
      },
      MODULE_MACROS: {
        "juris-pretitle": true,
        "juris-title": true,
        "juris-pretitle-short": true,
        "juris-title-short": true,
        "juris-main": true,
        "juris-main-short": true,
        "juris-tail": true,
        "juris-tail-short": true,
        "juris-locator": true
      },
      MODULE_TYPES: {
        "legal_case": true,
        "legislation": true,
        "bill": true,
        "hearing": true,
        "gazette": true,
        "report": true,
        "regulation": true
      },
      NestedBraces: [["(", "["], [")", "]"]],
      checkNestedBrace: function(state) {
        if (state.opt.xclass === "note") {
          this.depth = 0;
          this.update = function(str) {
            var str = str ? str : '';
            var lst = str.split(/([\(\)])/);
            for (var i = 1,
                ilen = lst.length; i < ilen; i += 2) {
              if (lst[i] === '(') {
                if (1 === (this.depth % 2)) {
                  lst[i] = '[';
                }
                this.depth += 1;
              } else if (lst[i] === ')') {
                if (0 === (this.depth % 2)) {
                  lst[i] = ']';
                }
                this.depth -= 1;
              }
            }
            var ret = lst.join("");
            return ret;
          };
        } else {
          this.update = function(str) {
            return str;
          };
        }
        ;
      },
      MULTI_FIELDS: ["event", "publisher", "publisher-place", "event-place", "title", "container-title", "collection-title", "authority", "genre", "title-short", "medium", "jurisdiction", "archive", "archive-place"],
      LangPrefsMap: {
        "title": "titles",
        "title-short": "titles",
        "event": "titles",
        "genre": "titles",
        "medium": "titles",
        "container-title": "journals",
        "collection-title": "journals",
        "archive": "journals",
        "publisher": "publishers",
        "authority": "publishers",
        "publisher-place": "places",
        "event-place": "places",
        "archive-place": "places",
        "jurisdiction": "places",
        "number": "number",
        "edition": "number",
        "issue": "number",
        "volume": "number"
      },
      AbbreviationSegments: function() {
        this["container-title"] = {};
        this["collection-title"] = {};
        this["institution-entire"] = {};
        this["institution-part"] = {};
        this.nickname = {};
        this.number = {};
        this.title = {};
        this.place = {};
        this.hereinafter = {};
        this.classic = {};
        this["container-phrase"] = {};
        this["title-phrase"] = {};
      },
      parseNoteFieldHacks: function(Item, validFieldsForType) {
        if ("string" !== typeof Item.note)
          return;
        var elems = [];
        var m = Item.note.match(CSL.NOTE_FIELDS_REGEXP);
        if (m) {
          var splt = Item.note.split(CSL.NOTE_FIELDS_REGEXP);
          for (var i = 0,
              ilen = (splt.length - 1); i < ilen; i++) {
            elems.push(splt[i]);
            elems.push(m[i]);
          }
          elems.push(splt[splt.length - 1]);
          var names = {};
          for (var i = 1,
              ilen = elems.length; i < ilen; i += 2) {
            var mm = elems[i].match(CSL.NOTE_FIELD_REGEXP);
            var key = mm[1];
            var val = mm[2].replace(/^\s+/, "").replace(/\s+$/, "");
            if (!Item[key]) {
              if (!validFieldsForType || validFieldsForType[key]) {
                if (CSL.DATE_VARIABLES.indexOf(key) > -1) {
                  Item[key] = {raw: val};
                  elems[i] = "";
                } else {
                  Item[key] = val;
                }
              } else if (CSL.NAME_VARIABLES.indexOf(key) > -1) {
                if (!names[key]) {
                  names[key] = [];
                }
                var lst = val.split(/\s*\|\|\s*/);
                if (lst.length === 1) {
                  names[key].push({literal: lst[0]});
                } else if (lst.length === 2) {
                  var name = {
                    family: lst[0],
                    given: lst[1]
                  };
                  CSL.parseParticles(name);
                  names[key].push(name);
                }
                elems[i] = "";
              }
            }
            if (name === "type") {
              Item.type = val;
            }
            Item.note = elems.join("");
          }
          for (var key in names) {
            Item[key] = names[key];
          }
        }
      },
      GENDERS: ["masculine", "feminine"],
      ERROR_NO_RENDERED_FORM: 1,
      PREVIEW: "Just for laughs.",
      ASSUME_ALL_ITEMS_REGISTERED: 2,
      START: 0,
      END: 1,
      SINGLETON: 2,
      SEEN: 6,
      SUCCESSOR: 3,
      SUCCESSOR_OF_SUCCESSOR: 4,
      SUPPRESS: 5,
      SINGULAR: 0,
      PLURAL: 1,
      LITERAL: true,
      BEFORE: 1,
      AFTER: 2,
      DESCENDING: 1,
      ASCENDING: 2,
      ONLY_FIRST: 1,
      ALWAYS: 2,
      ONLY_LAST: 3,
      FINISH: 1,
      POSITION_FIRST: 0,
      POSITION_SUBSEQUENT: 1,
      POSITION_IBID: 2,
      POSITION_IBID_WITH_LOCATOR: 3,
      MARK_TRAILING_NAMES: true,
      POSITION_TEST_VARS: ["position", "first-reference-note-number", "near-note"],
      AREAS: ["citation", "citation_sort", "bibliography", "bibliography_sort"],
      CITE_FIELDS: ["first-reference-note-number", "locator", "locator-extra"],
      MINIMAL_NAME_FIELDS: ["literal", "family"],
      SWAPPING_PUNCTUATION: [".", "!", "?", ":", ","],
      TERMINAL_PUNCTUATION: [":", ".", ";", "!", "?", " "],
      NONE: 0,
      NUMERIC: 1,
      POSITION: 2,
      COLLAPSE_VALUES: ["citation-number", "year", "year-suffix"],
      DATE_PARTS: ["year", "month", "day"],
      DATE_PARTS_ALL: ["year", "month", "day", "season"],
      DATE_PARTS_INTERNAL: ["year", "month", "day", "year_end", "month_end", "day_end"],
      NAME_PARTS: ["non-dropping-particle", "family", "given", "dropping-particle", "suffix", "literal"],
      DECORABLE_NAME_PARTS: ["given", "family", "suffix"],
      DISAMBIGUATE_OPTIONS: ["disambiguate-add-names", "disambiguate-add-givenname", "disambiguate-add-year-suffix"],
      GIVENNAME_DISAMBIGUATION_RULES: ["all-names", "all-names-with-initials", "primary-name", "primary-name-with-initials", "by-cite"],
      NAME_ATTRIBUTES: ["and", "delimiter-precedes-last", "delimiter-precedes-et-al", "initialize-with", "initialize", "name-as-sort-order", "sort-separator", "et-al-min", "et-al-use-first", "et-al-subsequent-min", "et-al-subsequent-use-first", "form", "prefix", "suffix", "delimiter"],
      PARALLEL_MATCH_VARS: ["container-title"],
      PARALLEL_TYPES: ["bill", "gazette", "regulation", "legislation", "legal_case", "treaty", "article-magazine", "article-journal"],
      PARALLEL_COLLAPSING_MID_VARSET: ["volume", "issue", "container-title", "section", "collection-number"],
      LOOSE: 0,
      STRICT: 1,
      TOLERANT: 2,
      PREFIX_PUNCTUATION: /[.;:]\s*$/,
      SUFFIX_PUNCTUATION: /^\s*[.;:,\(\)]/,
      NUMBER_REGEXP: /(?:^\d+|\d+$)/,
      NAME_INITIAL_REGEXP: /^([A-Z\u0590-\u05ff\u00c0-\u017f\u0400-\u042f\u0600-\u06ff\u0370\u0372\u0376\u0386\u0388-\u03ab\u03e2\u03e4\u03e6\u03e8\u03ea\u03ec\u03ee\u03f4\u03f7\u03fd-\u03ff])([a-zA-Z\u00c0-\u017f\u0400-\u052f\u0600-\u06ff\u0370-\u03ff\u1f00-\u1fff]*|)/,
      ROMANESQUE_REGEXP: /[-0-9a-zA-Z\u0590-\u05d4\u05d6-\u05ff\u0080-\u017f\u0400-\u052f\u0370-\u03ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/,
      ROMANESQUE_NOT_REGEXP: /[^a-zA-Z\u0590-\u05ff\u00c0-\u017f\u0400-\u052f\u0370-\u03ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/g,
      STARTSWITH_ROMANESQUE_REGEXP: /^[&a-zA-Z\u0590-\u05d4\u05d6-\u05ff\u00c0-\u017f\u0400-\u052f\u0370-\u03ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/,
      ENDSWITH_ROMANESQUE_REGEXP: /[.;:&a-zA-Z\u0590-\u05d4\u05d6-\u05ff\u00c0-\u017f\u0400-\u052f\u0370-\u03ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]$/,
      ALL_ROMANESQUE_REGEXP: /^[a-zA-Z\u0590-\u05ff\u00c0-\u017f\u0400-\u052f\u0370-\u03ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]+$/,
      VIETNAMESE_SPECIALS: /[\u00c0-\u00c3\u00c8-\u00ca\u00cc\u00cd\u00d2-\u00d5\u00d9\u00da\u00dd\u00e0-\u00e3\u00e8-\u00ea\u00ec\u00ed\u00f2-\u00f5\u00f9\u00fa\u00fd\u0101\u0103\u0110\u0111\u0128\u0129\u0168\u0169\u01a0\u01a1\u01af\u01b0\u1ea0-\u1ef9]/,
      VIETNAMESE_NAMES: /^(?:(?:[.AaBbCcDdEeGgHhIiKkLlMmNnOoPpQqRrSsTtUuVvXxYy \u00c0-\u00c3\u00c8-\u00ca\u00cc\u00cd\u00d2-\u00d5\u00d9\u00da\u00dd\u00e0-\u00e3\u00e8-\u00ea\u00ec\u00ed\u00f2-\u00f5\u00f9\u00fa\u00fd\u0101\u0103\u0110\u0111\u0128\u0129\u0168\u0169\u01a0\u01a1\u01af\u01b0\u1ea0-\u1ef9]{2,6})(\s+|$))+$/,
      NOTE_FIELDS_REGEXP: /\{:(?:[\-_a-z]+|[A-Z]+):[^\}]+\}/g,
      NOTE_FIELD_REGEXP: /\{:([\-_a-z]+|[A-Z]+):\s*([^\}]+)\}/,
      DISPLAY_CLASSES: ["block", "left-margin", "right-inline", "indent"],
      NAME_VARIABLES: ["author", "editor", "translator", "contributor", "collection-editor", "composer", "container-author", "director", "editorial-director", "interviewer", "original-author", "recipient"],
      NUMERIC_VARIABLES: ["call-number", "chapter-number", "collection-number", "edition", "page", "issue", "locator", "number", "number-of-pages", "number-of-volumes", "volume", "citation-number", "year-suffix"],
      DATE_VARIABLES: ["locator-date", "issued", "event-date", "accessed", "container", "original-date", "publication-date", "original-date", "available-date", "submitted"],
      TAG_ESCAPE: function(str, stopWords) {
        var mx,
            lst,
            len,
            pos,
            m,
            buf1,
            buf2,
            idx,
            ret,
            myret;
        if (!stopWords) {
          stopWords = [];
        }
        var pairs = {
          "<span class=\"nocase\">": "</span>",
          "<span class=\"nodecor\">": "</span>"
        };
        var stack = [];
        str = str.replace(/(<span)\s+(class=\"no(?:case|decor)\")\s*(>)/g, "$1 $2$3");
        var m1match = str.match(/((?: \"| \'|\" |\'[-.,;\?:]|\[|\]|\(|\)|<span class=\"no(?:case|decor)\">|<\/span>|<\/?(?:i|sc|b)>))/g);
        if (!m1match) {
          return [str];
        }
        var m1split = str.split(/(?: \"| \'|\" |\'[-.,;\?:]|\[|\]|\(|\)|<span class=\"no(?:case|decor)\">|<\/span>|<\/?(?:i|sc|b)>)/g);
        outer: for (var i = 0,
            ilen = m1match.length; i < ilen; i++) {
          if (pairs[m1match[i]]) {
            stack.push({
              tag: m1match[i],
              pos: i
            });
            var mFirstWord = m1split[i].match(/^(\s*([^' ]+[']?))(.*)/);
            if (mFirstWord) {
              if (stopWords.indexOf(mFirstWord[2]) > -1) {
                if (!m1split[i - 1].match(/[:\?\!]\s*$/)) {
                  m1match[i - 1] = m1match[i - 1] + mFirstWord[1];
                  m1split[i] = mFirstWord[3];
                }
              }
            }
            continue;
          }
          if (stack.length) {
            for (var j = stack.length - 1; j > -1; j--) {
              var stackObj = stack.slice(j)[0];
              if (m1match[i] === pairs[stackObj.tag]) {
                stack = stack.slice(0, j + 1);
                var startPos = stack[j].pos;
                for (var k = stack[j].pos + 1; k < i + 1; k++) {
                  m1match[k] = m1split[k] + m1match[k];
                  m1split[k] = "";
                }
                stack.pop();
                break;
              }
            }
          }
        }
        myret = [m1split[0]];
        for (pos = 1, len = m1split.length; pos < len; pos += 1) {
          myret.push(m1match[pos - 1]);
          myret.push(m1split[pos]);
        }
        var lst = myret.slice();
        return lst;
      },
      TAG_USEALL: function(str) {
        var ret,
            open,
            close,
            end;
        ret = [""];
        open = str.indexOf("<");
        close = str.indexOf(">");
        while (open > -1 && close > -1) {
          if (open > close) {
            end = open + 1;
          } else {
            end = close + 1;
          }
          if (open < close && str.slice(open + 1, close).indexOf("<") === -1) {
            ret[ret.length - 1] += str.slice(0, open);
            ret.push(str.slice(open, close + 1));
            ret.push("");
            str = str.slice(end);
          } else {
            ret[ret.length - 1] += str.slice(0, close + 1);
            str = str.slice(end);
          }
          open = str.indexOf("<");
          close = str.indexOf(">");
        }
        ret[ret.length - 1] += str;
        return ret;
      },
      SKIP_WORDS: ["about", "above", "across", "afore", "after", "against", "along", "alongside", "amid", "amidst", "among", "amongst", "anenst", "apropos", "apud", "around", "as", "aside", "astride", "at", "athwart", "atop", "barring", "before", "behind", "below", "beneath", "beside", "besides", "between", "beyond", "but", "by", "circa", "despite", "down", "during", "except", "for", "forenenst", "from", "given", "in", "inside", "into", "lest", "like", "modulo", "near", "next", "notwithstanding", "of", "off", "on", "onto", "out", "over", "per", "plus", "pro", "qua", "sans", "since", "than", "through", " thru", "throughout", "thruout", "till", "to", "toward", "towards", "under", "underneath", "until", "unto", "up", "upon", "versus", "vs.", "v.", "vs", "v", "via", "vis--vis", "with", "within", "without", "according to", "ahead of", "apart from", "as for", "as of", "as per", "as regards", "aside from", "back to", "because of", "close to", "due to", "except for", "far from", "inside of", "instead of", "near to", "next to", "on to", "out from", "out of", "outside of", "prior to", "pursuant to", "rather than", "regardless of", "such as", "that of", "up to", "where as", "or", "yet", "so", "for", "and", "nor", "a", "an", "the", "de", "d'", "von", "van", "c", "et", "ca"],
      FORMAT_KEY_SEQUENCE: ["@strip-periods", "@font-style", "@font-variant", "@font-weight", "@text-decoration", "@vertical-align", "@quotes"],
      INSTITUTION_KEYS: ["font-style", "font-variant", "font-weight", "text-decoration", "text-case"],
      SUFFIX_CHARS: "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z",
      ROMAN_NUMERALS: [["", "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix"], ["", "x", "xx", "xxx", "xl", "l", "lx", "lxx", "lxxx", "xc"], ["", "c", "cc", "ccc", "cd", "d", "dc", "dcc", "dccc", "cm"], ["", "m", "mm", "mmm", "mmmm", "mmmmm"]],
      CREATORS: ["author", "editor", "contributor", "translator", "recipient", "interviewer", "composer", "original-author", "container-author", "collection-editor"],
      LANGS: {
        "af-ZA": "Afrikaans",
        "ar": "Arabic",
        "bg-BG": "Bulgarian",
        "ca-AD": "Catalan",
        "cs-CZ": "Czech",
        "da-DK": "Danish",
        "de-AT": "Austrian",
        "de-CH": "German (CH)",
        "de-DE": "German (DE)",
        "el-GR": "Greek",
        "en-GB": "English (GB)",
        "en-US": "English (US)",
        "es-ES": "Spanish",
        "et-EE": "Estonian",
        "eu": "European",
        "fa-IR": "Persian",
        "fi-FI": "Finnish",
        "fr-CA": "French (CA)",
        "fr-FR": "French (FR)",
        "he-IL": "Hebrew",
        "hr-HR": "Croatian",
        "hu-HU": "Hungarian",
        "is-IS": "Icelandic",
        "it-IT": "Italian",
        "ja-JP": "Japanese",
        "km-KH": "Khmer",
        "ko-KR": "Korean",
        "lt-LT": "Lithuanian",
        "lv-LV": "Latvian",
        "mn-MN": "Mongolian",
        "nb-NO": "Norwegian (Bokml)",
        "nl-NL": "Dutch",
        "nn-NO": "Norwegian (Nynorsk)",
        "pl-PL": "Polish",
        "pt-BR": "Portuguese (BR)",
        "pt-PT": "Portuguese (PT)",
        "ro-RO": "Romanian",
        "ru-RU": "Russian",
        "sk-SK": "Slovak",
        "sl-SI": "Slovenian",
        "sr-RS": "Serbian",
        "sv-SE": "Swedish",
        "th-TH": "Thai",
        "tr-TR": "Turkish",
        "uk-UA": "Ukranian",
        "vi-VN": "Vietnamese",
        "zh-CN": "Chinese (CN)",
        "zh-TW": "Chinese (TW)"
      },
      LANG_BASES: {
        af: "af_ZA",
        ar: "ar",
        bg: "bg_BG",
        ca: "ca_AD",
        cs: "cs_CZ",
        da: "da_DK",
        de: "de_DE",
        el: "el_GR",
        en: "en_US",
        es: "es_ES",
        et: "et_EE",
        eu: "eu",
        fa: "fa_IR",
        fi: "fi_FI",
        fr: "fr_FR",
        he: "he_IL",
        hr: "hr-HR",
        hu: "hu_HU",
        is: "is_IS",
        it: "it_IT",
        ja: "ja_JP",
        km: "km_KH",
        ko: "ko_KR",
        lt: "lt_LT",
        lv: "lv-LV",
        mn: "mn_MN",
        nb: "nb_NO",
        nl: "nl_NL",
        nn: "nn-NO",
        pl: "pl_PL",
        pt: "pt_PT",
        ro: "ro_RO",
        ru: "ru_RU",
        sk: "sk_SK",
        sl: "sl_SI",
        sr: "sr_RS",
        sv: "sv_SE",
        th: "th_TH",
        tr: "tr_TR",
        uk: "uk_UA",
        vi: "vi_VN",
        zh: "zh_CN"
      },
      SUPERSCRIPTS: {
        "\u00AA": "\u0061",
        "\u00B2": "\u0032",
        "\u00B3": "\u0033",
        "\u00B9": "\u0031",
        "\u00BA": "\u006F",
        "\u02B0": "\u0068",
        "\u02B1": "\u0266",
        "\u02B2": "\u006A",
        "\u02B3": "\u0072",
        "\u02B4": "\u0279",
        "\u02B5": "\u027B",
        "\u02B6": "\u0281",
        "\u02B7": "\u0077",
        "\u02B8": "\u0079",
        "\u02E0": "\u0263",
        "\u02E1": "\u006C",
        "\u02E2": "\u0073",
        "\u02E3": "\u0078",
        "\u02E4": "\u0295",
        "\u1D2C": "\u0041",
        "\u1D2D": "\u00C6",
        "\u1D2E": "\u0042",
        "\u1D30": "\u0044",
        "\u1D31": "\u0045",
        "\u1D32": "\u018E",
        "\u1D33": "\u0047",
        "\u1D34": "\u0048",
        "\u1D35": "\u0049",
        "\u1D36": "\u004A",
        "\u1D37": "\u004B",
        "\u1D38": "\u004C",
        "\u1D39": "\u004D",
        "\u1D3A": "\u004E",
        "\u1D3C": "\u004F",
        "\u1D3D": "\u0222",
        "\u1D3E": "\u0050",
        "\u1D3F": "\u0052",
        "\u1D40": "\u0054",
        "\u1D41": "\u0055",
        "\u1D42": "\u0057",
        "\u1D43": "\u0061",
        "\u1D44": "\u0250",
        "\u1D45": "\u0251",
        "\u1D46": "\u1D02",
        "\u1D47": "\u0062",
        "\u1D48": "\u0064",
        "\u1D49": "\u0065",
        "\u1D4A": "\u0259",
        "\u1D4B": "\u025B",
        "\u1D4C": "\u025C",
        "\u1D4D": "\u0067",
        "\u1D4F": "\u006B",
        "\u1D50": "\u006D",
        "\u1D51": "\u014B",
        "\u1D52": "\u006F",
        "\u1D53": "\u0254",
        "\u1D54": "\u1D16",
        "\u1D55": "\u1D17",
        "\u1D56": "\u0070",
        "\u1D57": "\u0074",
        "\u1D58": "\u0075",
        "\u1D59": "\u1D1D",
        "\u1D5A": "\u026F",
        "\u1D5B": "\u0076",
        "\u1D5C": "\u1D25",
        "\u1D5D": "\u03B2",
        "\u1D5E": "\u03B3",
        "\u1D5F": "\u03B4",
        "\u1D60": "\u03C6",
        "\u1D61": "\u03C7",
        "\u2070": "\u0030",
        "\u2071": "\u0069",
        "\u2074": "\u0034",
        "\u2075": "\u0035",
        "\u2076": "\u0036",
        "\u2077": "\u0037",
        "\u2078": "\u0038",
        "\u2079": "\u0039",
        "\u207A": "\u002B",
        "\u207B": "\u2212",
        "\u207C": "\u003D",
        "\u207D": "\u0028",
        "\u207E": "\u0029",
        "\u207F": "\u006E",
        "\u2120": "\u0053\u004D",
        "\u2122": "\u0054\u004D",
        "\u3192": "\u4E00",
        "\u3193": "\u4E8C",
        "\u3194": "\u4E09",
        "\u3195": "\u56DB",
        "\u3196": "\u4E0A",
        "\u3197": "\u4E2D",
        "\u3198": "\u4E0B",
        "\u3199": "\u7532",
        "\u319A": "\u4E59",
        "\u319B": "\u4E19",
        "\u319C": "\u4E01",
        "\u319D": "\u5929",
        "\u319E": "\u5730",
        "\u319F": "\u4EBA",
        "\u02C0": "\u0294",
        "\u02C1": "\u0295",
        "\u06E5": "\u0648",
        "\u06E6": "\u064A"
      },
      SUPERSCRIPTS_REGEXP: new RegExp("[\u00AA\u00B2\u00B3\u00B9\u00BA\u02B0\u02B1\u02B2\u02B3\u02B4\u02B5\u02B6\u02B7\u02B8\u02E0\u02E1\u02E2\u02E3\u02E4\u1D2C\u1D2D\u1D2E\u1D30\u1D31\u1D32\u1D33\u1D34\u1D35\u1D36\u1D37\u1D38\u1D39\u1D3A\u1D3C\u1D3D\u1D3E\u1D3F\u1D40\u1D41\u1D42\u1D43\u1D44\u1D45\u1D46\u1D47\u1D48\u1D49\u1D4A\u1D4B\u1D4C\u1D4D\u1D4F\u1D50\u1D51\u1D52\u1D53\u1D54\u1D55\u1D56\u1D57\u1D58\u1D59\u1D5A\u1D5B\u1D5C\u1D5D\u1D5E\u1D5F\u1D60\u1D61\u2070\u2071\u2074\u2075\u2076\u2077\u2078\u2079\u207A\u207B\u207C\u207D\u207E\u207F\u2120\u2122\u3192\u3193\u3194\u3195\u3196\u3197\u3198\u3199\u319A\u319B\u319C\u319D\u319E\u319F\u02C0\u02C1\u06E5\u06E6]", "g"),
      UPDATE_GROUP_CONTEXT_CONDITION: function(state, termtxt, valueTerm) {
        if (state.tmp.group_context.tip.condition) {
          if (state.tmp.group_context.tip.condition.test) {
            var testres;
            if (state.tmp.group_context.tip.condition.test === "empty-label") {
              testres = !termtxt;
            } else if (state.tmp.group_context.tip.condition.test === "comma-safe") {
              var empty = !termtxt;
              var alpha = termtxt.slice(0, 1).match(CSL.ALL_ROMANESQUE_REGEXP);
              var num = state.tmp.just_did_number;
              if (empty) {
                testres = true;
              } else if (num) {
                if (alpha && !valueTerm) {
                  testres = true;
                } else {
                  testres = false;
                }
              } else {
                if (alpha && !valueTerm) {
                  testres = true;
                } else {
                  testres = false;
                }
              }
            }
            if (testres) {
              state.tmp.group_context.tip.force_suppress = false;
            } else {
              state.tmp.group_context.tip.force_suppress = true;
            }
            if (state.tmp.group_context.tip.condition.not) {
              state.tmp.group_context.tip.force_suppress = !state.tmp.group_context.tip.force_suppress;
            }
          }
        } else {
          if (termtxt.slice(-1).match(/[0-9]/)) {
            state.tmp.just_did_number = true;
          } else {
            state.tmp.just_did_number = false;
          }
        }
      },
      locale: {},
      locale_opts: {},
      locale_dates: {}
    };
    if (typeof require !== "undefined" && typeof module !== 'undefined' && "exports" in module) {
      var CSL_IS_NODEJS = true;
      var CSL_NODEJS = require("./csl_nodejs_jsdom").CSL_NODEJS_JSDOM;
      exports.CSL = CSL;
    }
    CSL.TERMINAL_PUNCTUATION_REGEXP = new RegExp("^([" + CSL.TERMINAL_PUNCTUATION.slice(0, -1).join("") + "])(.*)");
    CSL.CLOSURES = new RegExp(".*[\\]\\)]");
    if ("object" === typeof console && "function" === typeof console.log) {
      CSL.debug = function(str) {
        console.log("CSL: " + str);
      };
      CSL.error = function(str) {
        console.log("CSL error: " + str);
      };
    } else {
      CSL.debug = function() {};
      CSL.error = function(str) {
        throw "CSL error: " + str;
      };
    }
    CSL.XmlJSON = function(dataObj) {
      this.dataObj = dataObj;
      this.institution = {
        name: "institution",
        attrs: {
          "institution-parts": "long",
          "delimiter": ", ",
          "substitute-use-first": "1",
          "use-last": "1"
        },
        children: [{
          name: "institution-part",
          attrs: {name: "long"},
          children: []
        }]
      };
    };
    CSL.XmlJSON.prototype.clean = function(json) {
      return json;
    };
    CSL.XmlJSON.prototype.getStyleId = function(myjson, styleName) {
      var tagName = 'id';
      if (styleName) {
        tagName = 'title';
      }
      var ret = "";
      var children = myjson.children;
      for (var i = 0,
          ilen = children.length; i < ilen; i++) {
        if (children[i].name === 'info') {
          var grandkids = children[i].children;
          for (var j = 0,
              jlen = grandkids.length; j < jlen; j++) {
            if (grandkids[j].name === tagName) {
              ret = grandkids[j].children[0];
            }
          }
        }
      }
      return ret;
    };
    CSL.XmlJSON.prototype.children = function(myjson) {
      if (myjson && myjson.children.length) {
        return myjson.children.slice();
      } else {
        return false;
      }
    };
    CSL.XmlJSON.prototype.nodename = function(myjson) {
      return myjson.name;
    };
    CSL.XmlJSON.prototype.attributes = function(myjson) {
      var ret = {};
      for (var attrname in myjson.attrs) {
        ret["@" + attrname] = myjson.attrs[attrname];
      }
      return ret;
    };
    CSL.XmlJSON.prototype.content = function(myjson) {
      var ret = "";
      if (!myjson || !myjson.children) {
        return ret;
      }
      for (var i = 0,
          ilen = myjson.children.length; i < ilen; i += 1) {
        if ("string" === typeof myjson.children[i]) {
          ret += myjson.children[i];
        }
      }
      return ret;
    };
    CSL.XmlJSON.prototype.namespace = {};
    CSL.XmlJSON.prototype.numberofnodes = function(myjson) {
      if (myjson && "number" == typeof myjson.length) {
        return myjson.length;
      } else {
        return 0;
      }
    };
    CSL.XmlJSON.prototype.getAttributeValue = function(myjson, name, namespace) {
      var ret = "";
      if (namespace) {
        name = namespace + ":" + name;
      }
      if (myjson) {
        if (myjson.attrs) {
          if (myjson.attrs[name]) {
            ret = myjson.attrs[name];
          } else {
            ret = "";
          }
        }
      }
      return ret;
    };
    CSL.XmlJSON.prototype.getNodeValue = function(myjson, name) {
      var ret = "";
      if (name) {
        for (var i = 0,
            ilen = myjson.children.length; i < ilen; i += 1) {
          if (myjson.children[i].name === name) {
            if (myjson.children[i].children.length) {
              ret = myjson.children[i];
            } else {
              ret = "";
            }
          }
        }
      } else if (myjson) {
        ret = myjson;
      }
      if (ret && ret.children && ret.children.length == 1 && "string" === typeof ret.children[0]) {
        ret = ret.children[0];
      }
      return ret;
    };
    CSL.XmlJSON.prototype.setAttributeOnNodeIdentifiedByNameAttribute = function(myjson, nodename, partname, attrname, val) {
      var pos,
          len,
          xml,
          nodes,
          node;
      if (attrname.slice(0, 1) === '@') {
        attrname = attrname.slice(1);
      }
      for (var i = 0,
          ilen = myjson.children.length; i < ilen; i += 1) {
        if (myjson.children[i].name === nodename && myjson.children[i].attrs.name === partname) {
          myjson.children[i].attrs[attrname] = val;
        }
      }
    };
    CSL.XmlJSON.prototype.deleteNodeByNameAttribute = function(myjson, val) {
      var i,
          ilen;
      for (i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
        if (!myjson.children[i] || "string" === typeof myjson.children[i]) {
          continue;
        }
        if (myjson.children[i].attrs.name == val) {
          myjson.children = myjson.children.slice(0, i).concat(myjson.children.slice(i + 1));
        }
      }
    };
    CSL.XmlJSON.prototype.deleteAttribute = function(myjson, attrname) {
      var i,
          ilen;
      if ("undefined" !== typeof myjson.attrs[attrname]) {
        myjson.attrs.pop(attrname);
      }
    };
    CSL.XmlJSON.prototype.setAttribute = function(myjson, attr, val) {
      myjson.attrs[attr] = val;
      return false;
    };
    CSL.XmlJSON.prototype.nodeCopy = function(myjson, clone) {
      if (!clone) {
        var clone = {};
      }
      if ("object" === typeof clone && "undefined" === typeof clone.length) {
        for (var key in myjson) {
          if ("string" === typeof myjson[key]) {
            clone[key] = myjson[key];
          } else if ("object" === typeof myjson[key]) {
            if ("undefined" === typeof myjson[key].length) {
              clone[key] = this.nodeCopy(myjson[key], {});
            } else {
              clone[key] = this.nodeCopy(myjson[key], []);
            }
          }
        }
      } else {
        for (var i = 0,
            ilen = myjson.length; i < ilen; i += 1) {
          if ("string" === typeof myjson[i]) {
            clone[i] = myjson[i];
          } else {
            clone[i] = this.nodeCopy(myjson[i], {});
          }
        }
      }
      return clone;
    };
    CSL.XmlJSON.prototype.getNodesByName = function(myjson, name, nameattrval, ret) {
      var nodes,
          node,
          pos,
          len;
      if (!ret) {
        var ret = [];
      }
      if (!myjson || !myjson.children) {
        return ret;
      }
      if (name === myjson.name) {
        if (nameattrval) {
          if (nameattrval === myjson.attrs.name) {
            ret.push(myjson);
          }
        } else {
          ret.push(myjson);
        }
      }
      for (var i = 0,
          ilen = myjson.children.length; i < ilen; i += 1) {
        if ("object" !== typeof myjson.children[i]) {
          continue;
        }
        this.getNodesByName(myjson.children[i], name, nameattrval, ret);
      }
      return ret;
    };
    CSL.XmlJSON.prototype.nodeNameIs = function(myjson, name) {
      if (name == myjson.name) {
        return true;
      }
      return false;
    };
    CSL.XmlJSON.prototype.makeXml = function(myjson) {
      if ("string" === typeof myjson) {
        if (myjson.slice(0, 1) === "<") {
          myjson = this.jsonStringWalker.walkToObject(myjson);
        } else {
          myjson = JSON.parse(myjson);
        }
      }
      return myjson;
    };
    CSL.XmlJSON.prototype.insertChildNodeAfter = function(parent, node, pos, datejson) {
      for (var i = 0,
          ilen = parent.children.length; i < ilen; i += 1) {
        if (node === parent.children[i]) {
          parent.children = parent.children.slice(0, i).concat([datejson]).concat(parent.children.slice(i + 1));
          break;
        }
      }
      return parent;
    };
    CSL.XmlJSON.prototype.insertPublisherAndPlace = function(myjson) {
      if (myjson.name === "group") {
        var useme = true;
        var mustHaves = ["publisher", "publisher-place"];
        for (var i = 0,
            ilen = myjson.children.length; i < ilen; i += 1) {
          var haveVarname = mustHaves.indexOf(myjson.children[i].attrs.variable);
          var isText = myjson.children[i].name === "text";
          if (isText && haveVarname > -1 && !myjson.children[i].attrs.prefix && !myjson.children[i].attrs.suffix) {
            mustHaves = mustHaves.slice(0, haveVarname).concat(mustHaves.slice(haveVarname + 1));
          } else {
            useme = false;
            break;
          }
        }
        if (useme && !mustHaves.length) {
          myjson.attrs["has-publisher-and-publisher-place"] = true;
        }
      }
      for (var i = 0,
          ilen = myjson.children.length; i < ilen; i += 1) {
        if ("object" === typeof myjson.children[i]) {
          this.insertPublisherAndPlace(myjson.children[i]);
        }
      }
    };
    CSL.XmlJSON.prototype.isChildOfSubstitute = function(parents) {
      if (parents.length > 0) {
        var myparents = parents.slice();
        var parent = myparents.pop();
        if (parent === "substitute") {
          return true;
        } else {
          return this.isChildOfSubstitute(myparents);
        }
      }
      return false;
    };
    CSL.XmlJSON.prototype.addMissingNameNodes = function(myjson, parents) {
      if (!parents) {
        parents = [];
      }
      if (myjson.name === "names") {
        if (!this.isChildOfSubstitute(parents)) {
          var addName = true;
          for (var i = 0,
              ilen = myjson.children.length; i < ilen; i++) {
            if (myjson.children[i].name === "name") {
              addName = false;
              break;
            }
          }
          if (addName) {
            myjson.children = [{
              name: "name",
              attrs: {},
              children: []
            }].concat(myjson.children);
          }
        }
      }
      parents.push(myjson.name);
      for (var i = 0,
          ilen = myjson.children.length; i < ilen; i += 1) {
        if ("object" === typeof myjson.children[i]) {
          this.addMissingNameNodes(myjson.children[i], parents);
        }
      }
      parents.pop();
    };
    CSL.XmlJSON.prototype.addInstitutionNodes = function(myjson) {
      var names,
          thenames,
          institution,
          theinstitution,
          name,
          thename,
          xml,
          pos,
          len;
      if (myjson.name === "names") {
        var attributes = {};
        var insertPos = -1;
        for (var i = 0,
            ilen = myjson.children.length; i < ilen; i += 1) {
          if (myjson.children[i].name == "name") {
            for (var key in myjson.children[i].attrs) {
              attributes[key] = myjson.children[i].attrs[key];
            }
            attributes.delimiter = myjson.children[i].attrs.delimiter;
            attributes.and = myjson.children[i].attrs.and;
            insertPos = i;
            for (var k = 0,
                klen = myjson.children[i].children.length; k < klen; k += 1) {
              if (myjson.children[i].children[k].attrs.name !== 'family') {
                continue;
              }
              for (var key in myjson.children[i].children[k].attrs) {
                attributes[key] = myjson.children[i].children[k].attrs[key];
              }
            }
          }
          if (myjson.children[i].name == "institution") {
            insertPos = -1;
            break;
          }
        }
        if (insertPos > -1) {
          var institution = this.nodeCopy(this.institution);
          for (var i = 0,
              ilen = CSL.INSTITUTION_KEYS.length; i < ilen; i += 1) {
            var attrname = CSL.INSTITUTION_KEYS[i];
            if ("undefined" !== typeof attributes[attrname]) {
              institution.children[0].attrs[attrname] = attributes[attrname];
            }
            if (attributes.delimiter) {
              institution.attrs.delimiter = attributes.delimiter;
            }
            if (attributes.and) {
              institution.attrs.and = "text";
            }
          }
          myjson.children = myjson.children.slice(0, insertPos + 1).concat([institution]).concat(myjson.children.slice(insertPos + 1));
        }
      }
      for (var i = 0,
          ilen = myjson.children.length; i < ilen; i += 1) {
        if ("string" === typeof myjson.children[i]) {
          continue;
        }
        this.addInstitutionNodes(myjson.children[i]);
      }
    };
    CSL.XmlJSON.prototype.flagDateMacros = function(myjson) {
      for (var i = 0,
          ilen = myjson.children.length; i < ilen; i += 1) {
        if (myjson.children[i].name === "macro") {
          if (this.inspectDateMacros(myjson.children[i])) {
            myjson.children[i].attrs["macro-has-date"] = "true";
          }
        }
      }
    };
    CSL.XmlJSON.prototype.inspectDateMacros = function(myjson) {
      if (!myjson || !myjson.children) {
        return false;
      }
      if (myjson.name === "date") {
        return true;
      } else {
        for (var i = 0,
            ilen = myjson.children.length; i < ilen; i += 1) {
          if (this.inspectDateMacros(myjson.children[i])) {
            return true;
          }
        }
      }
      return false;
    };
    CSL.stripXmlProcessingInstruction = function(xml) {
      if (!xml) {
        return xml;
      }
      xml = xml.replace(/^<\?[^?]+\?>/, "");
      xml = xml.replace(/<!--[^>]+-->/g, "");
      xml = xml.replace(/^\s+/g, "");
      xml = xml.replace(/\s+$/g, "");
      return xml;
    };
    CSL.parseXml = function(str) {
      var _pos = 0;
      var _obj = {children: []};
      var _stack = [_obj.children];
      function _listifyString(str) {
        str = str.split(/(?:\r\n|\n|\r)/).join(" ").replace(/>[	 ]+</g, "><").replace(/<\!--.*?-->/g, "");
        var lst = str.split("><");
        var stylePos = null;
        for (var i = 0,
            ilen = lst.length; i < ilen; i++) {
          if (i > 0) {
            lst[i] = "<" + lst[i];
          }
          if (i < (lst.length - 1)) {
            lst[i] = lst[i] + ">";
          }
          if ("number" != typeof stylePos) {
            if (lst[i].slice(0, 7) === "<style " || lst[i].slice(0, 8) == "<locale ") {
              stylePos = i;
            }
          }
        }
        lst = lst.slice(stylePos);
        for (var i = lst.length - 2; i > -1; i--) {
          if (lst[i].slice(1).indexOf("<") === -1) {
            var stub = lst[i].slice(0, 5);
            if (stub === "<term") {
              if (lst[i + 1].slice(0, 6) === "</term") {
                lst[i] = lst[i] + lst[i + 1];
                lst = lst.slice(0, i + 1).concat(lst.slice(i + 2));
              }
            } else if (["<sing", "<mult"].indexOf(stub) > -1) {
              if (lst[i].slice(-2) !== "/>" && lst[i + 1].slice(0, 1) === "<") {
                lst[i] = lst[i] + lst[i + 1];
                lst = lst.slice(0, i + 1).concat(lst.slice(i + 2));
              }
            }
          }
        }
        return lst;
      }
      function _decodeHtmlEntities(str) {
        return str.split("&amp;").join("&").split("&quot;").join("\"").split("&gt;").join(">").split("&lt;").join("<").replace(/&#([0-9]{1,6});/gi, function(match, numStr) {
          var num = parseInt(numStr, 10);
          return String.fromCharCode(num);
        }).replace(/&#x([a-f0-9]{1,6});/gi, function(match, numStr) {
          var num = parseInt(numStr, 16);
          return String.fromCharCode(num);
        });
      }
      function _getAttributes(elem) {
        var m = elem.match(/([^\'\"=	 ]+)=(?:\"[^\"]*\"|\'[^\']*\')/g);
        if (m) {
          for (var i = 0,
              ilen = m.length; i < ilen; i++) {
            m[i] = m[i].replace(/=.*/, "");
          }
        }
        return m;
      }
      function _getAttribute(elem, attr) {
        var rex = RegExp('^.*[	 ]+' + attr + '=(\"(?:[^\"]*)\"|\'(?:[^\']*)\').*$');
        var m = elem.match(rex);
        return m ? m[1].slice(1, -1) : null;
      }
      function _getTagName(elem) {
        var rex = RegExp("^<([^	 />]+)");
        var m = elem.match(rex);
        return m ? m[1] : null;
      }
      function _castObjectFromOpeningTag(elem) {
        var obj = {};
        obj.name = _getTagName(elem);
        obj.attrs = {};
        var attributes = _getAttributes(elem);
        if (attributes) {
          for (var i = 0,
              ilen = attributes.length; i < ilen; i++) {
            var attr = {
              name: attributes[i],
              value: _getAttribute(elem, attributes[i])
            };
            obj.attrs[attr.name] = _decodeHtmlEntities(attr.value);
          }
        }
        obj.children = [];
        return obj;
      }
      function _extractTextFromCompositeElement(elem) {
        var m = elem.match(/^.*>([^<]*)<.*$/);
        return _decodeHtmlEntities(m[1]);
      }
      function _appendToChildren(obj) {
        _stack.slice(-1)[0].push(obj);
      }
      function _extendStackWithNewChildren(obj) {
        _stack.push(obj.children);
      }
      function processElement(elem) {
        var obj;
        if (elem.slice(1).indexOf('<') > -1) {
          var tag = elem.slice(0, elem.indexOf('>') + 1);
          obj = _castObjectFromOpeningTag(tag);
          obj.children = [_extractTextFromCompositeElement(elem)];
          _appendToChildren(obj);
        } else if (elem.slice(-2) === '/>') {
          obj = _castObjectFromOpeningTag(elem);
          if (_getTagName(elem) === 'term') {
            obj.children.push('');
          }
          _appendToChildren(obj);
        } else if (elem.slice(0, 2) === '</') {
          _stack.pop();
        } else {
          obj = _castObjectFromOpeningTag(elem);
          _appendToChildren(obj);
          _extendStackWithNewChildren(obj);
        }
      }
      var lst = _listifyString(str);
      for (var i = 0,
          ilen = lst.length; i < ilen; i++) {
        var elem = lst[i];
        processElement(elem);
      }
      return _obj.children[0];
    };
    CSL.XmlDOM = function(dataObj) {
      this.dataObj = dataObj;
      if ("undefined" == typeof DOMParser) {
        DOMParser = function() {};
        DOMParser.prototype.parseFromString = function(str, contentType) {
          if ("undefined" != typeof ActiveXObject) {
            var xmldata = new ActiveXObject('MSXML.DomDocument');
            xmldata.async = false;
            xmldata.loadXML(str);
            return xmldata;
          } else if ("undefined" != typeof XMLHttpRequest) {
            var xmldata = new XMLHttpRequest;
            if (!contentType) {
              contentType = 'text/xml';
            }
            xmldata.open('GET', 'data:' + contentType + ';charset=utf-8,' + encodeURIComponent(str), false);
            if (xmldata.overrideMimeType) {
              xmldata.overrideMimeType(contentType);
            }
            xmldata.send(null);
            return xmldata.responseXML;
          } else if ("undefined" != typeof marknote) {
            var parser = new marknote.Parser();
            return parser.parse(str);
          }
        };
        this.hasAttributes = function(node) {
          var ret;
          if (node.attributes && node.attributes.length) {
            ret = true;
          } else {
            ret = false;
          }
          return ret;
        };
      } else {
        this.hasAttributes = function(node) {
          var ret;
          if (node.attributes && node.attributes.length) {
            ret = true;
          } else {
            ret = false;
          }
          return ret;
        };
      }
      this.importNode = function(doc, srcElement) {
        if ("undefined" == typeof doc.importNode) {
          var ret = this._importNode(doc, srcElement, true);
        } else {
          var ret = doc.importNode(srcElement, true);
        }
        return ret;
      };
      this._importNode = function(doc, node, allChildren) {
        switch (node.nodeType) {
          case 1:
            var newNode = doc.createElement(node.nodeName);
            if (node.attributes && node.attributes.length > 0)
              for (var i = 0,
                  il = node.attributes.length; i < il; )
                newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i++].nodeName));
            if (allChildren && node.childNodes && node.childNodes.length > 0)
              for (var i = 0,
                  il = node.childNodes.length; i < il; )
                newNode.appendChild(this._importNode(doc, node.childNodes[i++], allChildren));
            return newNode;
            break;
          case 3:
          case 4:
          case 8:
        }
      };
      this.parser = new DOMParser();
      var str = "<docco><institution institution-parts=\"long\" delimiter=\", \" substitute-use-first=\"1\" use-last=\"1\"><institution-part name=\"long\"/></institution></docco>";
      var inst_doc = this.parser.parseFromString(str, "text/xml");
      var inst_node = inst_doc.getElementsByTagName("institution");
      this.institution = inst_node.item(0);
      var inst_part_node = inst_doc.getElementsByTagName("institution-part");
      this.institutionpart = inst_part_node.item(0);
      this.ns = "http://purl.org/net/xbiblio/csl";
    };
    CSL.XmlDOM.prototype.clean = function(xml) {
      xml = xml.replace(/<\?[^?]+\?>/g, "");
      xml = xml.replace(/<![^>]+>/g, "");
      xml = xml.replace(/^\s+/, "");
      xml = xml.replace(/\s+$/, "");
      xml = xml.replace(/^\n*/, "");
      return xml;
    };
    CSL.XmlDOM.prototype.getStyleId = function(myxml, styleName) {
      var text = "";
      var tagName = "id";
      if (styleName) {
        tagName = "title";
      }
      var node = myxml.getElementsByTagName(tagName);
      if (node && node.length) {
        node = node.item(0);
      }
      if (node) {
        text = node.textContent;
      }
      if (!text) {
        text = node.innerText;
      }
      if (!text) {
        text = node.innerHTML;
      }
      return text;
    };
    CSL.XmlDOM.prototype.children = function(myxml) {
      var children,
          pos,
          len,
          ret;
      if (myxml) {
        ret = [];
        children = myxml.childNodes;
        for (pos = 0, len = children.length; pos < len; pos += 1) {
          if (children[pos].nodeName != "#text") {
            ret.push(children[pos]);
          }
        }
        return ret;
      } else {
        return [];
      }
    };
    CSL.XmlDOM.prototype.nodename = function(myxml) {
      var ret = myxml.nodeName;
      return ret;
    };
    CSL.XmlDOM.prototype.attributes = function(myxml) {
      var ret,
          attrs,
          attr,
          key,
          xml,
          pos,
          len;
      ret = new Object();
      if (myxml && this.hasAttributes(myxml)) {
        attrs = myxml.attributes;
        for (pos = 0, len = attrs.length; pos < len; pos += 1) {
          attr = attrs[pos];
          ret["@" + attr.name] = attr.value;
        }
      }
      return ret;
    };
    CSL.XmlDOM.prototype.content = function(myxml) {
      var ret;
      if ("undefined" != typeof myxml.textContent) {
        ret = myxml.textContent;
      } else if ("undefined" != typeof myxml.innerText) {
        ret = myxml.innerText;
      } else {
        ret = myxml.txt;
      }
      return ret;
    };
    CSL.XmlDOM.prototype.namespace = {"xml": "http://www.w3.org/XML/1998/namespace"};
    CSL.XmlDOM.prototype.numberofnodes = function(myxml) {
      if (myxml) {
        return myxml.length;
      } else {
        return 0;
      }
    };
    CSL.XmlDOM.prototype.getAttributeName = function(attr) {
      var ret = attr.name;
      return ret;
    };
    CSL.XmlDOM.prototype.getAttributeValue = function(myxml, name, namespace) {
      var ret = "";
      if (namespace) {
        name = namespace + ":" + name;
      }
      if (myxml && this.hasAttributes(myxml) && myxml.getAttribute(name)) {
        ret = myxml.getAttribute(name);
      }
      return ret;
    };
    CSL.XmlDOM.prototype.getNodeValue = function(myxml, name) {
      var ret = null;
      if (name) {
        var vals = myxml.getElementsByTagName(name);
        if (vals.length > 0) {
          if ("undefined" != typeof vals[0].textContent) {
            ret = vals[0].textContent;
          } else if ("undefined" != typeof vals[0].innerText) {
            ret = vals[0].innerText;
          } else {
            ret = vals[0].text;
          }
        }
      }
      if (ret === null && myxml && myxml.childNodes && (myxml.childNodes.length == 0 || (myxml.childNodes.length == 1 && myxml.firstChild.nodeName == "#text"))) {
        if ("undefined" != typeof myxml.textContent) {
          ret = myxml.textContent;
        } else if ("undefined" != typeof myxml.innerText) {
          ret = myxml.innerText;
        } else {
          ret = myxml.text;
        }
      }
      if (ret === null) {
        ret = myxml;
      }
      return ret;
    };
    CSL.XmlDOM.prototype.setAttributeOnNodeIdentifiedByNameAttribute = function(myxml, nodename, partname, attrname, val) {
      var pos,
          len,
          xml,
          nodes,
          node;
      if (attrname.slice(0, 1) === '@') {
        attrname = attrname.slice(1);
      }
      nodes = myxml.getElementsByTagName(nodename);
      for (pos = 0, len = nodes.length; pos < len; pos += 1) {
        node = nodes[pos];
        if (node.getAttribute("name") != partname) {
          continue;
        }
        node.setAttribute(attrname, val);
      }
    };
    CSL.XmlDOM.prototype.deleteNodeByNameAttribute = function(myxml, val) {
      var pos,
          len,
          node,
          nodes;
      nodes = myxml.childNodes;
      for (pos = 0, len = nodes.length; pos < len; pos += 1) {
        node = nodes[pos];
        if (!node || node.nodeType == node.TEXT_NODE) {
          continue;
        }
        if (this.hasAttributes(node) && node.getAttribute("name") == val) {
          myxml.removeChild(nodes[pos]);
        }
      }
    };
    CSL.XmlDOM.prototype.deleteAttribute = function(myxml, attr) {
      myxml.removeAttribute(attr);
    };
    CSL.XmlDOM.prototype.setAttribute = function(myxml, attr, val) {
      if (!myxml.ownerDocument) {
        myxml = myxml.firstChild;
      }
      if (["function", "unknown"].indexOf(typeof myxml.setAttribute) > -1) {
        myxml.setAttribute(attr, val);
      }
      return false;
    };
    CSL.XmlDOM.prototype.nodeCopy = function(myxml) {
      var cloned_node = myxml.cloneNode(true);
      return cloned_node;
    };
    CSL.XmlDOM.prototype.getNodesByName = function(myxml, name, nameattrval) {
      var ret,
          nodes,
          node,
          pos,
          len;
      ret = [];
      nodes = myxml.getElementsByTagName(name);
      for (pos = 0, len = nodes.length; pos < len; pos += 1) {
        node = nodes.item(pos);
        if (nameattrval && !(this.hasAttributes(node) && node.getAttribute("name") == nameattrval)) {
          continue;
        }
        ret.push(node);
      }
      return ret;
    };
    CSL.XmlDOM.prototype.nodeNameIs = function(myxml, name) {
      if (name == myxml.nodeName) {
        return true;
      }
      return false;
    };
    CSL.XmlDOM.prototype.makeXml = function(myxml) {
      var ret,
          topnode;
      if (!myxml) {
        myxml = "<docco><bogus/></docco>";
      }
      myxml = myxml.replace(/\s*<\?[^>]*\?>\s*\n*/g, "");
      var nodetree = this.parser.parseFromString(myxml, "application/xml");
      return nodetree.firstChild;
    };
    CSL.XmlDOM.prototype.insertChildNodeAfter = function(parent, node, pos, datexml) {
      var myxml,
          xml;
      myxml = this.importNode(node.ownerDocument, datexml);
      parent.replaceChild(myxml, node);
      return parent;
    };
    CSL.XmlDOM.prototype.insertPublisherAndPlace = function(myxml) {
      var group = myxml.getElementsByTagName("group");
      for (var i = 0,
          ilen = group.length; i < ilen; i += 1) {
        var node = group.item(i);
        var skippers = [];
        for (var j = 0,
            jlen = node.childNodes.length; j < jlen; j += 1) {
          if (node.childNodes.item(j).nodeType !== 1) {
            skippers.push(j);
          }
        }
        if (node.childNodes.length - skippers.length === 2) {
          var twovars = [];
          for (var j = 0,
              jlen = 2; j < jlen; j += 1) {
            if (skippers.indexOf(j) > -1) {
              continue;
            }
            var child = node.childNodes.item(j);
            var subskippers = [];
            for (var k = 0,
                klen = child.childNodes.length; k < klen; k += 1) {
              if (child.childNodes.item(k).nodeType !== 1) {
                subskippers.push(k);
              }
            }
            if (child.childNodes.length - subskippers.length === 0) {
              twovars.push(child.getAttribute('variable'));
              if (child.getAttribute('suffix') || child.getAttribute('prefix')) {
                twovars = [];
                break;
              }
            }
          }
          if (twovars.indexOf("publisher") > -1 && twovars.indexOf("publisher-place") > -1) {
            node.setAttribute('has-publisher-and-publisher-place', true);
          }
        }
      }
    };
    CSL.XmlDOM.prototype.isChildOfSubstitute = function(node) {
      if (node.parentNode) {
        if (node.parentNode.tagName.toLowerCase() === "substitute") {
          return true;
        } else {
          return this.isChildOfSubstitute(node.parentNode);
        }
      }
      return false;
    };
    CSL.XmlDOM.prototype.addMissingNameNodes = function(myxml) {
      var nameslist = myxml.getElementsByTagName("names");
      for (var i = 0,
          ilen = nameslist.length; i < ilen; i += 1) {
        var names = nameslist.item(i);
        var namelist = names.getElementsByTagName("name");
        if ((!namelist || namelist.length === 0) && !this.isChildOfSubstitute(names)) {
          var doc = names.ownerDocument;
          var name = doc.createElement("name");
          names.appendChild(name);
        }
      }
    };
    CSL.XmlDOM.prototype.addInstitutionNodes = function(myxml) {
      var names,
          thenames,
          institution,
          theinstitution,
          name,
          thename,
          xml,
          pos,
          len;
      names = myxml.getElementsByTagName("names");
      for (pos = 0, len = names.length; pos < len; pos += 1) {
        thenames = names.item(pos);
        name = thenames.getElementsByTagName("name");
        if (name.length == 0) {
          continue;
        }
        institution = thenames.getElementsByTagName("institution");
        if (institution.length == 0) {
          theinstitution = this.importNode(myxml.ownerDocument, this.institution);
          theinstitutionpart = theinstitution.getElementsByTagName("institution-part").item(0);
          thename = name.item(0);
          thenames.insertBefore(theinstitution, thename.nextSibling);
          for (var j = 0,
              jlen = CSL.INSTITUTION_KEYS.length; j < jlen; j += 1) {
            var attrname = CSL.INSTITUTION_KEYS[j];
            var attrval = thename.getAttribute(attrname);
            if (attrval) {
              theinstitutionpart.setAttribute(attrname, attrval);
            }
          }
          var nameparts = thename.getElementsByTagName("name-part");
          for (var j = 0,
              jlen = nameparts.length; j < jlen; j += 1) {
            if ('family' === nameparts[j].getAttribute('name')) {
              for (var k = 0,
                  klen = CSL.INSTITUTION_KEYS.length; k < klen; k += 1) {
                var attrname = CSL.INSTITUTION_KEYS[k];
                var attrval = nameparts[j].getAttribute(attrname);
                if (attrval) {
                  theinstitutionpart.setAttribute(attrname, attrval);
                }
              }
            }
          }
        }
      }
    };
    CSL.XmlDOM.prototype.flagDateMacros = function(myxml) {
      var pos,
          len,
          thenode,
          thedate;
      nodes = myxml.getElementsByTagName("macro");
      for (pos = 0, len = nodes.length; pos < len; pos += 1) {
        thenode = nodes.item(pos);
        thedate = thenode.getElementsByTagName("date");
        if (thedate.length) {
          thenode.setAttribute('macro-has-date', 'true');
        }
      }
    };
    if ("undefined" !== typeof XML) {
      try {} catch (e) {
        throw "OOPS: " + e;
      }
    }
    CSL.setupXml = function(xmlObject) {
      var dataObj = {};
      var parser = null;
      if ("undefined" !== typeof xmlObject) {
        if ("string" === typeof xmlObject) {
          xmlObject = xmlObject.replace("^\uFEFF", "").replace(/^\s+/, "");
          if (xmlObject.slice(0, 1) === "<") {
            dataObj = CSL.parseXml(xmlObject);
          } else {
            dataObj = JSON.parse(xmlObject);
          }
          parser = new CSL.XmlJSON(dataObj);
        } else if ("undefined" !== typeof xmlObject.getAttribute) {
          parser = new CSL.XmlDOM(xmlObject);
        } else if ("undefined" !== typeof xmlObject.toXMLString) {
          parser = new CSL.XmlE4X(xmlObject);
        } else {
          parser = new CSL.XmlJSON(xmlObject);
        }
      } else {
        print("OUCH!");
      }
      if (!parser) {
        throw "citeproc-js error: unable to parse style or locale object";
      }
      return parser;
    };
    CSL.getSortCompare = function(default_locale) {
      if (CSL.stringCompare) {
        return CSL.stringCompare;
      }
      var strcmp;
      var strcmp_opts = {
        sensitivity: "base",
        ignorePunctuation: true,
        numeric: true
      };
      if (!default_locale) {
        default_locale = "en-US";
      }
      strcmp = function(a, b) {
        return a.toLocaleLowerCase().localeCompare(b.toLocaleLowerCase(), default_locale, strcmp_opts);
      };
      var stripPunct = function(str) {
        return str.replace(/^[\[\]\'\"]*/g, "");
      };
      var getBracketPreSort = function() {
        if (!strcmp("[x", "x")) {
          return false;
        } else {
          return function(a, b) {
            return strcmp(stripPunct(a), stripPunct(b));
          };
        }
      };
      var bracketPreSort = getBracketPreSort();
      var sortCompare = function(a, b) {
        if (bracketPreSort) {
          return bracketPreSort(a, b);
        } else {
          return strcmp(a, b);
        }
      };
      return sortCompare;
    };
    CSL.ambigConfigDiff = function(a, b) {
      var ret,
          pos,
          len,
          ppos,
          llen;
      if (a.names.length !== b.names.length) {
        return 1;
      } else {
        for (pos = 0, len = a.names.length; pos < len; pos += 1) {
          if (a.names[pos] !== b.names[pos]) {
            return 1;
          } else {
            for (ppos = 0, llen = a.givens[pos]; ppos < llen; ppos += 1) {
              if (a.givens[pos][ppos] !== b.givens[pos][ppos]) {
                return 1;
              }
            }
          }
        }
      }
      if (a.disambiguate != b.disambiguate) {
        return 1;
      }
      if (a.year_suffix !== b.year_suffix) {
        return 1;
      }
      return 0;
    };
    CSL.cloneAmbigConfig = function(config, oldconfig, tainters) {
      var i,
          ilen,
          j,
          jlen,
          k,
          klen,
          param;
      var ret = {};
      ret.names = [];
      ret.givens = [];
      ret.year_suffix = false;
      ret.disambiguate = false;
      for (i = 0, ilen = config.names.length; i < ilen; i += 1) {
        param = config.names[i];
        ret.names[i] = param;
      }
      for (i = 0, ilen = config.givens.length; i < ilen; i += 1) {
        param = [];
        for (j = 0, jlen = config.givens[i].length; j < jlen; j += 1) {
          param.push(config.givens[i][j]);
        }
        ret.givens.push(param);
      }
      if (oldconfig) {
        ret.year_suffix = oldconfig.year_suffix;
        ret.disambiguate = oldconfig.disambiguate;
      } else {
        ret.year_suffix = config.year_suffix;
        ret.disambiguate = config.disambiguate;
      }
      return ret;
    };
    CSL.getAmbigConfig = function() {
      var config,
          ret;
      config = this.tmp.disambig_request;
      if (!config) {
        config = this.tmp.disambig_settings;
      }
      ret = CSL.cloneAmbigConfig(config);
      return ret;
    };
    CSL.getMaxVals = function() {
      return this.tmp.names_max.mystack.slice();
    };
    CSL.getMinVal = function() {
      return this.tmp["et-al-min"];
    };
    CSL.tokenExec = function(token, Item, item) {
      var next,
          maybenext,
          exec,
          debug;
      debug = false;
      next = token.next;
      maybenext = false;
      var record = function(result) {
        if (result) {
          this.tmp.jump.replace("succeed");
          return token.succeed;
        } else {
          this.tmp.jump.replace("fail");
          return token.fail;
        }
      };
      if (token.test) {
        next = record.call(this, token.test(Item, item));
      }
      for (var i = 0,
          ilen = token.execs.length; i < ilen; i++) {
        exec = token.execs[i];
        maybenext = exec.call(token, this, Item, item);
        if (maybenext) {
          next = maybenext;
        }
      }
      return next;
    };
    CSL.expandMacro = function(macro_key_token, target) {
      var mkey,
          start_token,
          key,
          end_token,
          navi,
          macro_nodes,
          newoutput,
          mergeoutput,
          end_of_macro,
          func;
      mkey = macro_key_token.postponed_macro;
      macro_key_token = new CSL.Token("group", CSL.START);
      var hasDate = false;
      var macroid = false;
      macro_nodes = this.cslXml.getNodesByName(this.cslXml.dataObj, 'macro', mkey);
      if (macro_nodes.length) {
        macroid = this.cslXml.getAttributeValue(macro_nodes[0], 'cslid');
        hasDate = this.cslXml.getAttributeValue(macro_nodes[0], "macro-has-date");
      }
      if (hasDate) {
        mkey = mkey + "@" + this.build.current_default_locale;
        func = function(state, Item) {
          if (state.tmp.extension) {
            state.tmp["doing-macro-with-date"] = true;
          }
        };
        macro_key_token.execs.push(func);
      }
      if (this.build.macro_stack.indexOf(mkey) > -1) {
        throw "CSL processor error: call to macro \"" + mkey + "\" would cause an infinite loop";
      } else {
        this.build.macro_stack.push(mkey);
      }
      macro_key_token.cslid = macroid;
      if (CSL.MODULE_MACROS[mkey]) {
        macro_key_token.juris = mkey;
        this.opt.update_mode = CSL.POSITION;
      }
      CSL.Node.group.build.call(macro_key_token, this, target, true);
      if (!this.cslXml.getNodeValue(macro_nodes)) {
        throw "CSL style error: undefined macro \"" + mkey + "\"";
      }
      var mytarget = CSL.getMacroTarget.call(this, mkey);
      if (mytarget) {
        CSL.buildMacro.call(this, mytarget, macro_nodes);
        CSL.configureMacro.call(this, mytarget);
      }
      if (!this.build.extension) {
        var func = function(macro_name) {
          return function(state, Item, item) {
            var next = 0;
            while (next < state.macros[macro_name].length) {
              next = CSL.tokenExec.call(state, state.macros[macro_name][next], Item, item);
            }
          };
        }(mkey);
        var text_node = new CSL.Token("text", CSL.SINGLETON);
        text_node.execs.push(func);
        target.push(text_node);
      }
      end_of_macro = new CSL.Token("group", CSL.END);
      if (hasDate) {
        func = function(state, Item) {
          if (state.tmp.extension) {
            state.tmp["doing-macro-with-date"] = false;
          }
        };
        end_of_macro.execs.push(func);
      }
      if (macro_key_token.juris) {
        end_of_macro.juris = mkey;
      }
      CSL.Node.group.build.call(end_of_macro, this, target, true);
      this.build.macro_stack.pop();
    };
    CSL.getMacroTarget = function(mkey) {
      var mytarget = false;
      if (this.build.extension) {
        mytarget = this[this.build.root + this.build.extension].tokens;
      } else if (!this.macros[mkey]) {
        mytarget = [];
        this.macros[mkey] = mytarget;
      }
      return mytarget;
    };
    CSL.buildMacro = function(mytarget, macro_nodes) {
      var builder = CSL.makeBuilder(this, mytarget);
      var mynode;
      if ("undefined" === typeof macro_nodes.length) {
        mynode = macro_nodes;
      } else {
        mynode = macro_nodes[0];
      }
      builder(mynode);
    };
    CSL.configureMacro = function(mytarget) {
      if (!this.build.extension) {
        this.configureTokenList(mytarget);
      }
    };
    CSL.XmlToToken = function(state, tokentype, explicitTarget) {
      var name,
          txt,
          attrfuncs,
          attributes,
          decorations,
          token,
          key,
          target;
      name = state.cslXml.nodename(this);
      if (state.build.skip && state.build.skip !== name) {
        return;
      }
      if (!name) {
        txt = state.cslXml.content(this);
        if (txt) {
          state.build.text = txt;
        }
        return;
      }
      if (!CSL.Node[state.cslXml.nodename(this)]) {
        throw "Undefined node name \"" + name + "\".";
      }
      attrfuncs = [];
      attributes = state.cslXml.attributes(this);
      decorations = CSL.setDecorations.call(this, state, attributes);
      token = new CSL.Token(name, tokentype);
      if (tokentype !== CSL.END || name === "if" || name === "else-if" || name === "layout") {
        for (key in attributes) {
          if (attributes.hasOwnProperty(key)) {
            if (tokentype === CSL.END && key !== "@language" && key !== "@locale") {
              continue;
            }
            if (attributes.hasOwnProperty(key)) {
              if (CSL.Attributes[key]) {
                try {
                  CSL.Attributes[key].call(token, state, "" + attributes[key]);
                } catch (e) {
                  CSL.error(e);
                  throw "CSL processor error, " + key + " attribute: " + e;
                }
              } else {
                CSL.debug("warning: undefined attribute \"" + key + "\" in style");
              }
            }
          }
        }
        token.decorations = decorations;
      } else if (tokentype === CSL.END && attributes['@variable']) {
        token.hasVariable = true;
        if (CSL.DATE_VARIABLES.indexOf(attributes['@variable']) > -1) {
          token.variables = attributes['@variable'].split(/\s+/);
        }
      }
      if (explicitTarget) {
        target = explicitTarget;
      } else {
        target = state[state.build.area].tokens;
      }
      CSL.Node[name].build.call(token, state, target, true);
    };
    CSL.DateParser = new function() {
      var epochPairs = [["\u660E\u6CBB", 1867], ["\u5927\u6B63", 1911], ["\u662D\u548C", 1925], ["\u5E73\u6210", 1988]];
      var epochYearByName = {};
      for (var i = 0,
          ilen = epochPairs.length; i < ilen; i++) {
        var key = epochPairs[i][0];
        var val = epochPairs[i][1];
        epochYearByName[key] = val;
      }
      var epochMatchStrings = [];
      for (var i = 0,
          ilen = epochPairs.length; i < ilen; i++) {
        var val = epochPairs[i][0];
        epochMatchStrings.push(val);
      }
      var epochMatchString = epochMatchStrings.join("|");
      var epochSplitter = new RegExp("(?:" + epochMatchString + ")(?:[0-9]+)");
      var epochMatcher = new RegExp("(?:" + epochMatchString + ")(?:[0-9]+)", "g");
      var kanjiMonthDay = /(\u6708|\u5E74)/g;
      var kanjiYear = /\u65E5/g;
      var kanjiRange = /\u301c/g;
      var yearLast = "(?:[?0-9]{1,2}%%NUMD%%){0,2}[?0-9]{4}(?![0-9])";
      var yearFirst = "[?0-9]{4}(?:%%NUMD%%[?0-9]{1,2}){0,2}(?![0-9])";
      var numberVal = "[?0-9]{1,3}";
      var rangeSeparator = "[%%DATED%%]";
      var fuzzyChar = "[?~]";
      var chars = "[^\-\/\~\?0-9]+";
      var rexString = "(" + yearFirst + "|" + yearLast + "|" + numberVal + "|" + rangeSeparator + "|" + fuzzyChar + "|" + chars + ")";
      var rexDash = new RegExp(rexString.replace(/%%NUMD%%/g, "-").replace(/%%DATED%%/g, "-"));
      var rexDashSlash = new RegExp(rexString.replace(/%%NUMD%%/g, "-").replace(/%%DATED%%/g, "\/"));
      var rexSlashDash = new RegExp(rexString.replace(/%%NUMD%%/g, "\/").replace(/%%DATED%%/g, "-"));
      var monthString = "january february march april may june july august september october november december spring summer fall winter spring summer";
      this.monthStrings = monthString.split(" ");
      this.setOrderDayMonth = function() {
        this.monthGuess = 1;
        this.dayGuess = 0;
      };
      this.setOrderMonthDay = function() {
        this.monthGuess = 0;
        this.dayGuess = 1;
      };
      this.resetDateParserMonths = function() {
        this.monthSets = [];
        for (var i = 0,
            ilen = this.monthStrings.length; i < ilen; i++) {
          this.monthSets.push([this.monthStrings[i]]);
        }
        this.monthAbbrevs = [];
        for (var i = 0,
            ilen = this.monthSets.length; i < ilen; i++) {
          this.monthAbbrevs.push([]);
          for (var j = 0,
              jlen = this.monthSets[i].length; j < jlen; j++) {
            this.monthAbbrevs[i].push(this.monthSets[i][0].slice(0, 3));
          }
        }
        this.monthRexes = [];
        for (var i = 0,
            ilen = this.monthAbbrevs.length; i < ilen; i++) {
          this.monthRexes.push(new RegExp("(?:" + this.monthAbbrevs[i].join("|") + ")"));
        }
      };
      this.addDateParserMonths = function(lst) {
        if ("string" === typeof lst) {
          lst = lst.split(/\s+/);
        }
        if (lst.length !== 12 && lst.length !== 16) {
          CSL.debug("month [+season] list of " + lst.length + ", expected 12 or 16. Ignoring.");
          return;
        }
        var otherMatch = [];
        var thisMatch = [];
        for (var i = 0,
            ilen = lst.length; i < ilen; i++) {
          var abbrevLength = null;
          var skip = false;
          var insert = 3;
          var extendedSets = {};
          for (var j = 0,
              jlen = this.monthAbbrevs.length; j < jlen; j++) {
            extendedSets[j] = {};
            if (j === i) {
              for (var k = 0,
                  klen = this.monthAbbrevs[i].length; k < klen; k++) {
                if (this.monthAbbrevs[i][k] === lst[i].slice(0, this.monthAbbrevs[i][k].length)) {
                  skip = true;
                  break;
                }
              }
            } else {
              for (var k = 0,
                  klen = this.monthAbbrevs[j].length; k < klen; k++) {
                abbrevLength = this.monthAbbrevs[j][k].length;
                if (this.monthAbbrevs[j][k] === lst[i].slice(0, abbrevLength)) {
                  while (this.monthSets[j][k].slice(0, abbrevLength) === lst[i].slice(0, abbrevLength)) {
                    if (abbrevLength > lst[i].length || abbrevLength > this.monthSets[j][k].length) {
                      CSL.debug("unable to disambiguate month string in date parser: " + lst[i]);
                      break;
                    } else {
                      abbrevLength += 1;
                    }
                  }
                  insert = abbrevLength;
                  extendedSets[j][k] = abbrevLength;
                }
              }
            }
            for (var jKey in extendedSets) {
              for (kKey in extendedSets[jKey]) {
                abbrevLength = extendedSets[jKey][kKey];
                jKey = parseInt(jKey, 10);
                kKey = parseInt(kKey, 10);
                this.monthAbbrevs[jKey][kKey] = this.monthSets[jKey][kKey].slice(0, abbrevLength);
              }
            }
          }
          if (!skip) {
            this.monthSets[i].push(lst[i]);
            this.monthAbbrevs[i].push(lst[i].slice(0, insert));
          }
        }
        this.monthRexes = [];
        this.monthRexStrs = [];
        for (var i = 0,
            ilen = this.monthAbbrevs.length; i < ilen; i++) {
          this.monthRexes.push(new RegExp("^(?:" + this.monthAbbrevs[i].join("|") + ")"));
          this.monthRexStrs.push("^(?:" + this.monthAbbrevs[i].join("|") + ")");
        }
        if (this.monthAbbrevs.length === 18) {
          for (var i = 12,
              ilen = 14; i < ilen; i++) {
            this.monthRexes[i + 4] = new RegExp("^(?:" + this.monthAbbrevs[i].join("|") + ")");
            this.monthRexStrs[i + 4] = "^(?:" + this.monthAbbrevs[i].join("|") + ")";
          }
        }
      };
      this.convertDateObjectToArray = function(thedate) {
        thedate["date-parts"] = [];
        thedate["date-parts"].push([]);
        var slicelen = 0;
        for (var i = 0,
            ilen = 3; i < ilen; i++) {
          var part = ["year", "month", "day"][i];
          if (!thedate[part]) {
            break;
          }
          slicelen += 1;
          thedate["date-parts"][0].push(thedate[part]);
          delete thedate[part];
        }
        thedate["date-parts"].push([]);
        for (var i = 0,
            ilen = slicelen; i < ilen; i++) {
          part = ["year_end", "month_end", "day_end"][i];
          if (!thedate[part]) {
            break;
          }
          thedate["date-parts"][1].push(thedate[part]);
          delete thedate[part];
        }
        if (thedate["date-parts"][0].length !== thedate["date-parts"][1].length) {
          thedate["date-parts"].pop();
        }
        return thedate;
      };
      this.convertDateObjectToString = function(thedate) {
        var ret = [];
        for (var i = 0,
            ilen = 3; i < ilen; i += 1) {
          if (thedate[DATE_PARTS_ALL[i]]) {
            ret.push(thedate[DATE_PARTS_ALL[i]]);
          } else {
            break;
          }
        }
        return ret.join("-");
      };
      this._parseNumericDate = function(ret, delim, suff, txt) {
        if (!suff)
          suff = "";
        var lst = txt.split(delim);
        for (var i = 0,
            ilen = lst.length; i < ilen; i++) {
          if (lst[i].length === 4) {
            ret[("year" + suff)] = lst[i].replace(/^0*/, "");
            if (!i) {
              lst = lst.slice(1);
            } else {
              lst = lst.slice(0, i);
            }
            break;
          }
        }
        for (var i = 0,
            ilen = lst.length; i < ilen; i++) {
          lst[i] = parseInt(lst[i], 10);
        }
        if (lst.length === 1 || (lst.length === 2 && !lst[1])) {
          ret[("month" + suff)] = "" + lst[0];
        } else if (lst.length === 2) {
          if (lst[this.monthGuess] > 12) {
            ret[("month" + suff)] = "" + lst[this.dayGuess];
            ret[("day" + suff)] = "" + lst[this.monthGuess];
          } else {
            ret[("month" + suff)] = "" + lst[this.monthGuess];
            ret[("day" + suff)] = "" + lst[this.dayGuess];
          }
        }
      };
      this.parseDateToObject = function(txt) {
        var orig = txt;
        var slashPos = -1;
        var dashPos = -1;
        var lst;
        if (txt) {
          txt = "" + txt;
          txt = txt.replace(/\s*[0-9]{2}:[0-9]{2}(?::[0-9]+)/, "");
          var m = txt.match(kanjiMonthDay);
          if (m) {
            txt = txt.replace(/\s+/g, "");
            txt = txt.replace(kanjiYear, "");
            txt = txt.replace(kanjiMonthDay, "-");
            txt = txt.replace(kanjiRange, "/");
            txt = txt.replace(/\-\//g, "/");
            txt = txt.replace(/-$/g, "");
            var slst = txt.split(epochSplitter);
            lst = [];
            var mm = txt.match(epochMatcher);
            if (mm) {
              var mmx = [];
              for (var i = 0,
                  ilen = mm.length; i < ilen; i++) {
                mmx = mmx.concat(mm[i].match(/([^0-9]+)([0-9]+)/).slice(1));
              }
              for (var i = 0,
                  ilen = slst.length; i < ilen; i++) {
                lst.push(slst[i]);
                if (i !== (len - 1)) {
                  var mmpos = (pos * 2);
                  lst.push(mmx[mmpos]);
                  lst.push(mmx[mmpos + 1]);
                }
              }
            } else {
              lst = slst;
            }
            for (var i = 1,
                ilen = lst.length; i < ilen; i += 3) {
              lst[i + 1] = jiy[lst[i]] + parseInt(lst[i + 1], 10);
              lst[i] = "";
            }
            txt = lst.join("");
            txt = txt.replace(/\s*-\s*$/, "").replace(/\s*-\s*\//, "/");
            txt = txt.replace(/\.\s*$/, "");
            txt = txt.replace(/\.(?! )/, "");
            slashPos = txt.indexOf("/");
            dashPos = txt.indexOf("-");
          }
        }
        txt = txt.replace(/([A-Za-z])\./g, "$1");
        var number = "";
        var note = "";
        var thedate = {};
        var rangeDelim;
        var dateDelim;
        if (txt.slice(0, 1) === "\"" && txt.slice(-1) === "\"") {
          thedate.literal = txt.slice(1, -1);
          return thedate;
        }
        if (slashPos > -1 && dashPos > -1) {
          var slashCount = txt.split("/");
          if (slashCount.length > 3) {
            rangeDelim = "-";
            txt = txt.replace(/\_/g, "-");
            dateDelim = "/";
            lst = txt.split(rexSlashDash);
          } else {
            rangeDelim = "/";
            txt = txt.replace(/\_/g, "/");
            dateDelim = "-";
            lst = txt.split(rexDashSlash);
          }
        } else {
          txt = txt.replace(/\//g, "-");
          txt = txt.replace(/\_/g, "-");
          rangeDelim = "-";
          dateDelim = "-";
          lst = txt.split(rexDash);
        }
        var ret = [];
        for (var i = 0,
            ilen = lst.length; i < ilen; i++) {
          var m = lst[i].match(/^\s*([\-\/]|[^\-\/\~\?0-9]+|[\-~?0-9]+)\s*$/);
          if (m) {
            ret.push(m[1]);
          }
        }
        var delimPos = ret.indexOf(rangeDelim);
        var delims = [];
        var isRange = false;
        if (delimPos > -1) {
          delims.push([0, delimPos]);
          delims.push([(delimPos + 1), ret.length]);
          isRange = true;
        } else {
          delims.push([0, ret.length]);
        }
        var suff = "";
        for (var i = 0,
            ilen = delims.length; i < ilen; i++) {
          delim = delims[i];
          date = ret.slice(delim[0], delim[1]);
          outer: for (var j = 0,
              jlen = date.length; j < jlen; j++) {
            var element = date[j];
            if (element.indexOf(dateDelim) > -1) {
              this._parseNumericDate(thedate, dateDelim, suff, element);
              continue;
            }
            if (element.match(/[0-9]{4}/)) {
              thedate[("year" + suff)] = element.replace(/^0*/, "");
              continue;
            }
            for (var k = 0,
                klen = this.monthRexes.length; k < klen; k++) {
              if (element.toLocaleLowerCase().match(this.monthRexes[k])) {
                thedate[("month" + suff)] = "" + (parseInt(k, 10) + 1);
                continue outer;
              }
            }
            if (element.match(/^[0-9]+$/)) {
              number = element;
            }
            if (element.toLocaleLowerCase().match(/^bc/) && number) {
              thedate[("year" + suff)] = "" + (number * -1);
              number = "";
              continue;
            }
            if (element.toLocaleLowerCase().match(/^ad/) && number) {
              thedate[("year" + suff)] = "" + number;
              number = "";
              continue;
            }
            if (element === "~" || element === "?" || element === "c" || element.match(/^cir/)) {
              thedate.circa = "" + 1;
              continue;
            }
            if (element.toLocaleLowerCase().match(/(?:mic|tri|hil|eas)/) && !thedate[("season" + suff)]) {
              note = element;
              continue;
            }
          }
          if (number) {
            thedate[("day" + suff)] = number;
            number = "";
          }
          if (note && !thedate[("season" + suff)]) {
            thedate[("season" + suff)] = note;
            note = "";
          }
          suff = "_end";
        }
        if (isRange) {
          for (var j = 0,
              jlen = CSL.DATE_PARTS_ALL.length; j < jlen; j++) {
            var item = CSL.DATE_PARTS_ALL[j];
            if (thedate[item] && !thedate[(item + "_end")]) {
              thedate[(item + "_end")] = thedate[item];
            } else if (!thedate[item] && thedate[(item + "_end")]) {
              thedate[item] = thedate[(item + "_end")];
            }
          }
        }
        if (!thedate.year || (thedate.year && thedate.day && !thedate.month)) {
          thedate = {"literal": orig};
        }
        var parts = ["year", "month", "day", "year_end", "month_end", "day_end"];
        for (var i = 0,
            ilen = parts.length; i < ilen; i++) {
          var part = parts[i];
          if ("string" === typeof thedate[part] && thedate[part].match(/^[0-9]+$/)) {
            thedate[part] = parseInt(thedate[part], 10);
          }
        }
        return thedate;
      };
      this.parseDateToArray = function(txt) {
        return this.convertDateObjectToArray(this.parseDateToObject(txt));
      };
      this.parseDateToString = function(txt) {
        return this.convertDateObjectToString(this.parseDateToObject(txt));
      };
      this.parse = function(txt) {
        return this.parseDateToObject(txt);
      };
      this.setOrderMonthDay();
      this.resetDateParserMonths();
    };
    CSL.Engine = function(sys, style, lang, forceLang) {
      var attrs,
          langspec,
          localexml,
          locale;
      this.processor_version = CSL.PROCESSOR_VERSION;
      this.csl_version = "1.0";
      this.sys = sys;
      if (sys.variableWrapper) {
        CSL.VARIABLE_WRAPPER_PREPUNCT_REX = new RegExp('^([' + [" "].concat(CSL.SWAPPING_PUNCTUATION).join("") + ']*)(.*)');
      }
      if (CSL.retrieveStyleModule) {
        this.sys.retrieveStyleModule = CSL.retrieveStyleModule;
      }
      if (CSL.getAbbreviation) {
        this.sys.getAbbreviation = CSL.getAbbreviation;
      }
      if (this.sys.stringCompare) {
        CSL.stringCompare = this.sys.stringCompare;
      }
      this.sys.AbbreviationSegments = CSL.AbbreviationSegments;
      this.parallel = new CSL.Parallel(this);
      this.transform = new CSL.Transform(this);
      this.setParseNames = function(val) {
        this.opt['parse-names'] = val;
      };
      this.opt = new CSL.Engine.Opt();
      this.tmp = new CSL.Engine.Tmp();
      this.build = new CSL.Engine.Build();
      this.fun = new CSL.Engine.Fun(this);
      this.configure = new CSL.Engine.Configure();
      this.citation_sort = new CSL.Engine.CitationSort();
      this.bibliography_sort = new CSL.Engine.BibliographySort();
      this.citation = new CSL.Engine.Citation(this);
      this.bibliography = new CSL.Engine.Bibliography();
      this.output = new CSL.Output.Queue(this);
      this.dateput = new CSL.Output.Queue(this);
      this.cslXml = CSL.setupXml(style);
      if (this.opt.development_extensions.csl_reverse_lookup_support || this.sys.csl_reverse_lookup_support) {
        this.build.cslNodeId = 0;
        this.setCslNodeIds = function(myxml, nodename) {
          var children = this.cslXml.children(myxml);
          this.cslXml.setAttribute(myxml, 'cslid', this.build.cslNodeId);
          this.opt.nodenames.push(nodename);
          this.build.cslNodeId += 1;
          for (var i = 0,
              ilen = this.cslXml.numberofnodes(children); i < ilen; i += 1) {
            nodename = this.cslXml.nodename(children[i]);
            if (nodename) {
              this.setCslNodeIds(children[i], nodename);
            }
          }
        };
        this.setCslNodeIds(this.cslXml.dataObj, "style");
      }
      this.cslXml.addMissingNameNodes(this.cslXml.dataObj);
      this.cslXml.addInstitutionNodes(this.cslXml.dataObj);
      this.cslXml.insertPublisherAndPlace(this.cslXml.dataObj);
      this.cslXml.flagDateMacros(this.cslXml.dataObj);
      attrs = this.cslXml.attributes(this.cslXml.dataObj);
      if ("undefined" === typeof attrs["@sort-separator"]) {
        this.cslXml.setAttribute(this.cslXml.dataObj, "sort-separator", ", ");
      }
      this.opt["initialize-with-hyphen"] = true;
      this.setStyleAttributes();
      this.opt.xclass = this.cslXml.getAttributeValue(this.cslXml.dataObj, "class");
      this.opt.class = this.opt.xclass;
      this.opt.styleID = this.cslXml.getStyleId(this.cslXml.dataObj);
      if (CSL.setSuppressedJurisdictions) {
        CSL.setSuppressedJurisdictions(this.opt.styleID, this.opt.suppressedJurisdictions);
      }
      this.opt.styleName = this.cslXml.getStyleId(this.cslXml.dataObj, true);
      if (this.opt.version.slice(0, 4) === "1.1m") {
        this.opt.development_extensions.static_statute_locator = true;
        this.opt.development_extensions.handle_parallel_articles = true;
        this.opt.development_extensions.main_title_from_short_title = true;
        this.opt.development_extensions.rtl_support = true;
        this.opt.development_extensions.expect_and_symbol_form = true;
        this.opt.development_extensions.require_explicit_legal_case_title_short = true;
        this.opt.development_extensions.force_jurisdiction = true;
      }
      if (lang) {
        lang = lang.replace("_", "-");
      }
      if (this.opt["default-locale"][0]) {
        this.opt["default-locale"][0] = this.opt["default-locale"][0].replace("_", "-");
      }
      if (lang && forceLang) {
        this.opt["default-locale"] = [lang];
      }
      if (lang && !forceLang && this.opt["default-locale"][0]) {
        lang = this.opt["default-locale"][0];
      }
      if (this.opt["default-locale"].length === 0) {
        if (!lang) {
          lang = "en-US";
        }
        this.opt["default-locale"].push("en-US");
      }
      if (!lang) {
        lang = this.opt["default-locale"][0];
      }
      langspec = CSL.localeResolve(lang);
      this.opt.lang = langspec.best;
      this.opt["default-locale"][0] = langspec.best;
      this.locale = {};
      if (!this.opt["default-locale-sort"]) {
        this.opt["default-locale-sort"] = this.opt["default-locale"][0];
      }
      this.localeConfigure(langspec);
      function makeRegExp(lst) {
        var lst = lst.slice();
        var ret = new RegExp("(?:(?:[?!:]*\\s+|-|^)(?:" + lst.join("|") + ")(?=[!?:]*\\s+|-|$))", "g");
        return ret;
      }
      this.locale[this.opt.lang].opts["skip-words-regexp"] = makeRegExp(this.locale[this.opt.lang].opts["skip-words"]);
      this.output.adjust = new CSL.Output.Queue.adjust(this.getOpt('punctuation-in-quote'));
      this.registry = new CSL.Registry(this);
      this.macros = {};
      this.build.area = "citation";
      var area_nodes = this.cslXml.getNodesByName(this.cslXml.dataObj, this.build.area);
      this.buildTokenLists(area_nodes, this[this.build.area].tokens);
      this.build.area = "bibliography";
      var area_nodes = this.cslXml.getNodesByName(this.cslXml.dataObj, this.build.area);
      this.buildTokenLists(area_nodes, this[this.build.area].tokens);
      this.juris = {};
      this.configureTokenLists();
      this.disambiguate = new CSL.Disambiguation(this);
      this.splice_delimiter = false;
      this.fun.dateparser = CSL.DateParser;
      this.fun.flipflopper = new CSL.Util.FlipFlopper(this);
      this.setCloseQuotesArray();
      this.fun.ordinalizer.init(this);
      this.fun.long_ordinalizer.init(this);
      this.fun.page_mangler = CSL.Util.PageRangeMangler.getFunction(this, "page");
      this.fun.year_mangler = CSL.Util.PageRangeMangler.getFunction(this, "year");
      this.setOutputFormat("html");
    };
    CSL.Engine.prototype.setCloseQuotesArray = function() {
      var ret;
      ret = [];
      ret.push(this.getTerm("close-quote"));
      ret.push(this.getTerm("close-inner-quote"));
      ret.push('"');
      ret.push("'");
      this.opt.close_quotes_array = ret;
    };
    CSL.makeBuilder = function(me, target) {
      function enterFunc(node) {
        CSL.XmlToToken.call(node, me, CSL.START, target);
      }
      ;
      function leaveFunc(node) {
        CSL.XmlToToken.call(node, me, CSL.END, target);
      }
      ;
      function singletonFunc(node) {
        CSL.XmlToToken.call(node, me, CSL.SINGLETON, target);
      }
      ;
      function buildStyle(node) {
        var starttag,
            origparent;
        if (me.cslXml.numberofnodes(me.cslXml.children(node))) {
          origparent = node;
          enterFunc(origparent);
          for (var i = 0; i < me.cslXml.numberofnodes(me.cslXml.children(origparent)); i += 1) {
            node = me.cslXml.children(origparent)[i];
            if (me.cslXml.nodename(node) === null) {
              continue;
            }
            if (me.cslXml.nodename(node) === "date") {
              CSL.Util.fixDateNode.call(me, origparent, i, node);
              node = me.cslXml.children(origparent)[i];
            }
            buildStyle(node, enterFunc, leaveFunc, singletonFunc);
          }
          leaveFunc(origparent);
        } else {
          singletonFunc(node);
        }
      }
      return buildStyle;
    };
    CSL.Engine.prototype.buildTokenLists = function(area_nodes, target) {
      if (!this.cslXml.getNodeValue(area_nodes))
        return;
      var builder = CSL.makeBuilder(this, target);
      var mynode;
      if ("undefined" === typeof area_nodes.length) {
        mynode = area_nodes;
      } else {
        mynode = area_nodes[0];
      }
      builder(mynode);
    };
    CSL.Engine.prototype.setStyleAttributes = function() {
      var dummy,
          attr,
          key,
          attributes,
          attrname;
      var dummy = {};
      dummy.name = this.cslXml.nodename(this.cslXml.dataObj);
      attributes = this.cslXml.attributes(this.cslXml.dataObj);
      for (attrname in attributes) {
        if (attributes.hasOwnProperty(attrname)) {
          CSL.Attributes[attrname].call(dummy, this, attributes[attrname]);
        }
      }
    };
    CSL.Engine.prototype.getTerm = function(term, form, plural, gender, mode, forceDefaultLocale) {
      if (term && term.match(/[A-Z]/) && term === term.toUpperCase()) {
        CSL.debug("Warning: term key is in uppercase form: " + term);
        term = term.toLowerCase();
      }
      var lang;
      if (forceDefaultLocale) {
        lang = this.opt["default-locale"][0];
      } else {
        lang = this.opt.lang;
      }
      var ret = CSL.Engine.getField(CSL.LOOSE, this.locale[lang].terms, term, form, plural, gender);
      if (!ret && term === "range-delimiter") {
        ret = "\u2013";
      }
      if (typeof ret === "undefined") {
        if (mode === CSL.STRICT) {
          throw "Error in getTerm: term \"" + term + "\" does not exist.";
        } else if (mode === CSL.TOLERANT) {
          ret = "";
        }
      }
      if (ret) {
        this.tmp.cite_renders_content = true;
      }
      return ret;
    };
    CSL.Engine.prototype.getDate = function(form, forceDefaultLocale) {
      var lang;
      if (forceDefaultLocale) {
        lang = this.opt["default-locale"];
      } else {
        lang = this.opt.lang;
      }
      if (this.locale[lang].dates[form]) {
        return this.locale[lang].dates[form];
      } else {
        return false;
      }
    };
    CSL.Engine.prototype.getOpt = function(arg) {
      if ("undefined" !== typeof this.locale[this.opt.lang].opts[arg]) {
        return this.locale[this.opt.lang].opts[arg];
      } else {
        return false;
      }
    };
    CSL.Engine.prototype.getVariable = function(Item, varname, form, plural) {
      return CSL.Engine.getField(CSL.LOOSE, Item, varname, form, plural);
    };
    CSL.Engine.prototype.getDateNum = function(ItemField, partname) {
      if ("undefined" === typeof ItemField) {
        return 0;
      } else {
        return ItemField[partname];
      }
    };
    CSL.Engine.getField = function(mode, hash, term, form, plural, gender) {
      var ret,
          forms,
          f,
          pos,
          len,
          hashterm;
      ret = "";
      if ("undefined" === typeof hash[term]) {
        if (mode === CSL.STRICT) {
          throw "Error in getField: term \"" + term + "\" does not exist.";
        } else {
          return undefined;
        }
      }
      if (gender && hash[term][gender]) {
        hashterm = hash[term][gender];
      } else {
        hashterm = hash[term];
      }
      forms = [];
      if (form === "symbol") {
        forms = ["symbol", "short"];
      } else if (form === "verb-short") {
        forms = ["verb-short", "verb"];
      } else if (form !== "long") {
        forms = [form];
      }
      forms = forms.concat(["long"]);
      len = forms.length;
      for (pos = 0; pos < len; pos += 1) {
        f = forms[pos];
        if ("string" === typeof hashterm || "number" === typeof hashterm) {
          ret = hashterm;
        } else if ("undefined" !== typeof hashterm[f]) {
          if ("string" === typeof hashterm[f] || "number" === typeof hashterm[f]) {
            ret = hashterm[f];
          } else {
            if ("number" === typeof plural) {
              ret = hashterm[f][plural];
            } else {
              ret = hashterm[f][0];
            }
          }
          break;
        }
      }
      return ret;
    };
    CSL.Engine.prototype.configureTokenLists = function() {
      var dateparts_master,
          area,
          pos,
          token,
          dateparts,
          part,
          ppos,
          pppos,
          len,
          llen,
          lllen;
      len = CSL.AREAS.length;
      for (pos = 0; pos < len; pos += 1) {
        area = CSL.AREAS[pos];
        var tokens = this[area].tokens;
        this.configureTokenList(tokens);
      }
      this.version = CSL.version;
      return this.state;
    };
    CSL.Engine.prototype.configureTokenList = function(tokens) {
      var dateparts_master,
          area,
          pos,
          token,
          dateparts,
          part,
          ppos,
          pppos,
          len,
          llen,
          lllen;
      dateparts_master = ["year", "month", "day"];
      llen = tokens.length - 1;
      for (ppos = llen; ppos > -1; ppos += -1) {
        token = tokens[ppos];
        if ("date" === token.name && CSL.END === token.tokentype) {
          dateparts = [];
        }
        if ("date-part" === token.name && token.strings.name) {
          lllen = dateparts_master.length;
          for (pppos = 0; pppos < lllen; pppos += 1) {
            part = dateparts_master[pppos];
            if (part === token.strings.name) {
              dateparts.push(token.strings.name);
            }
          }
        }
        if ("date" === token.name && CSL.START === token.tokentype) {
          dateparts.reverse();
          token.dateparts = dateparts;
        }
        token.next = (ppos + 1);
        if (token.name && CSL.Node[token.name].configure) {
          CSL.Node[token.name].configure.call(token, this, ppos);
        }
      }
    };
    CSL.Engine.prototype.retrieveItems = function(ids) {
      var ret,
          pos,
          len;
      ret = [];
      for (var i = 0,
          ilen = ids.length; i < ilen; i += 1) {
        ret.push(this.retrieveItem("" + ids[i]));
      }
      return ret;
    };
    CSL.ITERATION = 0;
    CSL.Engine.prototype.retrieveItem = function(id) {
      var Item,
          m,
          pos,
          len,
          mm;
      if (this.opt.development_extensions.normalize_lang_keys_to_lowercase && "boolean" === typeof this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
        for (var i = 0,
            ilen = this.opt["default-locale"].length; i < ilen; i += 1) {
          this.opt["default-locale"][i] = this.opt["default-locale"][i].toLowerCase();
        }
        for (var i = 0,
            ilen = this.opt["locale-translit"].length; i < ilen; i += 1) {
          this.opt["locale-translit"][i] = this.opt["locale-translit"][i].toLowerCase();
        }
        for (var i = 0,
            ilen = this.opt["locale-translat"].length; i < ilen; i += 1) {
          this.opt["locale-translat"][i] = this.opt["locale-translat"][i].toLowerCase();
        }
        this.opt.development_extensions.normalize_lang_keys_to_lowercase = 100;
      }
      CSL.ITERATION += 1;
      Item = this.sys.retrieveItem("" + id);
      if (this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
        if (Item.multi) {
          if (Item.multi._keys) {
            for (var field in Item.multi._keys) {
              for (var key in Item.multi._keys[field]) {
                if (key !== key.toLowerCase()) {
                  Item.multi._keys[field][key.toLowerCase()] = Item.multi._keys[field][key];
                  delete Item.multi._keys[field][key];
                }
              }
            }
          }
          if (Item.multi.main) {
            for (var field in Item.multi.main) {
              Item.multi.main[field] = Item.multi.main[field].toLowerCase();
            }
          }
        }
        for (var i = 0,
            ilen = CSL.CREATORS.length; i > ilen; i += 1) {
          var ctype = CSL.CREATORS[i];
          if (Item[ctype] && Item[ctype].multi) {
            for (var j = 0,
                jlen = Item[ctype].length; j < jlen; j += 1) {
              var creator = Item[ctype][j];
              if (creator.multi) {
                if (creator.multi._key) {
                  for (var key in creator.multi._key) {
                    if (key !== key.toLowerCase()) {
                      creator.multi._key[key.toLowerCase()] = creator.multi._key[key];
                      delete creator.multi._key[key];
                    }
                  }
                }
                if (creator.multi.main) {
                  creator.multi.main = creator.multi.main.toLowerCase();
                }
              }
            }
          }
        }
      }
      if (this.sys.getLanguageName && Item.language) {
        if (Item.language) {
          Item.language = Item.language.toLowerCase();
          var lst = Item.language.split("<");
          if (lst.length > 0) {
            var languageName = this.sys.getLanguageName(lst[0]);
            if (languageName) {
              Item["language-name"] = languageName;
            }
          }
          if (lst.length === 2) {
            var originalLanguage = this.sys.getLanguageName(lst[1]);
            if (originalLanguage) {
              Item["language-name-original"] = originalLanguage;
            }
          }
        }
      }
      if (Item.page) {
        Item["page-first"] = Item.page;
        var num = "" + Item.page;
        m = num.split(/\s*(?:&|, |-|\u2013)\s*/);
        if (m[0].slice(-1) !== "\\") {
          Item["page-first"] = m[0];
        }
      }
      if (this.opt.development_extensions.field_hack && Item.note) {
        CSL.parseNoteFieldHacks(Item);
      }
      for (var i = 1,
          ilen = CSL.DATE_VARIABLES.length; i < ilen; i += 1) {
        var dateobj = Item[CSL.DATE_VARIABLES[i]];
        if (dateobj) {
          if (this.opt.development_extensions.raw_date_parsing) {
            if (dateobj.raw) {
              dateobj = this.fun.dateparser.parseDateToObject(dateobj.raw);
            }
          }
          Item[CSL.DATE_VARIABLES[i]] = this.dateParseArray(dateobj);
        }
      }
      if (this.opt.development_extensions.static_statute_locator) {
        if (Item.type && ["bill", "gazette", "legislation", "regulation", "treaty"].indexOf(Item.type) > -1) {
          var varname;
          var elements = ["type", "title", "jurisdiction", "genre", "volume", "container-title"];
          var legislation_id = [];
          for (i = 0, ilen = elements.length; i < ilen; i += 1) {
            varname = elements[i];
            if (Item[varname]) {
              legislation_id.push(Item[varname]);
            }
          }
          elements = ["original-date", "issued"];
          for (i = 0, elements.length; i < ilen; i += 1) {
            varname = elements[i];
            if (Item[varname] && Item[varname].year) {
              var value = Item[varname].year;
              legislation_id.push(value);
              break;
            }
          }
          Item.legislation_id = legislation_id.join("::");
        }
      }
      if (!Item["title-short"]) {
        Item["title-short"] = Item.shortTitle;
      }
      if (this.opt.development_extensions.main_title_from_short_title) {
        var segments = ["", "container-"];
        for (var i = 0,
            ilen = segments.length; i < ilen; i++) {
          var seg = segments[i];
          Item[seg + "title-main"] = Item[seg + "title"];
          Item[seg + "title-sub"] = false;
          if (Item[seg + "title"] && Item[seg + "title-short"]) {
            var shortTitle = Item[seg + "title-short"];
            offset = shortTitle.length;
            if (Item[seg + "title"].slice(0, offset) === shortTitle && Item[seg + "title"].slice(offset).match(/^\s*:/)) {
              Item[seg + "title-main"] = Item[seg + "title"].slice(0, offset).replace(/\s+$/, "");
              Item[seg + "title-sub"] = Item[seg + "title"].slice(offset).replace(/^\s*:\s*/, "");
              if (this.opt.development_extensions.uppercase_subtitles && Item[seg + "title-sub"]) {
                var subtitle = Item[seg + "title-sub"];
                for (var j = 0,
                    jlen = subtitle.length; j < jlen; j++) {
                  if (subtitle.charAt(j).toLowerCase() !== subtitle.charAt(j).toUpperCase()) {
                    Item[seg + "title-sub"] = subtitle.slice(0, j) + subtitle.charAt(j).toUpperCase() + subtitle.slice(j + 1);
                    break;
                  }
                }
              }
              var mainPlusJoinOffset = offset + Item[seg + "title"].length - Item[seg + "title-main"].length - Item[seg + "title-sub"].length;
              Item[seg + "title"] = Item[seg + "title"].slice(0, mainPlusJoinOffset) + Item[seg + "title-sub"];
            }
          }
        }
      }
      var isLegalType = ["bill", "legal_case", "legislation", "gazette", "regulation"].indexOf(Item.type) > -1;
      if (this.opt.development_extensions.force_jurisdiction && isLegalType) {
        if (!Item.jurisdiction) {
          Item.jurisdiction = "us";
        }
      }
      if (!isLegalType && Item.title && this.sys.getAbbreviation) {
        var noHints = false;
        if (!Item.jurisdiction) {
          noHints = true;
        }
        var jurisdiction = this.transform.loadAbbreviation(Item.jurisdiction, "title", Item.title, Item.type, true);
        if (this.transform.abbrevs[jurisdiction].title) {
          if (this.transform.abbrevs[jurisdiction].title[Item.title]) {
            Item["title-short"] = this.transform.abbrevs[jurisdiction].title[Item.title];
          }
        }
      }
      if (!Item["container-title-short"]) {
        Item["container-title-short"] = Item.journalAbbreviation;
      }
      if (Item["container-title"] && this.sys.getAbbreviation) {
        var jurisdiction = this.transform.loadAbbreviation(Item.jurisdiction, "container-title", Item["container-title"]);
        if (this.transform.abbrevs[jurisdiction]["container-title"]) {
          if (this.transform.abbrevs[jurisdiction]["container-title"][Item["container-title"]]) {
            Item["container-title-short"] = this.transform.abbrevs[jurisdiction]["container-title"][Item["container-title"]];
          }
        }
      }
      return Item;
    };
    CSL.Engine.prototype.setOpt = function(token, name, value) {
      if (token.name === "style" || token.name === "cslstyle") {
        this.opt[name] = value;
      } else if (["citation", "bibliography"].indexOf(token.name) > -1) {
        this[token.name].opt[name] = value;
      } else if (["name-form", "name-delimiter", "names-delimiter"].indexOf(name) === -1) {
        token.strings[name] = value;
      }
    };
    CSL.Engine.prototype.fixOpt = function(token, name, localname) {
      if (["citation", "bibliography"].indexOf(token.name) > -1) {
        if (!this[token.name].opt[name] && "undefined" !== typeof this.opt[name]) {
          this[token.name].opt[name] = this.opt[name];
        }
      }
      if ("name" === token.name || "names" === token.name) {
        if ("undefined" === typeof token.strings[localname] && "undefined" !== typeof this[this.build.root].opt[name]) {
          token.strings[localname] = this[this.build.root].opt[name];
        }
      }
    };
    CSL.Engine.prototype.remapSectionVariable = function(inputList) {
      for (var i = 0,
          ilen = inputList.length; i < ilen; i += 1) {
        var Item = inputList[i][0];
        var item = inputList[i][1];
        if (["bill", "gazette", "legislation", "regulation", "treaty"].indexOf(Item.type) > -1) {
          if (item.locator) {
            item.locator = item.locator.trim();
            var m = item.locator.match(CSL.STATUTE_SUBDIV_PLAIN_REGEX);
            if (!m) {
              if (item.label) {
                item.locator = CSL.STATUTE_SUBDIV_STRINGS_REVERSE[item.label] + " " + item.locator;
              } else {
                item.locator = "p. " + item.locator;
              }
            }
          }
          var sectionMasterLabel = null;
          if (Item.section) {
            Item.section = Item.section.trim();
            var m = Item.section.match(CSL.STATUTE_SUBDIV_PLAIN_REGEX);
            if (!m) {
              Item.section = "sec. " + Item.section;
              sectionMasterLabel = "sec.";
            } else {
              sectionMasterLabel = m[0].trim();
            }
          }
          if (Item.section) {
            if (!item.locator) {
              item.locator = Item.section;
            } else {
              var m = item.locator.match(/^([^ ]*)\s*(.*)/);
              var space = " ";
              if (m) {
                if (m[1] === "p." && sectionMasterLabel !== "p.") {
                  item.locator = m[2];
                }
                if (["[", "(", ".", ",", ";", ":", "?"].indexOf(item.locator.slice(0, 1)) > -1) {
                  space = "";
                }
              } else {
                space = "";
              }
              item.locator = Item.section + space + item.locator;
            }
          }
          item.label = "";
        }
      }
    };
    CSL.Engine.prototype.setNumberLabels = function(Item) {
      if (Item.number && ["bill", "gazette", "legislation", "regulation", "treaty"].indexOf(Item.type) > -1 && this.opt.development_extensions.static_statute_locator && !this.tmp.shadow_numbers["number"]) {
        this.tmp.shadow_numbers["number"] = {};
        this.tmp.shadow_numbers["number"].values = [];
        this.tmp.shadow_numbers["number"].plural = 0;
        this.tmp.shadow_numbers["number"].numeric = false;
        this.tmp.shadow_numbers["number"].label = false;
        var value = "" + Item.number;
        value = value.split("\\").join("");
        var firstword = value.split(/\s+/)[0];
        var firstlabel = CSL.STATUTE_SUBDIV_STRINGS[firstword];
        if (firstlabel) {
          var m = value.match(CSL.STATUTE_SUBDIV_GROUPED_REGEX);
          var splt = value.split(CSL.STATUTE_SUBDIV_PLAIN_REGEX);
          if (splt.length > 1) {
            var lst = [];
            for (var j = 1,
                jlen = splt.length; j < jlen; j += 1) {
              var subdiv = m[j - 1].replace(/^\s*/, "");
              lst.push(splt[j].replace(/\s*$/, "").replace(/^\s*/, ""));
            }
            value = lst.join(" ");
          } else {
            value = splt[0];
          }
          this.tmp.shadow_numbers["number"].label = firstlabel;
          this.tmp.shadow_numbers["number"].values.push(["Blob", value, false]);
          this.tmp.shadow_numbers["number"].numeric = false;
        } else {
          this.tmp.shadow_numbers["number"].values.push(["Blob", value, false]);
          this.tmp.shadow_numbers["number"].numeric = true;
        }
      }
    };
    CSL.substituteOne = function(template) {
      return function(state, list) {
        if (!list) {
          return "";
        } else {
          return template.replace("%%STRING%%", list);
        }
      };
    };
    CSL.substituteTwo = function(template) {
      return function(param) {
        var template2 = template.replace("%%PARAM%%", param);
        return function(state, list) {
          if (!list) {
            return "";
          } else {
            return template2.replace("%%STRING%%", list);
          }
        };
      };
    };
    CSL.Mode = function(mode) {
      var decorations,
          params,
          param,
          func,
          val,
          args;
      decorations = {};
      params = CSL.Output.Formats[mode];
      for (param in params) {
        if (true) {
          if ("@" !== param.slice(0, 1)) {
            decorations[param] = params[param];
            continue;
          }
          func = false;
          val = params[param];
          args = param.split('/');
          if (typeof val === "string" && val.indexOf("%%STRING%%") > -1) {
            if (val.indexOf("%%PARAM%%") > -1) {
              func = CSL.substituteTwo(val);
            } else {
              func = CSL.substituteOne(val);
            }
          } else if (typeof val === "boolean" && !val) {
            func = CSL.Output.Formatters.passthrough;
          } else if (typeof val === "function") {
            func = val;
          } else {
            throw "CSL.Compiler: Bad " + mode + " config entry for " + param + ": " + val;
          }
          if (args.length === 1) {
            decorations[args[0]] = func;
          } else if (args.length === 2) {
            if (!decorations[args[0]]) {
              decorations[args[0]] = {};
            }
            decorations[args[0]][args[1]] = func;
          }
        }
      }
      return decorations;
    };
    CSL.setDecorations = function(state, attributes) {
      var ret,
          key,
          pos;
      ret = [];
      for (pos in CSL.FORMAT_KEY_SEQUENCE) {
        if (true) {
          key = CSL.FORMAT_KEY_SEQUENCE[pos];
          if (attributes[key]) {
            ret.push([key, attributes[key]]);
            delete attributes[key];
          }
        }
      }
      return ret;
    };
    CSL.Engine.prototype.normalDecorIsOrphan = function(blob, params) {
      if (params[1] === "normal") {
        var use_param = false;
        var all_the_decor;
        if (this.tmp.area === "citation") {
          all_the_decor = [this.citation.opt.layout_decorations].concat(blob.alldecor);
        } else {
          all_the_decor = blob.alldecor;
        }
        for (var k = all_the_decor.length - 1; k > -1; k += -1) {
          for (var n = all_the_decor[k].length - 1; n > -1; n += -1) {
            if (all_the_decor[k][n][0] === params[0]) {
              if (all_the_decor[k][n][1] !== "normal") {
                use_param = true;
              }
            }
          }
        }
        if (!use_param) {
          return true;
        }
      }
      return false;
    };
    CSL.Engine.prototype.getCitationLabel = function(Item) {
      var label = "";
      var params = this.getTrigraphParams();
      var config = params[0];
      var myname = this.getTerm("reference", "short", 0);
      if ("undefined" === typeof myname) {
        myname = "reference";
      }
      myname = myname.replace(".", "");
      myname = myname.slice(0, 1).toUpperCase() + myname.slice(1);
      for (var i = 0,
          ilen = CSL.CREATORS.length; i < ilen; i += 1) {
        var n = CSL.CREATORS[i];
        if (Item[n]) {
          var names = Item[n];
          if (names.length > params.length) {
            config = params[params.length - 1];
          } else {
            config = params[names.length - 1];
          }
          for (var j = 0,
              jlen = names.length; j < jlen; j += 1) {
            if (j === config.authors.length) {
              break;
            }
            var res = this.nameOutput.getName(names[j], "locale-translit", true);
            var name = res.name;
            if (name && name.family) {
              myname = name.family;
              myname = myname.replace(/^([ \'\u2019a-z]+\s+)/, "");
            } else if (name && name.literal) {
              myname = name.literal;
            }
            var m = myname.toLowerCase().match(/^(a\s+|the\s+|an\s+)/);
            if (m) {
              myname = myname.slice(m[1].length);
            }
            myname = myname.replace(CSL.ROMANESQUE_NOT_REGEXP, "");
            if (!myname) {
              break;
            }
            myname = myname.slice(0, config.authors[j]);
            if (myname.length > 1) {
              myname = myname.slice(0, 1).toUpperCase() + myname.slice(1).toLowerCase();
            } else if (myname.length === 1) {
              myname = myname.toUpperCase();
            }
            label += myname;
          }
          break;
        }
      }
      var year = "0000";
      if (Item.issued) {
        if (Item.issued.year) {
          year = "" + Item.issued.year;
        }
      }
      year = year.slice((config.year * -1));
      label = label + year;
      return label;
    };
    CSL.Engine.prototype.getTrigraphParams = function() {
      var params = [];
      var ilst = this.opt.trigraph.split(":");
      if (!this.opt.trigraph || this.opt.trigraph.slice(0, 1) !== "A") {
        throw "Bad trigraph definition: " + this.opt.trigraph;
      }
      for (var i = 0,
          ilen = ilst.length; i < ilen; i += 1) {
        var str = ilst[i];
        var config = {
          authors: [],
          year: 0
        };
        for (var j = 0,
            jlen = str.length; j < jlen; j += 1) {
          switch (str.slice(j, j + 1)) {
            case "A":
              config.authors.push(1);
              break;
            case "a":
              config.authors[config.authors.length - 1] += 1;
              break;
            case "0":
              config.year += 1;
              break;
            default:
              throw "Invalid character in trigraph definition: " + this.opt.trigraph;
          }
        }
        params.push(config);
      }
      return params;
    };
    CSL.Engine.prototype.setOutputFormat = function(mode) {
      this.opt.mode = mode;
      this.fun.decorate = CSL.Mode(mode);
      if (!this.output[mode]) {
        this.output[mode] = {};
        this.output[mode].tmp = {};
      }
    };
    CSL.Engine.prototype.getSortFunc = function() {
      return function(a, b) {
        a = a.split("-");
        b = b.split("-");
        if (a.length < b.length) {
          return 1;
        } else if (a.length > b.length) {
          return -1;
        } else {
          a = a.slice(-1)[0];
          b = b.slice(-1)[0];
          if (a.length < b.length) {
            return 1;
          } else if (a.length > b.length) {
            return -1;
          } else {
            return 0;
          }
        }
      };
    };
    CSL.Engine.prototype.setLangTagsForCslSort = function(tags) {
      var i,
          ilen;
      if (tags) {
        this.opt['locale-sort'] = [];
        for (i = 0, ilen = tags.length; i < ilen; i += 1) {
          this.opt['locale-sort'].push(tags[i]);
        }
      }
      this.opt['locale-sort'].sort(this.getSortFunc());
    };
    CSL.Engine.prototype.setLangTagsForCslTransliteration = function(tags) {
      var i,
          ilen;
      this.opt['locale-translit'] = [];
      if (tags) {
        for (i = 0, ilen = tags.length; i < ilen; i += 1) {
          this.opt['locale-translit'].push(tags[i]);
        }
      }
      this.opt['locale-translit'].sort(this.getSortFunc());
    };
    CSL.Engine.prototype.setLangTagsForCslTranslation = function(tags) {
      var i,
          ilen;
      this.opt['locale-translat'] = [];
      if (tags) {
        for (i = 0, ilen = tags.length; i < ilen; i += 1) {
          this.opt['locale-translat'].push(tags[i]);
        }
      }
      this.opt['locale-translat'].sort(this.getSortFunc());
    };
    CSL.Engine.prototype.setLangPrefsForCites = function(obj, conv) {
      var opt = this.opt['cite-lang-prefs'];
      if (!conv) {
        conv = function(key) {
          return key.toLowerCase();
        };
      }
      var segments = ['Persons', 'Institutions', 'Titles', 'Journals', 'Publishers', 'Places'];
      for (var i = 0,
          ilen = segments.length; i < ilen; i += 1) {
        var clientSegment = conv(segments[i]);
        var citeprocSegment = segments[i].toLowerCase();
        if (!obj[clientSegment]) {
          continue;
        }
        var supplements = [];
        while (obj[clientSegment].length > 1) {
          supplements.push(obj[clientSegment].pop());
        }
        var sortval = {
          orig: 1,
          translit: 2,
          translat: 3
        };
        if (supplements.length === 2 && sortval[supplements[0]] < sortval[supplements[1]]) {
          supplements.reverse();
        }
        while (supplements.length) {
          obj[clientSegment].push(supplements.pop());
        }
        var lst = opt[citeprocSegment];
        while (lst.length) {
          lst.pop();
        }
        for (var j = 0,
            jlen = obj[clientSegment].length; j < jlen; j += 1) {
          lst.push(obj[clientSegment][j]);
        }
      }
    };
    CSL.Engine.prototype.setLangPrefsForCiteAffixes = function(affixList) {
      if (affixList && affixList.length === 48) {
        var affixes = this.opt.citeAffixes;
        var count = 0;
        var settings = ["persons", "institutions", "titles", "journals", "publishers", "places"];
        var forms = ["translit", "orig", "translit", "translat"];
        var value;
        for (var i = 0,
            ilen = settings.length; i < ilen; i += 1) {
          for (var j = 0,
              jlen = forms.length; j < jlen; j += 1) {
            value = "";
            if ((count % 8) === 4) {
              if (!affixes[settings[i]]["locale-" + forms[j]].prefix && !affixes[settings[i]]["locale-" + forms[j]].suffix) {
                value = affixList[count] ? affixList[count] : "";
                affixes[settings[i]]["locale-" + forms[j]].prefix = value;
                value = affixList[count] ? affixList[count + 1] : "";
                affixes[settings[i]]["locale-" + forms[j]].suffix = value;
              }
            } else {
              value = affixList[count] ? affixList[count] : "";
              affixes[settings[i]]["locale-" + forms[j]].prefix = value;
              value = affixList[count] ? affixList[count + 1] : "";
              affixes[settings[i]]["locale-" + forms[j]].suffix = value;
            }
            count += 2;
          }
        }
        this.opt.citeAffixes = affixes;
      }
    };
    CSL.Engine.prototype.setAutoVietnameseNamesOption = function(arg) {
      if (arg) {
        this.opt["auto-vietnamese-names"] = true;
      } else {
        this.opt["auto-vietnamese-names"] = false;
      }
    };
    CSL.Engine.prototype.setAbbreviations = function(arg) {
      if (this.sys.setAbbreviations) {
        this.sys.setAbbreviations(arg);
      }
    };
    CSL.Engine.prototype.setSuppressTrailingPunctuation = function(arg) {
      this.citation.opt.suppressTrailingPunctuation = !!arg;
    };
    CSL.Output = {};
    CSL.Output.Queue = function(state) {
      this.levelname = ["top"];
      this.state = state;
      this.queue = [];
      this.empty = new CSL.Token("empty");
      var tokenstore = {};
      tokenstore.empty = this.empty;
      this.formats = new CSL.Stack(tokenstore);
      this.current = new CSL.Stack(this.queue);
    };
    CSL.Output.Queue.prototype.pop = function() {
      var drip = this.current.value();
      if (drip.length) {
        return drip.pop();
      } else {
        return drip.blobs.pop();
      }
    };
    CSL.Output.Queue.prototype.getToken = function(name) {
      var ret = this.formats.value()[name];
      return ret;
    };
    CSL.Output.Queue.prototype.mergeTokenStrings = function(base, modifier) {
      var base_token,
          modifier_token,
          ret,
          key;
      base_token = this.formats.value()[base];
      modifier_token = this.formats.value()[modifier];
      ret = base_token;
      if (modifier_token) {
        if (!base_token) {
          base_token = new CSL.Token(base, CSL.SINGLETON);
          base_token.decorations = [];
        }
        ret = new CSL.Token(base, CSL.SINGLETON);
        key = "";
        for (key in base_token.strings) {
          if (base_token.strings.hasOwnProperty(key)) {
            ret.strings[key] = base_token.strings[key];
          }
        }
        for (key in modifier_token.strings) {
          if (modifier_token.strings.hasOwnProperty(key)) {
            ret.strings[key] = modifier_token.strings[key];
          }
        }
        ret.decorations = base_token.decorations.concat(modifier_token.decorations);
      }
      return ret;
    };
    CSL.Output.Queue.prototype.addToken = function(name, modifier, token) {
      var newtok,
          attr;
      newtok = new CSL.Token("output");
      if ("string" === typeof token) {
        token = this.formats.value()[token];
      }
      if (token && token.strings) {
        for (attr in token.strings) {
          if (token.strings.hasOwnProperty(attr)) {
            newtok.strings[attr] = token.strings[attr];
          }
        }
        newtok.decorations = token.decorations;
      }
      if ("string" === typeof modifier) {
        newtok.strings.delimiter = modifier;
      }
      this.formats.value()[name] = newtok;
    };
    CSL.Output.Queue.prototype.pushFormats = function(tokenstore) {
      if (!tokenstore) {
        tokenstore = {};
      }
      tokenstore.empty = this.empty;
      this.formats.push(tokenstore);
    };
    CSL.Output.Queue.prototype.popFormats = function(tokenstore) {
      this.formats.pop();
    };
    CSL.Output.Queue.prototype.startTag = function(name, token) {
      var tokenstore = {};
      if (this.state.tmp["doing-macro-with-date"] && this.state.tmp.extension) {
        token = this.empty;
        name = "empty";
      }
      tokenstore[name] = token;
      this.pushFormats(tokenstore);
      this.openLevel(name);
    };
    CSL.Output.Queue.prototype.endTag = function(name) {
      this.closeLevel(name);
      this.popFormats();
    };
    CSL.Output.Queue.prototype.openLevel = function(token, ephemeral) {
      var blob,
          curr,
          x,
          has_ephemeral;
      if ("object" === typeof token) {
        blob = new CSL.Blob(undefined, token);
      } else if ("undefined" === typeof token) {
        blob = new CSL.Blob(undefined, this.formats.value().empty, "empty");
      } else {
        if (!this.formats.value() || !this.formats.value()[token]) {
          throw "CSL processor error: call to nonexistent format token \"" + token + "\"";
        }
        blob = new CSL.Blob(undefined, this.formats.value()[token], token);
      }
      curr = this.current.value();
      if (!this.state.tmp.just_looking && this.checkNestedBrace) {
        blob.strings.prefix = this.checkNestedBrace.update(blob.strings.prefix);
      }
      curr.push(blob);
      this.current.push(blob);
    };
    CSL.Output.Queue.prototype.closeLevel = function(name) {
      if (name && name !== this.current.value().levelname) {
        CSL.error("Level mismatch error:  wanted " + name + " but found " + this.current.value().levelname);
      }
      var blob = this.current.pop();
      if (!this.state.tmp.just_looking && this.checkNestedBrace) {
        blob.strings.suffix = this.checkNestedBrace.update(blob.strings.suffix);
      }
    };
    CSL.Output.Queue.prototype.append = function(str, tokname, notSerious, ignorePredecessor, noStripPeriods) {
      var token,
          blob,
          curr;
      var useblob = true;
      if (notSerious) {
        ignorePredecessor = true;
      }
      if (this.state.tmp["doing-macro-with-date"] && !notSerious) {
        if (tokname !== "macro-with-date") {
          return false;
        }
        if (tokname === "macro-with-date") {
          tokname = "empty";
        }
      }
      if ("undefined" === typeof str) {
        return false;
      }
      if ("number" === typeof str) {
        str = "" + str;
      }
      if (!notSerious && this.state.tmp.element_trace && this.state.tmp.element_trace.value() === "suppress-me") {
        return false;
      }
      blob = false;
      if (!tokname) {
        token = this.formats.value().empty;
      } else if (tokname === "literal") {
        token = true;
        useblob = false;
      } else if ("string" === typeof tokname) {
        token = this.formats.value()[tokname];
      } else {
        token = tokname;
      }
      if (!token) {
        throw "CSL processor error: unknown format token name: " + tokname;
      }
      if (token.strings && "undefined" === typeof token.strings.delimiter) {
        token.strings.delimiter = "";
      }
      if ("string" === typeof str && str.length) {
        str = str.replace(/ ([:;?!\u00bb])/g, "\u202f$1").replace(/\u00ab /g, "\u00ab\u202f");
        this.last_char_rendered = str.slice(-1);
        str = str.replace(/\s+'/g, "  \'");
        if (!notSerious) {
          str = str.replace(/^'/g, " \'");
        }
        if (!ignorePredecessor) {
          this.state.tmp.term_predecessor = true;
        } else if (notSerious) {
          this.state.tmp.term_predecessor_name = true;
        }
      }
      blob = new CSL.Blob(str, token);
      curr = this.current.value();
      if ("undefined" === typeof curr && this.current.mystack.length === 0) {
        this.current.mystack.push([]);
        curr = this.current.value();
      }
      if ("string" === typeof blob.blobs) {
        if (!ignorePredecessor) {
          this.state.tmp.term_predecessor = true;
        } else if (notSerious) {
          this.state.tmp.term_predecessor_name = true;
        }
      }
      if (!notSerious) {
        this.state.parallel.AppendBlobPointer(curr);
      }
      if ("string" === typeof str) {
        curr.push(blob);
        if (blob.strings["text-case"]) {
          blob.blobs = CSL.Output.Formatters[blob.strings["text-case"]](this.state, str);
        }
        if (this.state.tmp.strip_periods && !noStripPeriods) {
          blob.blobs = blob.blobs.replace(/\.([^a-z]|$)/g, "$1");
        }
        for (var i = blob.decorations.length - 1; i > -1; i += -1) {
          if (blob.decorations[i][0] === "@quotes" && blob.decorations[i][1] !== "false") {
            blob.punctuation_in_quote = this.state.getOpt("punctuation-in-quote");
          }
          if (!blob.blobs.match(CSL.ROMANESQUE_REGEXP)) {
            if (blob.decorations[i][0] === "@font-style") {
              blob.decorations = blob.decorations.slice(0, i).concat(blob.decorations.slice(i + 1));
            }
          }
        }
        this.state.fun.flipflopper.init(str, blob);
        this.state.fun.flipflopper.processTags();
      } else if (useblob) {
        curr.push(blob);
      } else {
        curr.push(str);
      }
      return true;
    };
    CSL.Output.Queue.prototype.string = function(state, myblobs, blob) {
      var i,
          ilen,
          j,
          jlen,
          b;
      var txt_esc = CSL.getSafeEscape(this.state);
      var blobs = myblobs.slice();
      var ret = [];
      if (blobs.length === 0) {
        return ret;
      }
      var blob_delimiter = "";
      if (blob) {
        blob_delimiter = blob.strings.delimiter;
      } else {
        state.tmp.count_offset_characters = false;
        state.tmp.offset_characters = 0;
      }
      if (blob && blob.new_locale) {
        blob.old_locale = state.opt.lang;
        state.opt.lang = blob.new_locale;
      }
      var blobjr,
          use_suffix,
          use_prefix,
          params;
      for (i = 0, ilen = blobs.length; i < ilen; i += 1) {
        blobjr = blobs[i];
        if (blobjr.strings.first_blob) {
          state.tmp.count_offset_characters = blobjr.strings.first_blob;
        }
        if ("string" === typeof blobjr.blobs) {
          if ("number" === typeof blobjr.num) {
            ret.push(blobjr);
          } else if (blobjr.blobs) {
            b = txt_esc(blobjr.blobs);
            var blen = b.length;
            if (!state.tmp.suppress_decorations) {
              for (j = 0, jlen = blobjr.decorations.length; j < jlen; j += 1) {
                params = blobjr.decorations[j];
                if (params[0] === "@showid") {
                  continue;
                }
                if (state.normalDecorIsOrphan(blobjr, params)) {
                  continue;
                }
                b = state.fun.decorate[params[0]][params[1]].call(blobjr, state, b, params[2]);
              }
            }
            if (b && b.length) {
              b = txt_esc(blobjr.strings.prefix) + b + txt_esc(blobjr.strings.suffix);
              if ((state.opt.development_extensions.csl_reverse_lookup_support || state.sys.csl_reverse_lookup_support) && !state.tmp.suppress_decorations) {
                for (j = 0, jlen = blobjr.decorations.length; j < jlen; j += 1) {
                  params = blobjr.decorations[j];
                  if (params[0] === "@showid") {
                    b = state.fun.decorate[params[0]][params[1]].call(blobjr, state, b, params[2]);
                  }
                }
              }
              ret.push(b);
              if (state.tmp.count_offset_characters) {
                state.tmp.offset_characters += (blen + blobjr.strings.suffix.length + blobjr.strings.prefix.length);
              }
            }
          }
        } else if (blobjr.blobs.length) {
          var addtoret = state.output.string(state, blobjr.blobs, blobjr);
          ret = ret.concat(addtoret);
        }
        if (blobjr.strings.first_blob) {
          state.registry.registry[blobjr.strings.first_blob].offset = state.tmp.offset_characters;
          state.tmp.count_offset_characters = false;
        }
      }
      for (i = 0, ilen = ret.length - 1; i < ilen; i += 1) {
        if ("number" === typeof ret[i].num && "number" === typeof ret[i + 1].num && !ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK) {
          ret[i].strings.suffix = ret[i].strings.suffix + (blob_delimiter ? blob_delimiter : "");
          ret[i + 1].successor_prefix = "";
          ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK = true;
        }
      }
      var span_split = 0;
      for (i = 0, ilen = ret.length; i < ilen; i += 1) {
        if ("string" === typeof ret[i]) {
          span_split = (parseInt(i, 10) + 1);
          if (i < ret.length - 1 && "object" === typeof ret[i + 1]) {
            if (blob_delimiter && !ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK) {
              ret[i] += txt_esc(blob_delimiter);
            }
            ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK = true;
          }
        }
      }
      if (blob && (blob.decorations.length || blob.strings.suffix)) {
        span_split = ret.length;
      } else if (blob && blob.strings.prefix) {
        for (var i = 0,
            ilen = ret.length; i < ilen; i++) {
          if ("undefined" !== typeof ret[i].num) {
            span_split = i;
            if (i === 0) {
              ret[i].strings.prefix = blob.strings.prefix + ret[i].strings.prefix;
            }
            break;
          }
        }
      }
      var blobs_start = state.output.renderBlobs(ret.slice(0, span_split), blob_delimiter, false, blob);
      if (blobs_start && blob && (blob.decorations.length || blob.strings.suffix || blob.strings.prefix)) {
        if (!state.tmp.suppress_decorations) {
          for (i = 0, ilen = blob.decorations.length; i < ilen; i += 1) {
            params = blob.decorations[i];
            if (["@cite", "@bibliography", "@display", "@showid"].indexOf(params[0]) > -1) {
              continue;
            }
            if (state.normalDecorIsOrphan(blobjr, params)) {
              continue;
            }
            if ("string" === typeof blobs_start) {
              blobs_start = state.fun.decorate[params[0]][params[1]].call(blob, state, blobs_start, params[2]);
            }
          }
        }
        b = blobs_start;
        use_suffix = blob.strings.suffix;
        if (b && b.length) {
          use_prefix = blob.strings.prefix;
          b = txt_esc(use_prefix) + b + txt_esc(use_suffix);
          if (state.tmp.count_offset_characters) {
            state.tmp.offset_characters += (use_prefix.length + use_suffix.length);
          }
        }
        blobs_start = b;
        if (!state.tmp.suppress_decorations) {
          for (i = 0, ilen = blob.decorations.length; i < ilen; i += 1) {
            params = blob.decorations[i];
            if (["@cite", "@bibliography", "@display", "@showid"].indexOf(params[0]) === -1) {
              continue;
            }
            if ("string" === typeof blobs_start) {
              blobs_start = state.fun.decorate[params[0]][params[1]].call(blob, state, blobs_start, params[2]);
            }
          }
        }
      }
      var blobs_end = ret.slice(span_split, ret.length);
      if (!blobs_end.length && blobs_start) {
        ret = [blobs_start];
      } else if (blobs_end.length && !blobs_start) {
        ret = blobs_end;
      } else if (blobs_start && blobs_end.length) {
        ret = [blobs_start].concat(blobs_end);
      }
      if ("undefined" === typeof blob) {
        this.queue = [];
        this.current.mystack = [];
        this.current.mystack.push(this.queue);
        if (state.tmp.suppress_decorations) {
          ret = state.output.renderBlobs(ret, undefined, false);
        }
      } else if ("boolean" === typeof blob) {
        ret = state.output.renderBlobs(ret, undefined, true);
      }
      if (blob && blob.new_locale) {
        state.opt.lang = blob.old_locale;
      }
      return ret;
    };
    CSL.Output.Queue.prototype.clearlevel = function() {
      var blob,
          pos,
          len;
      blob = this.current.value();
      len = blob.blobs.length;
      for (pos = 0; pos < len; pos += 1) {
        blob.blobs.pop();
      }
    };
    CSL.Output.Queue.prototype.renderBlobs = function(blobs, delim, in_cite, parent) {
      var state,
          ret,
          ret_last_char,
          use_delim,
          i,
          blob,
          pos,
          len,
          ppos,
          llen,
          pppos,
          lllen,
          res,
          str,
          params,
          txt_esc;
      txt_esc = CSL.getSafeEscape(this.state);
      if (!delim) {
        delim = "";
      }
      state = this.state;
      ret = "";
      ret_last_char = [];
      use_delim = "";
      len = blobs.length;
      if (this.state.tmp.area === "citation" && !this.state.tmp.just_looking && len === 1 && typeof blobs[0] === "object" && parent) {
        blobs[0].strings.prefix = parent.strings.prefix + blobs[0].strings.prefix;
        blobs[0].strings.suffix = blobs[0].strings.suffix + parent.strings.suffix;
        blobs[0].decorations = blobs[0].decorations.concat(parent.decorations);
        blobs[0].params = parent.params;
        return blobs[0];
      }
      var start = true;
      for (pos = 0; pos < len; pos += 1) {
        if (blobs[pos].checkNext) {
          blobs[pos].checkNext(blobs[pos + 1], start);
          start = false;
        } else if (blobs[pos + 1] && blobs[pos + 1].splice_prefix) {
          start = false;
        } else {
          start = true;
        }
      }
      var doit = true;
      for (pos = blobs.length - 1; pos > 0; pos += -1) {
        if (blobs[pos].checkLast) {
          if (doit && blobs[pos].checkLast(blobs[pos - 1])) {
            doit = false;
          }
        } else {
          doit = true;
        }
      }
      len = blobs.length;
      for (pos = 0; pos < len; pos += 1) {
        blob = blobs[pos];
        if (ret) {
          use_delim = delim;
        }
        if ("string" === typeof blob) {
          ret += txt_esc(use_delim);
          ret += blob;
          if (state.tmp.count_offset_characters) {
            state.tmp.offset_characters += (use_delim.length);
          }
        } else if (in_cite) {
          if (ret) {
            ret = [ret, blob];
          } else {
            ret = [blob];
          }
        } else if (blob.status !== CSL.SUPPRESS) {
          if (blob.particle) {
            str = blob.particle + blob.num;
          } else {
            str = blob.formatter.format(blob.num, blob.gender);
          }
          var strlen = str.replace(/<[^>]*>/g, "").length;
          this.append(str, "empty", true);
          var str_blob = this.pop();
          var count_offset_characters = state.tmp.count_offset_characters;
          str = this.string(state, [str_blob], false);
          state.tmp.count_offset_characters = count_offset_characters;
          if (blob.strings["text-case"]) {
            str = CSL.Output.Formatters[blob.strings["text-case"]](this.state, str);
          }
          if (str && this.state.tmp.strip_periods) {
            str = str.replace(/\.([^a-z]|$)/g, "$1");
          }
          if (!state.tmp.suppress_decorations) {
            llen = blob.decorations.length;
            for (ppos = 0; ppos < llen; ppos += 1) {
              params = blob.decorations[ppos];
              if (state.normalDecorIsOrphan(blob, params)) {
                continue;
              }
              str = state.fun.decorate[params[0]][params[1]].call(blob, state, str, params[2]);
            }
          }
          str = txt_esc(blob.strings.prefix) + str + txt_esc(blob.strings.suffix);
          var addme = "";
          if (blob.status === CSL.END) {
            addme = txt_esc(blob.range_prefix);
          } else if (blob.status === CSL.SUCCESSOR) {
            addme = txt_esc(blob.successor_prefix);
          } else if (blob.status === CSL.START) {
            if (pos > 0) {
              addme = txt_esc(blob.splice_prefix);
            } else {
              addme = "";
            }
          } else if (blob.status === CSL.SEEN) {
            addme = txt_esc(blob.splice_prefix);
          }
          ret += addme;
          ret += str;
          if (state.tmp.count_offset_characters) {
            state.tmp.offset_characters += (addme.length + blob.strings.prefix.length + strlen + blob.strings.suffix.length);
          }
        }
      }
      return ret;
    };
    CSL.Output.Queue.purgeEmptyBlobs = function(parent) {
      if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
        return;
      }
      for (var i = parent.blobs.length - 1; i > -1; i--) {
        CSL.Output.Queue.purgeEmptyBlobs(parent.blobs[i]);
        var child = parent.blobs[i];
        if (!child || !child.blobs || !child.blobs.length) {
          var buf = [];
          while ((parent.blobs.length - 1) > i) {
            buf.push(parent.blobs.pop());
          }
          parent.blobs.pop();
          while (buf.length) {
            parent.blobs.push(buf.pop());
          }
        }
      }
    };
    CSL.Output.Queue.adjust = function(punctInQuote) {
      var NO_SWAP_IN = {
        ";": true,
        ":": true
      };
      var NO_SWAP_OUT = {
        ".": true,
        "!": true,
        "?": true
      };
      this.upward = upward;
      this.leftward = leftward;
      this.downward = downward;
      this.fix = fix;
      var LtoR_MAP = {
        "!": {
          ".": "!",
          "?": "!?",
          ":": "!",
          ",": "!,",
          ";": "!;"
        },
        "?": {
          "!": "?!",
          ".": "?",
          ":": "?",
          ",": "?,",
          ";": "?;"
        },
        ".": {
          "!": ".!",
          "?": ".?",
          ":": ".:",
          ",": ".,",
          ";": ".;"
        },
        ":": {
          "!": "!",
          "?": "?",
          ".": ":",
          ",": ":,",
          ";": ":;"
        },
        ",": {
          "!": ",!",
          "?": ",?",
          ":": ",:",
          ".": ",.",
          ";": ",;"
        },
        ";": {
          "!": "!",
          "?": "?",
          ":": ";",
          ",": ";,",
          ".": ";"
        }
      };
      var SWAP_IN = {};
      var SWAP_OUT = {};
      var PUNCT = {};
      var PUNCT_OR_SPACE = {};
      for (var key in LtoR_MAP) {
        PUNCT[key] = true;
        PUNCT_OR_SPACE[key] = true;
        if (!NO_SWAP_IN[key]) {
          SWAP_IN[key] = true;
        }
        if (!NO_SWAP_OUT[key]) {
          SWAP_OUT[key] = true;
        }
      }
      PUNCT_OR_SPACE[" "] = true;
      PUNCT_OR_SPACE[""] = true;
      var RtoL_MAP = {};
      for (var key in LtoR_MAP) {
        for (var subkey in LtoR_MAP[key]) {
          if (!RtoL_MAP[subkey]) {
            RtoL_MAP[subkey] = {};
          }
          RtoL_MAP[subkey][key] = LtoR_MAP[key][subkey];
        }
      }
      function blobIsNumber(blob) {
        return ("number" === typeof blob.num || (blob.blobs && blob.blobs.length === 1 && "number" === typeof blob.blobs[0].num));
      }
      ;
      function blobEndsInNumber(blob) {
        if ("number" === typeof blob.num) {
          return true;
        }
        if (!blob.blobs || "object" !== typeof blob.blobs)
          return false;
        if (blobEndsInNumber(blob.blobs[blob.blobs.length - 1]))
          return true;
      }
      function blobHasDecorations(blob, includeQuotes) {
        var ret = false;
        var decorlist = ['@font-style', '@font-variant', '@font-weight', '@text-decoration', '@vertical-align'];
        if (includeQuotes) {
          decorlist.push('@quotes');
        }
        if (blob.decorations) {
          for (var i = 0,
              ilen = blob.decorations.length; i < ilen; i++) {
            if (decorlist.indexOf(blob.decorations[i][0]) > -1) {
              ret = true;
              break;
            }
          }
        }
        return ret;
      }
      ;
      function blobHasDescendantQuotes(blob) {
        if (blob.decorations) {
          for (var i = 0,
              ilen = blob.decorations.length; i < ilen; i++) {
            if (blob.decorations[i][0] === '@quotes' && blob.decorations[i][1] !== "false") {
              return true;
            }
          }
        }
        if ("object" !== typeof blob.blobs) {
          return false;
        }
        ;
        return blobHasDescendantQuotes(blob.blobs[blob.blobs.length - 1]);
      }
      function blobHasDescendantMergingPunctuation(parentChar, blob) {
        var childChar = blob.strings.suffix.slice(-1);
        if (!childChar && "string" === typeof blob.blobs) {
          childChar = blob.blobs.slice(-1);
        }
        var mergedChars = RtoL_MAP[parentChar][childChar];
        if (mergedChars && mergedChars.length === 1) {
          return true;
        }
        if ("object" !== typeof blob.blobs)
          return false;
        if (blobHasDescendantMergingPunctuation(parentChar, blob.blobs[blob.blobs.length - 1]))
          return true;
        return false;
      }
      function matchLastChar(blob, chr) {
        if (!PUNCT[chr]) {
          return false;
        }
        if ("string" === typeof blob.blobs) {
          if (blob.blobs.slice(-1) === chr) {
            return true;
          } else {
            return false;
          }
        } else {
          var child = blob.blobs[blob.blobs.length - 1];
          if (child) {
            var childChar = child.strings.suffix.slice(-1);
            if (!childChar) {
              return matchLastChar(child, chr);
            } else if (child.strings.suffix.slice(-1) == chr) {
              return true;
            } else {
              return false;
            }
          } else {
            return false;
          }
        }
      }
      ;
      function mergeChars(First, first, Second, second, merge_right) {
        FirstStrings = "blobs" === first ? First : First.strings;
        SecondStrings = "blobs" === second ? Second : Second.strings;
        var firstChar = FirstStrings[first].slice(-1);
        var secondChar = SecondStrings[second].slice(0, 1);
        function cullRight() {
          SecondStrings[second] = SecondStrings[second].slice(1);
        }
        ;
        function cullLeft() {
          FirstStrings[first] = FirstStrings[first].slice(0, -1);
        }
        ;
        function addRight(chr) {
          SecondStrings[second] = chr + SecondStrings[second];
        }
        function addLeft(chr) {
          FirstStrings[first] += chr;
        }
        var cull = merge_right ? cullLeft : cullRight;
        function matchOnRight() {
          return RtoL_MAP[secondChar];
        }
        function matchOnLeft() {
          return LtoR_MAP[firstChar];
        }
        var match = merge_right ? matchOnLeft : matchOnRight;
        function mergeToRight() {
          var chr = LtoR_MAP[firstChar][secondChar];
          if ("string" === typeof chr) {
            cullLeft();
            cullRight();
            addRight(chr);
          } else {
            addRight(firstChar);
            cullLeft();
          }
        }
        function mergeToLeft() {
          var chr = RtoL_MAP[secondChar][firstChar];
          if ("string" === typeof chr) {
            cullLeft();
            cullRight();
            addLeft(chr);
          } else {
            addLeft(secondChar);
            cullRight();
          }
        }
        var merge = merge_right ? mergeToRight : mergeToLeft;
        var isDuplicate = firstChar === secondChar;
        if (isDuplicate) {
          cull();
        } else {
          if (match()) {
            merge();
          }
        }
      }
      ;
      function upward(parent) {
        if (parent.blobs && "string" == typeof parent.blobs) {
          if (PUNCT[parent.strings.suffix.slice(0, 1)] && parent.strings.suffix.slice(0, 1) === parent.blobs.slice(-1)) {
            parent.strings.suffix = parent.strings.suffix.slice(1);
          }
          return;
        } else if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
          return;
        }
        var parentDecorations = blobHasDecorations(parent, true);
        for (var i = parent.blobs.length - 1; i > -1; i--) {
          var endFlag = i === (parent.blobs.length - 1);
          this.upward(parent.blobs[i]);
          var parentStrings = parent.strings;
          var childStrings = parent.blobs[i].strings;
          if (i === 0) {
            if (" " === parentStrings.prefix.slice(-1) && " " === childStrings.prefix.slice(0, 1)) {
              childStrings.prefix = childStrings.prefix.slice(1);
            }
            var childChar = childStrings.prefix.slice(0, 1);
            if (!parentDecorations && PUNCT_OR_SPACE[childChar] && !parentStrings.prefix) {
              parentStrings.prefix += childChar;
              childStrings.prefix = childStrings.prefix.slice(1);
            }
          }
          if (i === (parent.blobs.length - 1)) {
            var childChar = childStrings.suffix.slice(-1);
            if (!parentDecorations && [" "].indexOf(childChar) > -1) {
              if (parentStrings.suffix.slice(0, 1) !== childChar) {
                parentStrings.suffix = childChar + parentStrings.suffix;
              }
              childStrings.suffix = childStrings.suffix.slice(0, -1);
            }
          }
          if (parentStrings.delimiter && i > 0) {
            if (PUNCT_OR_SPACE[parentStrings.delimiter.slice(-1)] && parentStrings.delimiter.slice(-1) === childStrings.prefix.slice(0, 1)) {
              childStrings.prefix = childStrings.prefix.slice(1);
            }
          }
        }
      }
      ;
      function leftward(parent) {
        if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
          return;
        }
        for (var i = parent.blobs.length - 1; i > -1; i--) {
          this.leftward(parent.blobs[i]);
          if ((i < parent.blobs.length - 1) && !parent.strings.delimiter) {
            var child = parent.blobs[i];
            var childChar = child.strings.suffix.slice(-1);
            var sibling = parent.blobs[i + 1];
            var siblingChar = sibling.strings.prefix.slice(0, 1);
            var hasDecorations = blobHasDecorations(child) || blobHasDecorations(sibling);
            var hasNumber = "number" === typeof childChar || "number" === typeof siblingChar;
            if (!hasDecorations && !hasNumber && PUNCT[siblingChar] && !hasNumber) {
              var suffixAndPrefixMatch = siblingChar === child.strings.suffix.slice(-1);
              var suffixAndFieldMatch = (!child.strings.suffix && "string" === typeof child.blobs && child.blobs.slice(-1) === siblingChar);
              if (!suffixAndPrefixMatch && !suffixAndFieldMatch) {
                mergeChars(child, 'suffix', sibling, 'prefix');
              } else {
                sibling.strings.prefix = sibling.strings.prefix.slice(1);
              }
            }
          }
        }
      }
      ;
      function downward(parent, top) {
        if (parent.blobs && "string" == typeof parent.blobs) {
          if (PUNCT[parent.strings.suffix.slice(0, 1)] && parent.strings.suffix.slice(0, 1) === parent.blobs.slice(-1)) {
            parent.strings.suffix = parent.strings.suffix.slice(1);
          }
          return;
        } else if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
          return;
        }
        var parentStrings = parent.strings;
        var someChildrenAreNumbers = false;
        for (var i = 0,
            ilen = parent.blobs.length; i < ilen; i++) {
          if (blobIsNumber(parent.blobs[i])) {
            someChildrenAreNumbers = true;
            break;
          }
        }
        if (true || !someChildrenAreNumbers) {
          if (parentStrings.delimiter && PUNCT[parentStrings.delimiter.slice(0, 1)]) {
            var delimChar = parentStrings.delimiter.slice(0, 1);
            for (var i = parent.blobs.length - 2; i > -1; i--) {
              var childStrings = parent.blobs[i].strings;
              if (childStrings.suffix.slice(-1) !== delimChar) {
                childStrings.suffix += delimChar;
              }
            }
            parentStrings.delimiter = parentStrings.delimiter.slice(1);
          }
        }
        var parentDecorations = blobHasDecorations(parent, true);
        var parentIsNumber = blobIsNumber(parent);
        for (var i = parent.blobs.length - 1; i > -1; i--) {
          var child = parent.blobs[i];
          var childStrings = parent.blobs[i].strings;
          var childDecorations = blobHasDecorations(child, true);
          var childIsNumber = blobIsNumber(child);
          if (i === (parent.blobs.length - 1)) {
            if (true || !someChildrenAreNumbers) {
              var parentChar = parentStrings.suffix.slice(0, 1);
              var allowMigration = false;
              if (PUNCT[parentChar]) {
                allowMigration = blobHasDescendantMergingPunctuation(parentChar, child);
                if (!allowMigration && punctInQuote) {
                  allowMigration = blobHasDescendantQuotes(child);
                }
              }
              if (allowMigration) {
                if (PUNCT[parentChar]) {
                  if (!blobEndsInNumber(child)) {
                    if ("string" === typeof child.blobs) {
                      mergeChars(child, 'blobs', parent, 'suffix');
                    } else {
                      mergeChars(child, 'suffix', parent, 'suffix');
                    }
                    if (parentStrings.suffix.slice(0, 1) === ".") {
                      childStrings.suffix += parentStrings.suffix.slice(0, 1);
                      parentStrings.suffix = parentStrings.suffix.slice(1);
                    }
                  }
                }
              }
              if (childStrings.suffix.slice(-1) === "" && parentStrings.suffix.slice(0, 1) === " ") {
                parentStrings.suffix = parentStrings.suffix.slice(1);
              }
              if (PUNCT_OR_SPACE[childStrings.suffix.slice(0, 1)]) {
                if ("string" === typeof child.blobs && child.blobs.slice(-1) === childStrings.suffix.slice(0, 1)) {
                  childStrings.suffix = childStrings.suffix.slice(1);
                }
                if (childStrings.suffix.slice(-1) === parentStrings.suffix.slice(0, 1)) {
                  parentStrings.suffix = parentStrings.suffix.slice(0, -1);
                }
              }
            }
            if (matchLastChar(parent, parent.strings.suffix.slice(0, 1))) {
              parent.strings.suffix = parent.strings.suffix.slice(1);
            }
          } else if (parentStrings.delimiter) {
            if (PUNCT_OR_SPACE[parentStrings.delimiter.slice(0, 1)] && parentStrings.delimiter.slice(0, 1) === childStrings.suffix.slice(-1)) {
              parent.blobs[i].strings.suffix = parent.blobs[i].strings.suffix.slice(0, -1);
            }
          } else {
            var siblingStrings = parent.blobs[i + 1].strings;
            if (!blobIsNumber(child) && !childDecorations && PUNCT_OR_SPACE[childStrings.suffix.slice(-1)] && childStrings.suffix.slice(-1) === siblingStrings.prefix.slice(0, 1)) {
              siblingStrings.prefix = siblingStrings.prefix.slice(1);
            }
          }
          if (!childIsNumber && !childDecorations && PUNCT[childStrings.suffix.slice(0, 1)] && "string" === typeof child.blobs) {
            mergeChars(child, 'blobs', child, 'suffix');
          }
          this.downward(parent.blobs[i]);
        }
      }
      ;
      function swapToTheLeft(child) {
        var childChar = child.strings.suffix.slice(0, 1);
        if ("string" === typeof child.blobs) {
          while (SWAP_IN[childChar]) {
            mergeChars(child, 'blobs', child, 'suffix');
            childChar = child.strings.suffix.slice(0, 1);
          }
        } else {
          while (SWAP_IN[childChar]) {
            mergeChars(child.blobs[child.blobs.length - 1], 'suffix', child, 'suffix');
            childChar = child.strings.suffix.slice(0, 1);
          }
        }
      }
      function swapToTheRight(child) {
        if ("string" === typeof child.blobs) {
          var childChar = child.blobs.slice(-1);
          while (SWAP_OUT[childChar]) {
            mergeChars(child, 'blobs', child, 'suffix', true);
            childChar = child.blobs.slice(-1);
          }
        } else {
          var childChar = child.blobs[child.blobs.length - 1].strings.suffix.slice(-1);
          while (SWAP_OUT[childChar]) {
            mergeChars(child.blobs[child.blobs.length - 1], 'suffix', child, 'suffix', true);
            childChar = child.blobs[child.blobs.length - 1].strings.suffix.slice(-1);
          }
        }
      }
      function fix(parent) {
        if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
          return;
        }
        var lastChar;
        for (var i = 0,
            ilen = parent.blobs.length; i < ilen; i++) {
          var child = parent.blobs[i];
          var quoteSwap = false;
          for (var j = 0,
              jlen = child.decorations.length; j < jlen; j++) {
            var decoration = child.decorations[j];
            if (decoration[0] === "@quotes" && decoration[1] !== "false") {
              quoteSwap = true;
            }
          }
          if (quoteSwap) {
            if (punctInQuote) {
              swapToTheLeft(child);
            } else {
              swapToTheRight(child);
            }
          }
          lastChar = this.fix(parent.blobs[i]);
          if (child.blobs && "string" === typeof child.blobs) {
            lastChar = child.blobs.slice(-1);
          }
        }
        return lastChar;
      }
      ;
    };
    CSL.Engine.Opt = function() {
      this.has_disambiguate = false;
      this.mode = "html";
      this.dates = {};
      this.jurisdictions_seen = {};
      this.suppressedJurisdictions = {};
      this["locale-sort"] = [];
      this["locale-translit"] = [];
      this["locale-translat"] = [];
      this.citeAffixes = {
        persons: {
          "locale-orig": {
            prefix: "",
            suffix: ""
          },
          "locale-translit": {
            prefix: "",
            suffix: ""
          },
          "locale-translat": {
            prefix: "",
            suffix: ""
          }
        },
        institutions: {
          "locale-orig": {
            prefix: "",
            suffix: ""
          },
          "locale-translit": {
            prefix: "",
            suffix: ""
          },
          "locale-translat": {
            prefix: "",
            suffix: ""
          }
        },
        titles: {
          "locale-orig": {
            prefix: "",
            suffix: ""
          },
          "locale-translit": {
            prefix: "",
            suffix: ""
          },
          "locale-translat": {
            prefix: "",
            suffix: ""
          }
        },
        journals: {
          "locale-orig": {
            prefix: "",
            suffix: ""
          },
          "locale-translit": {
            prefix: "",
            suffix: ""
          },
          "locale-translat": {
            prefix: "",
            suffix: ""
          }
        },
        publishers: {
          "locale-orig": {
            prefix: "",
            suffix: ""
          },
          "locale-translit": {
            prefix: "",
            suffix: ""
          },
          "locale-translat": {
            prefix: "",
            suffix: ""
          }
        },
        places: {
          "locale-orig": {
            prefix: "",
            suffix: ""
          },
          "locale-translit": {
            prefix: "",
            suffix: ""
          },
          "locale-translat": {
            prefix: "",
            suffix: ""
          }
        }
      };
      this["default-locale"] = [];
      this.update_mode = CSL.NONE;
      this.bib_mode = CSL.NONE;
      this.sort_citations = false;
      this["et-al-min"] = 0;
      this["et-al-use-first"] = 1;
      this["et-al-use-last"] = false;
      this["et-al-subsequent-min"] = false;
      this["et-al-subsequent-use-first"] = false;
      this["demote-non-dropping-particle"] = "display-and-sort";
      this["parse-names"] = true;
      this.citation_number_slug = false;
      this.trigraph = "Aaaa00:AaAa00:AaAA00:AAAA00";
      this.nodenames = [];
      this.gender = {};
      this['cite-lang-prefs'] = {
        persons: ['orig'],
        institutions: ['orig'],
        titles: ['orig', 'translat'],
        journals: ['translit'],
        publishers: ['orig'],
        places: ['orig'],
        number: ['translat']
      };
      this.has_layout_locale = false;
      this.development_extensions = {};
      this.development_extensions.field_hack = true;
      this.development_extensions.locator_date_and_revision = true;
      this.development_extensions.locator_parsing_for_plurals = true;
      this.development_extensions.locator_label_parse = true;
      this.development_extensions.raw_date_parsing = true;
      this.development_extensions.clean_up_csl_flaws = true;
      this.development_extensions.flip_parentheses_to_braces = true;
      this.development_extensions.jurisdiction_subfield = true;
      this.development_extensions.static_statute_locator = false;
      this.development_extensions.csl_reverse_lookup_support = false;
      this.development_extensions.clobber_locator_if_no_statute_section = false;
      this.development_extensions.wrap_url_and_doi = false;
      this.development_extensions.allow_force_lowercase = false;
      this.development_extensions.handle_parallel_articles = false;
      this.development_extensions.thin_non_breaking_space_html_hack = false;
      this.development_extensions.apply_citation_wrapper = false;
      this.development_extensions.main_title_from_short_title = false;
      this.development_extensions.uppercase_subtitles = false;
      this.development_extensions.normalize_lang_keys_to_lowercase = false;
      this.development_extensions.strict_text_case_locales = false;
      this.development_extensions.rtl_support = false;
      this.development_extensions.expect_and_symbol_form = false;
      this.development_extensions.require_explicit_legal_case_title_short = false;
      this.development_extensions.spoof_institutional_affiliations = false;
      this.development_extensions.force_jurisdiction = false;
      this.development_extensions.parse_names = true;
    };
    CSL.Engine.Tmp = function() {
      this.names_max = new CSL.Stack();
      this.names_base = new CSL.Stack();
      this.givens_base = new CSL.Stack();
      this.value = [];
      this.namepart_decorations = {};
      this.namepart_type = false;
      this.area = "citation";
      this.root = "citation";
      this.extension = "";
      this.can_substitute = new CSL.Stack(0, CSL.LITERAL);
      this.element_rendered_ok = false;
      this.element_trace = new CSL.Stack("style");
      this.nameset_counter = 0;
      this.group_context = new CSL.Stack({
        term_intended: false,
        variable_attempt: false,
        variable_success: false,
        output_tip: undefined,
        label_form: undefined,
        parallel_conditions: undefined,
        condition: false,
        force_suppress: false,
        done_vars: []
      });
      this.term_predecessor = false;
      this.jump = new CSL.Stack(0, CSL.LITERAL);
      this.decorations = new CSL.Stack();
      this.tokenstore_stack = new CSL.Stack();
      this.last_suffix_used = "";
      this.last_names_used = [];
      this.last_years_used = [];
      this.years_used = [];
      this.names_used = [];
      this.taintedItemIDs = {};
      this.taintedCitationIDs = {};
      this.initialize_with = new CSL.Stack();
      this.disambig_request = false;
      this["name-as-sort-order"] = false;
      this.suppress_decorations = false;
      this.disambig_settings = new CSL.AmbigConfig();
      this.bib_sort_keys = [];
      this.prefix = new CSL.Stack("", CSL.LITERAL);
      this.suffix = new CSL.Stack("", CSL.LITERAL);
      this.delimiter = new CSL.Stack("", CSL.LITERAL);
      this.cite_locales = [];
      this.cite_affixes = {
        citation: false,
        bibliography: false,
        citation_sort: false,
        bibliography_sort: false
      };
      this.strip_periods = 0;
      this.shadow_numbers = {};
      this.authority_stop_last = 0;
    };
    CSL.Engine.Fun = function(state) {
      this.match = new CSL.Util.Match;
      this.suffixator = new CSL.Util.Suffixator(CSL.SUFFIX_CHARS);
      this.romanizer = new CSL.Util.Romanizer();
      this.ordinalizer = new CSL.Util.Ordinalizer(state);
      this.long_ordinalizer = new CSL.Util.LongOrdinalizer();
    };
    CSL.Engine.Build = function() {
      this["alternate-term"] = false;
      this.in_bibliography = false;
      this.in_style = false;
      this.skip = false;
      this.postponed_macro = false;
      this.layout_flag = false;
      this.name = false;
      this.form = false;
      this.term = false;
      this.macro = {};
      this.macro_stack = [];
      this.text = false;
      this.lang = false;
      this.area = "citation";
      this.root = "citation";
      this.extension = "";
      this.substitute_level = new CSL.Stack(0, CSL.LITERAL);
      this.names_level = 0;
      this.render_nesting_level = 0;
      this.render_seen = false;
    };
    CSL.Engine.Configure = function() {
      this.fail = [];
      this.succeed = [];
    };
    CSL.Engine.Citation = function(state) {
      this.opt = {};
      this.tokens = [];
      this.srt = new CSL.Registry.Comparifier(state, "citation_sort");
      this.opt.collapse = [];
      this.opt["disambiguate-add-names"] = false;
      this.opt["disambiguate-add-givenname"] = false;
      this.opt["disambiguate-add-year-suffix"] = false;
      this.opt["givenname-disambiguation-rule"] = "by-cite";
      this.opt["near-note-distance"] = 5;
      this.opt.topdecor = [];
      this.opt.layout_decorations = [];
      this.opt.layout_prefix = "";
      this.opt.layout_suffix = "";
      this.opt.layout_delimiter = "";
      this.opt.sort_locales = [];
      this.opt.max_number_of_names = 0;
      this.root = "citation";
    };
    CSL.Engine.Bibliography = function() {
      this.opt = {};
      this.tokens = [];
      this.opt.collapse = [];
      this.opt.topdecor = [];
      this.opt.layout_decorations = [];
      this.opt.layout_prefix = "";
      this.opt.layout_suffix = "";
      this.opt.layout_delimiter = "";
      this.opt["line-spacing"] = 1;
      this.opt["entry-spacing"] = 1;
      this.opt.sort_locales = [];
      this.opt.max_number_of_names = 0;
      this.root = "bibliography";
    };
    CSL.Engine.BibliographySort = function() {
      this.tokens = [];
      this.opt = {};
      this.opt.sort_directions = [];
      this.keys = [];
      this.opt.topdecor = [];
      this.root = "bibliography";
    };
    CSL.Engine.CitationSort = function() {
      this.tokens = [];
      this.opt = {};
      this.opt.sort_directions = [];
      this.keys = [];
      this.opt.topdecor = [];
      this.root = "citation";
    };
    CSL.Engine.prototype.previewCitationCluster = function(citation, citationsPre, citationsPost, newMode) {
      var oldMode = this.opt.mode;
      this.setOutputFormat(newMode);
      var ret = this.processCitationCluster(citation, citationsPre, citationsPost, CSL.PREVIEW);
      this.setOutputFormat(oldMode);
      return ret[1];
    };
    CSL.Engine.prototype.appendCitationCluster = function(citation) {
      var citationsPre = [];
      var len = this.registry.citationreg.citationByIndex.length;
      for (var pos = 0; pos < len; pos += 1) {
        var c = this.registry.citationreg.citationByIndex[pos];
        citationsPre.push(["" + c.citationID, c.properties.noteIndex]);
      }
      return this.processCitationCluster(citation, citationsPre, [])[1];
    };
    CSL.Engine.prototype.processCitationCluster = function(citation, citationsPre, citationsPost, flag) {
      var c,
          i,
          ilen,
          j,
          jlen,
          k,
          klen,
          n,
          nlen,
          key,
          Item,
          item,
          noteCitations,
          textCitations,
          m,
          citationsInNote;
      this.debug = false;
      this.tmp.citation_errors = [];
      var return_data = {"bibchange": false};
      this.setCitationId(citation);
      var oldCitationList;
      var oldItemList;
      var oldAmbigs;
      if (flag === CSL.PREVIEW) {
        oldCitationList = this.registry.citationreg.citationByIndex.slice();
        oldItemList = this.registry.reflist.slice();
        var newCitationList = citationsPre.concat([["" + citation.citationID, citation.properties.noteIndex]]).concat(citationsPost);
        var newItemIds = {};
        var newItemIdsList = [];
        for (i = 0, ilen = newCitationList.length; i < ilen; i += 1) {
          c = this.registry.citationreg.citationById[newCitationList[i][0]];
          for (j = 0, jlen = c.citationItems.length; j < jlen; j += 1) {
            newItemIds[c.citationItems[j].id] = true;
            newItemIdsList.push("" + c.citationItems[j].id);
          }
        }
        oldAmbigs = {};
        for (i = 0, ilen = oldItemList.length; i < ilen; i += 1) {
          if (!newItemIds[oldItemList[i].id]) {
            var oldAkey = this.registry.registry[oldItemList[i].id].ambig;
            var ids = this.registry.ambigcites[oldAkey];
            if (ids) {
              for (j = 0, jlen = ids.length; j < jlen; j += 1) {
                oldAmbigs[ids[j]] = CSL.cloneAmbigConfig(this.registry.registry[ids[j]].disambig);
              }
            }
          }
        }
      }
      this.tmp.taintedCitationIDs = {};
      var sortedItems = [];
      var rerunAkeys = {};
      for (i = 0, ilen = citation.citationItems.length; i < ilen; i += 1) {
        item = {};
        for (key in citation.citationItems[i]) {
          item[key] = citation.citationItems[i][key];
        }
        Item = this.retrieveItem("" + item.id);
        if (Item.id) {
          this.transform.loadAbbreviation("default", "hereinafter", Item.id);
        }
        if (this.opt.development_extensions.locator_date_and_revision) {
          if (item.locator) {
            item.locator = "" + item.locator;
            var idx = item.locator.indexOf("|");
            if (idx > -1) {
              var raw_locator = item.locator;
              item.locator = raw_locator.slice(0, idx);
              raw_locator = raw_locator.slice(idx + 1);
              m = raw_locator.match(/^([0-9]{4}-[0-9]{2}-[0-9]{2}).*/);
              if (m) {
                item["locator-date"] = this.fun.dateparser.parseDateToObject(m[1]);
                raw_locator = raw_locator.slice(m[1].length);
              }
              item["locator-extra"] = raw_locator.replace(/^\s+/, "").replace(/\s+$/, "");
            }
          }
        }
        if (item.locator) {
          item.locator = ("" + item.locator).replace(/\s+$/, '');
        }
        this.remapSectionVariable([[Item, item]]);
        if (this.opt.development_extensions.locator_label_parse) {
          if (item.locator && ["bill", "gazette", "legislation", "regulation", "treaty"].indexOf(Item.type) === -1 && (!item.label || item.label === 'page')) {
            m = CSL.LOCATOR_LABELS_REGEXP.exec(item.locator);
            if (m) {
              var tryLabel = CSL.LOCATOR_LABELS_MAP[m[2]];
              if (this.getTerm(tryLabel)) {
                item.label = tryLabel;
                item.locator = m[3];
              }
            }
          }
        }
        var newitem = [Item, item];
        sortedItems.push(newitem);
        citation.citationItems[i].item = Item;
      }
      citation.sortedItems = sortedItems;
      var citationByIndex = [];
      for (i = 0, ilen = citationsPre.length; i < ilen; i += 1) {
        c = citationsPre[i];
        this.registry.citationreg.citationById[c[0]].properties.noteIndex = c[1];
        citationByIndex.push(this.registry.citationreg.citationById[c[0]]);
      }
      citationByIndex.push(citation);
      for (i = 0, ilen = citationsPost.length; i < ilen; i += 1) {
        c = citationsPost[i];
        this.registry.citationreg.citationById[c[0]].properties.noteIndex = c[1];
        citationByIndex.push(this.registry.citationreg.citationById[c[0]]);
      }
      this.registry.citationreg.citationByIndex = citationByIndex;
      this.registry.citationreg.citationsByItemId = {};
      if (this.opt.update_mode === CSL.POSITION) {
        textCitations = [];
        noteCitations = [];
        citationsInNote = {};
      }
      var update_items = [];
      for (i = 0, ilen = citationByIndex.length; i < ilen; i += 1) {
        citationByIndex[i].properties.index = i;
        for (j = 0, jlen = citationByIndex[i].sortedItems.length; j < jlen; j += 1) {
          item = citationByIndex[i].sortedItems[j];
          if (!this.registry.citationreg.citationsByItemId[item[1].id]) {
            this.registry.citationreg.citationsByItemId[item[1].id] = [];
            update_items.push("" + item[1].id);
          }
          if (this.registry.citationreg.citationsByItemId[item[1].id].indexOf(citationByIndex[i]) === -1) {
            this.registry.citationreg.citationsByItemId[item[1].id].push(citationByIndex[i]);
          }
        }
        if (this.opt.update_mode === CSL.POSITION) {
          if (citationByIndex[i].properties.noteIndex) {
            noteCitations.push(citationByIndex[i]);
          } else {
            citationByIndex[i].properties.noteIndex = 0;
            textCitations.push(citationByIndex[i]);
          }
        }
      }
      if (flag !== CSL.ASSUME_ALL_ITEMS_REGISTERED) {
        this.updateItems(update_items);
      }
      if (!this.opt.citation_number_sort && sortedItems && sortedItems.length > 1 && this.citation_sort.tokens.length > 0) {
        for (i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
          sortedItems[i][1].sortkeys = CSL.getSortKeys.call(this, sortedItems[i][0], "citation_sort");
        }
        if (this.opt.grouped_sort && !citation.properties.unsorted) {
          for (i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
            var sortkeys = sortedItems[i][1].sortkeys;
            this.tmp.authorstring_request = true;
            var mydisambig = this.registry.registry[sortedItems[i][0].id].disambig;
            this.tmp.authorstring_request = true;
            CSL.getAmbiguousCite.call(this, sortedItems[i][0], mydisambig);
            var authorstring = this.registry.authorstrings[sortedItems[i][0].id];
            this.tmp.authorstring_request = false;
            sortedItems[i][1].sortkeys = [authorstring].concat(sortkeys);
          }
          sortedItems.sort(this.citation.srt.compareCompositeKeys);
          var lastauthor = false;
          var thiskey = false;
          var thisauthor = false;
          for (i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
            if (sortedItems[i][1].sortkeys[0] !== lastauthor) {
              thisauthor = sortedItems[i][1].sortkeys[0];
              thiskey = sortedItems[i][1].sortkeys[1];
            }
            sortedItems[i][1].sortkeys[0] = "" + thiskey + i;
            lastauthor = thisauthor;
          }
        }
        if (!citation.properties.unsorted) {
          sortedItems.sort(this.citation.srt.compareCompositeKeys);
        }
      }
      var citations;
      if (this.opt.update_mode === CSL.POSITION) {
        for (i = 0; i < 2; i += 1) {
          citations = [textCitations, noteCitations][i];
          var first_ref = {};
          var last_ref = {};
          for (j = 0, jlen = citations.length; j < jlen; j += 1) {
            var onecitation = citations[j];
            if (!citations[j].properties.noteIndex) {
              citations[j].properties.noteIndex = 0;
            }
            citations[j].properties.noteIndex = parseInt(citations[j].properties.noteIndex, 10);
            if (j > 0 && citations[j - 1].properties.noteIndex > citations[j].properties.noteIndex) {
              citationsInNote = {};
              first_ref = {};
              last_ref = {};
            }
            for (k = 0, klen = onecitation.sortedItems.length; k < klen; k += 1) {
              if (!this.registry.registry[onecitation.sortedItems[k][1].id].parallel) {
                if (!citationsInNote[onecitation.properties.noteIndex]) {
                  citationsInNote[onecitation.properties.noteIndex] = 1;
                } else {
                  citationsInNote[onecitation.properties.noteIndex] += 1;
                }
              }
            }
            for (k = 0, klen = citations[j].sortedItems.length; k < klen; k += 1) {
              item = citations[j].sortedItems[k];
              var myid = item[0].id;
              var mylocator = item[1].locator;
              var mylabel = item[1].label;
              if (item[0].legislation_id) {
                myid = item[0].legislation_id;
              }
              var incitationid;
              if (k > 0) {
                if (onecitation.sortedItems[k - 1][0].legislation_id) {
                  incitationid = onecitation.sortedItems[k - 1][0].legislation_id;
                } else {
                  incitationid = onecitation.sortedItems[k - 1][1].id;
                }
              }
              if (flag === CSL.PREVIEW) {
                if (onecitation.citationID != citation.citationID) {
                  if ("undefined" === typeof first_ref[item[1].id]) {
                    first_ref[myid] = onecitation.properties.noteIndex;
                    last_ref[myid] = onecitation.properties.noteIndex;
                  } else {
                    last_ref[myid] = onecitation.properties.noteIndex;
                  }
                  continue;
                }
              }
              var oldvalue = {};
              oldvalue.position = item[1].position;
              oldvalue["first-reference-note-number"] = item[1]["first-reference-note-number"];
              oldvalue["near-note"] = item[1]["near-note"];
              item[1]["first-reference-note-number"] = 0;
              item[1]["near-note"] = false;
              if (this.registry.citationreg.citationsByItemId[myid]) {
                if (this.opt.xclass === 'note' && this.opt.has_disambiguate) {
                  var oldCount = this.registry.registry[myid]["citation-count"];
                  var newCount = this.registry.citationreg.citationsByItemId[myid].length;
                  this.registry.registry[myid]["citation-count"] = this.registry.citationreg.citationsByItemId[myid].length;
                  if ("number" === typeof oldCount) {
                    var oldCountCheck = (oldCount < 2);
                    var newCountCheck = (newCount < 2);
                    if (oldCountCheck !== newCountCheck) {
                      for (var l = 0,
                          llen = this.registry.citationreg.citationsByItemId[myid].length; l < llen; l++) {
                        rerunAkeys[this.registry.registry[myid].ambig] = true;
                        this.tmp.taintedCitationIDs[this.registry.citationreg.citationsByItemId[myid][l].citationID] = true;
                      }
                    }
                  } else {
                    for (var l = 0,
                        llen = this.registry.citationreg.citationsByItemId[myid].length; l < llen; l++) {
                      rerunAkeys[this.registry.registry[myid].ambig] = true;
                      this.tmp.taintedCitationIDs[this.registry.citationreg.citationsByItemId[myid][l].citationID] = true;
                    }
                  }
                }
              }
              var oldlastid;
              if ("undefined" === typeof first_ref[myid]) {
                first_ref[myid] = onecitation.properties.noteIndex;
                if (this.registry.registry[myid]) {
                  this.registry.registry[myid]['first-reference-note-number'] = onecitation.properties.noteIndex;
                }
                last_ref[myid] = onecitation.properties.noteIndex;
                item[1].position = CSL.POSITION_FIRST;
              } else {
                var ibidme = false;
                var suprame = false;
                if (j > 0) {
                  oldlastid = citations[j - 1].sortedItems.slice(-1)[0][1].id;
                  if (citations[j - 1].sortedItems[0].slice(-1)[0].legislation_id) {
                    oldlastid = citations[j - 1].sortedItems[0].slice(-1)[0].legislation_id;
                  }
                }
                if (j > 0 && parseInt(k, 10) === 0 && citations[j - 1].properties.noteIndex !== citations[j].properties.noteIndex) {
                  var items = citations[(j - 1)].sortedItems;
                  var useme = false;
                  var oldid = citations[j - 1].sortedItems[0][0].id;
                  if (citations[j - 1].sortedItems[0][0].legislation_id) {
                    oldid = citations[j - 1].sortedItems[0][0].legislation_id;
                  }
                  if ((oldid == myid && citations[j - 1].properties.noteIndex >= (citations[j].properties.noteIndex - 1)) || citations[j - 1].sortedItems[0][1].id == this.registry.registry[item[1].id].parallel) {
                    if (citationsInNote[citations[j - 1].properties.noteIndex] === 1 || citations[j - 1].properties.noteIndex === 0) {
                      useme = true;
                    }
                  }
                  for (n = 0, nlen = items.slice(1).length; n < nlen; n += 1) {
                    var itmp = items.slice(1)[n];
                    if (!this.registry.registry[itmp[1].id].parallel || this.registry.registry[itmp[1].id].parallel == this.registry.registry[itmp[1].id]) {
                      useme = false;
                    }
                  }
                  if (useme) {
                    ibidme = true;
                  } else {
                    suprame = true;
                  }
                } else if (k > 0 && incitationid == myid) {
                  ibidme = true;
                } else if (k === 0 && citations[j - 1].properties.noteIndex == citations[j].properties.noteIndex && citations[j - 1].sortedItems.length && oldlastid == myid) {
                  ibidme = true;
                } else {
                  suprame = true;
                }
                var prev,
                    prev_locator,
                    prev_label,
                    curr_locator,
                    curr_label;
                if (ibidme) {
                  if (k > 0) {
                    prev = onecitation.sortedItems[(k - 1)][1];
                  } else {
                    prev = citations[(j - 1)].sortedItems[0][1];
                  }
                  if (prev.locator) {
                    if (prev.label) {
                      prev_label = prev.label;
                    } else {
                      prev_label = "";
                    }
                    prev_locator = "" + prev.locator + prev_label;
                  } else {
                    prev_locator = prev.locator;
                  }
                  if (mylocator) {
                    if (mylabel) {
                      curr_label = mylabel;
                    } else {
                      curr_label = "";
                    }
                    curr_locator = "" + mylocator + curr_label;
                  } else {
                    curr_locator = mylocator;
                  }
                }
                if (ibidme && prev_locator && !curr_locator) {
                  ibidme = false;
                  suprame = true;
                }
                if (ibidme) {
                  if (!prev_locator && curr_locator) {
                    item[1].position = CSL.POSITION_IBID_WITH_LOCATOR;
                  } else if (!prev_locator && !curr_locator) {
                    item[1].position = CSL.POSITION_IBID;
                  } else if (prev_locator && curr_locator === prev_locator) {
                    item[1].position = CSL.POSITION_IBID;
                  } else if (prev_locator && curr_locator && curr_locator !== prev_locator) {
                    item[1].position = CSL.POSITION_IBID_WITH_LOCATOR;
                  } else {
                    ibidme = false;
                    suprame = true;
                  }
                }
                if (suprame) {
                  item[1].position = CSL.POSITION_SUBSEQUENT;
                }
                if (suprame || ibidme) {
                  if (first_ref[myid] != onecitation.properties.noteIndex) {
                    item[1]["first-reference-note-number"] = first_ref[myid];
                    if (this.registry.registry[myid]) {
                      var oldFirst = this.registry.citationreg.citationsByItemId[myid][0].properties.noteIndex;
                      var newFirst = onecitation.properties.noteIndex;
                      this.registry.registry[myid]['first-reference-note-number'] = newFirst < oldFirst ? newFirst : oldFirst;
                    }
                  }
                }
              }
              if (onecitation.properties.noteIndex) {
                var note_distance = parseInt(onecitation.properties.noteIndex, 10) - parseInt(last_ref[myid], 10);
                if (item[1].position !== CSL.POSITION_FIRST && note_distance <= this.citation.opt["near-note-distance"]) {
                  item[1]["near-note"] = true;
                }
                last_ref[myid] = onecitation.properties.noteIndex;
              }
              if (onecitation.citationID != citation.citationID) {
                for (n = 0, nlen = CSL.POSITION_TEST_VARS.length; n < nlen; n += 1) {
                  var param = CSL.POSITION_TEST_VARS[n];
                  if (item[1][param] !== oldvalue[param]) {
                    if (this.registry.registry[myid]) {
                      if (param === 'first-reference-note-number') {
                        rerunAkeys[this.registry.registry[myid].ambig] = true;
                        this.tmp.taintedItemIDs[myid] = true;
                      }
                    }
                    this.tmp.taintedCitationIDs[onecitation.citationID] = true;
                  }
                }
              }
              if (this.sys.variableWrapper) {
                item[1].index = onecitation.properties.index;
                item[1].noteIndex = onecitation.properties.noteIndex;
              }
            }
          }
        }
      }
      if (this.opt.citation_number_sort && sortedItems && sortedItems.length > 1 && this.citation_sort.tokens.length > 0) {
        for (i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
          sortedItems[i][1].sortkeys = CSL.getSortKeys.call(this, sortedItems[i][0], "citation_sort");
        }
        if (!citation.properties.unsorted) {
          sortedItems.sort(this.citation.srt.compareCompositeKeys);
        }
      }
      for (key in this.tmp.taintedItemIDs) {
        if (this.tmp.taintedItemIDs.hasOwnProperty(key)) {
          citations = this.registry.citationreg.citationsByItemId[key];
          if (citations) {
            for (i = 0, ilen = citations.length; i < ilen; i += 1) {
              this.tmp.taintedCitationIDs[citations[i].citationID] = true;
            }
          }
        }
      }
      var ret = [];
      if (flag === CSL.PREVIEW) {
        try {
          ret = this.process_CitationCluster.call(this, citation.sortedItems, citation.citationID);
        } catch (e) {
          CSL.error("Error running CSL processor for preview: " + e);
        }
        this.registry.citationreg.citationByIndex = oldCitationList;
        this.registry.citationreg.citationById = {};
        for (i = 0, ilen = oldCitationList.length; i < ilen; i += 1) {
          this.registry.citationreg.citationById[oldCitationList[i].citationID] = oldCitationList[i];
        }
        var oldItemIds = [];
        for (i = 0, ilen = oldItemList.length; i < ilen; i += 1) {
          oldItemIds.push("" + oldItemList[i].id);
        }
        this.updateItems(oldItemIds);
        for (key in oldAmbigs) {
          if (oldAmbigs.hasOwnProperty(key)) {
            this.registry.registry[key].disambig = oldAmbigs[key];
          }
        }
      } else {
        for (var rerunAkey in rerunAkeys) {
          this.disambiguate.run(rerunAkey, citation);
        }
        var obj;
        for (key in this.tmp.taintedCitationIDs) {
          if (key == citation.citationID) {
            continue;
          }
          var mycitation = this.registry.citationreg.citationById[key];
          this.tmp.citation_pos = mycitation.properties.index;
          this.tmp.citation_note_index = mycitation.properties.noteIndex;
          this.tmp.citation_id = "" + mycitation.citationID;
          obj = [];
          obj.push(mycitation.properties.index);
          obj.push(this.process_CitationCluster.call(this, mycitation.sortedItems, mycitation.citationID));
          ret.push(obj);
        }
        this.tmp.taintedItemIDs = {};
        this.tmp.taintedCitationIDs = {};
        this.tmp.citation_pos = citation.properties.index;
        this.tmp.citation_note_index = citation.properties.noteIndex;
        this.tmp.citation_id = "" + citation.citationID;
        obj = [];
        obj.push(citationsPre.length);
        obj.push(this.process_CitationCluster.call(this, sortedItems, citation.citationID));
        ret.push(obj);
        ret.sort(function(a, b) {
          if (a[0] > b[0]) {
            return 1;
          } else if (a[0] < b[0]) {
            return -1;
          } else {
            return 0;
          }
        });
      }
      return_data.citation_errors = this.tmp.citation_errors.slice();
      return [return_data, ret];
    };
    CSL.Engine.prototype.process_CitationCluster = function(sortedItems, citationID) {
      var str;
      this.parallel.StartCitation(sortedItems);
      str = CSL.getCitationCluster.call(this, sortedItems, citationID);
      return str;
    };
    CSL.Engine.prototype.makeCitationCluster = function(rawList) {
      var inputList,
          newitem,
          str,
          pos,
          len,
          item,
          Item;
      inputList = [];
      len = rawList.length;
      for (pos = 0; pos < len; pos += 1) {
        item = {};
        for (var key in rawList[pos]) {
          item[key] = rawList[pos][key];
        }
        Item = this.retrieveItem("" + item.id);
        if (this.opt.development_extensions.locator_label_parse) {
          if (item.locator && ["bill", "gazette", "legislation", "regulation", "treaty"].indexOf(Item.type) === -1 && (!item.label || item.label === 'page')) {
            var m = CSL.LOCATOR_LABELS_REGEXP.exec(item.locator);
            if (m) {
              var tryLabel = CSL.LOCATOR_LABELS_MAP[m[2]];
              if (this.getTerm(tryLabel)) {
                item.label = tryLabel;
                item.locator = m[3];
              }
            }
          }
        }
        if (item.locator) {
          item.locator = ("" + item.locator).replace(/\s+$/, '');
        }
        newitem = [Item, item];
        inputList.push(newitem);
      }
      this.remapSectionVariable(inputList);
      if (inputList && inputList.length > 1 && this.citation_sort.tokens.length > 0) {
        len = inputList.length;
        for (pos = 0; pos < len; pos += 1) {
          inputList[pos][1].sortkeys = CSL.getSortKeys.call(this, inputList[pos][0], "citation_sort");
        }
        inputList.sort(this.citation.srt.compareCompositeKeys);
      }
      this.tmp.citation_errors = [];
      this.parallel.StartCitation(inputList);
      str = CSL.getCitationCluster.call(this, inputList);
      return str;
    };
    CSL.getAmbiguousCite = function(Item, disambig, visualForm, item) {
      var use_parallels,
          ret;
      var flags = this.tmp.group_context.tip;
      var oldTermSiblingLayer = {
        term_intended: flags.term_intended,
        variable_attempt: flags.variable_attempt,
        variable_success: flags.variable_success,
        output_tip: flags.output_tip,
        label_form: flags.label_form,
        parallel_conditions: flags.parallel_conditions,
        condition: flags.condition,
        force_suppress: flags.force_suppress,
        done_vars: flags.done_vars.slice()
      };
      if (disambig) {
        this.tmp.disambig_request = disambig;
      } else {
        this.tmp.disambig_request = false;
      }
      var itemSupp = {
        position: 1,
        "near-note": true
      };
      if (item) {
        itemSupp.locator = item.locator;
        itemSupp.label = item.label;
      }
      if (this.registry.registry[Item.id] && this.registry.citationreg.citationsByItemId && this.registry.citationreg.citationsByItemId[Item.id] && this.registry.citationreg.citationsByItemId[Item.id].length && visualForm) {
        if (this.citation.opt["givenname-disambiguation-rule"] === "by-cite") {
          itemSupp['first-reference-note-number'] = this.registry.registry[Item.id]['first-reference-note-number'];
        }
      }
      this.tmp.area = "citation";
      this.parallel.use_parallels = (this.parallel.use_parallels === true || this.parallel.use_parallels === null) ? null : false;
      this.tmp.suppress_decorations = true;
      this.tmp.just_looking = true;
      CSL.getCite.call(this, Item, itemSupp, null, false);
      for (var i = 0,
          ilen = this.output.queue.length; i < ilen; i += 1) {
        CSL.Output.Queue.purgeEmptyBlobs(this.output.queue[i]);
      }
      if (this.opt.development_extensions.clean_up_csl_flaws) {
        for (var j = 0,
            jlen = this.output.queue.length; j < jlen; j += 1) {
          this.output.adjust.upward(this.output.queue[j]);
          this.output.adjust.leftward(this.output.queue[j]);
          this.output.adjust.downward(this.output.queue[j]);
          this.output.adjust.fix(this.output.queue[j]);
        }
      }
      ret = this.output.string(this, this.output.queue);
      this.tmp.just_looking = false;
      this.tmp.suppress_decorations = false;
      this.parallel.use_parallels = this.parallel.use_parallels === null ? true : false;
      this.tmp.group_context.replace(oldTermSiblingLayer);
      return ret;
    };
    CSL.getSpliceDelimiter = function(last_collapsed, pos) {
      if (last_collapsed && !this.tmp.have_collapsed && "string" === typeof this.citation.opt["after-collapse-delimiter"]) {
        this.tmp.splice_delimiter = this.citation.opt["after-collapse-delimiter"];
      } else if (this.tmp.use_cite_group_delimiter) {
        this.tmp.splice_delimiter = this.citation.opt.cite_group_delimiter;
      } else if (this.tmp.have_collapsed && this.opt.xclass === "in-text" && this.opt.update_mode !== CSL.NUMERIC) {
        this.tmp.splice_delimiter = ", ";
      } else if (this.tmp.cite_locales[pos - 1]) {
        var alt_affixes = this.tmp.cite_affixes[this.tmp.area][this.tmp.cite_locales[pos - 1]];
        if (alt_affixes && alt_affixes.delimiter) {
          this.tmp.splice_delimiter = alt_affixes.delimiter;
        }
      }
      return this.tmp.splice_delimiter;
    };
    CSL.getCitationCluster = function(inputList, citationID) {
      var result,
          objects,
          myparams,
          len,
          pos,
          item,
          last_collapsed,
          params,
          empties,
          composite,
          compie,
          myblobs,
          Item,
          llen,
          ppos,
          obj,
          preceding_item,
          txt_esc,
          error_object;
      inputList = inputList ? inputList : [];
      this.tmp.last_primary_names_string = false;
      txt_esc = CSL.getSafeEscape(this);
      this.tmp.area = "citation";
      result = "";
      objects = [];
      this.tmp.last_suffix_used = "";
      this.tmp.last_names_used = [];
      this.tmp.last_years_used = [];
      this.tmp.backref_index = [];
      this.tmp.cite_locales = [];
      this.output.checkNestedBrace = new CSL.checkNestedBrace(this);
      var use_layout_prefix = this.output.checkNestedBrace.update(this.citation.opt.layout_prefix);
      var suppressTrailingPunctuation = false;
      if (this.opt.xclass === "note" && this.citation.opt.suppressTrailingPunctuation) {
        suppressTrailingPunctuation = true;
      }
      if (citationID) {
        if (this.registry.citationreg.citationById[citationID].properties["suppress-trailing-punctuation"]) {
          suppressTrailingPunctuation = true;
        }
      }
      if (this.opt.xclass === "note") {
        var parasets = [];
        var lastTitle = false;
        var lastPosition = false;
        var lastID = false;
        var lst = [];
        for (var i = 0,
            ilen = inputList.length; i < ilen; i += 1) {
          var type = inputList[i][0].type;
          var title = inputList[i][0].title;
          var position = inputList[i][1].position;
          var id = inputList[i][0].id;
          if (title && type === "legal_case" && id !== lastID && position) {
            if (title !== lastTitle || parasets.length === 0) {
              lst = [];
              parasets.push(lst);
            }
            lst.push(inputList[i][1]);
          }
          lastTitle = title;
          lastPosition = position;
          lastID = id;
        }
        for (i = 0, ilen = parasets.length; i < ilen; i += 1) {
          lst = parasets[i];
          if (lst.length < 2) {
            continue;
          }
          var locatorInLastPosition = lst.slice(-1)[0].locator;
          if (locatorInLastPosition) {
            for (var j = 0,
                jlen = lst.length - 1; j < jlen; j += 1) {
              if (lst[j].locator) {
                locatorInLastPosition = false;
              }
            }
          }
          if (locatorInLastPosition) {
            lst[0].locator = locatorInLastPosition;
            delete lst.slice(-1)[0].locator;
            lst[0].label = lst.slice(-1)[0].label;
            if (lst.slice(-1)[0].label) {
              delete lst.slice(-1)[0].label;
            }
          }
        }
      }
      myparams = [];
      len = inputList.length;
      for (pos = 0; pos < len; pos += 1) {
        Item = inputList[pos][0];
        item = inputList[pos][1];
        last_collapsed = this.tmp.have_collapsed;
        params = {};
        this.tmp.shadow_numbers = {};
        if (!this.tmp.just_looking && this.opt.hasPlaceholderTerm) {
          var output = this.output;
          this.output = new CSL.Output.Queue(this);
          this.output.adjust = new CSL.Output.Queue.adjust();
          CSL.getAmbiguousCite.call(this, Item, null, false, item);
          this.output = output;
        }
        if (pos > 0) {
          CSL.getCite.call(this, Item, item, "" + inputList[(pos - 1)][0].id, true);
        } else {
          this.tmp.term_predecessor = false;
          CSL.getCite.call(this, Item, item, null, true);
        }
        if (!this.tmp.cite_renders_content) {
          error_object = {
            citationID: "" + this.tmp.citation_id,
            index: this.tmp.citation_pos,
            noteIndex: this.tmp.citation_note_index,
            itemID: "" + Item.id,
            citationItems_pos: pos,
            error_code: CSL.ERROR_NO_RENDERED_FORM
          };
          this.tmp.citation_errors.push(error_object);
        }
        if (pos === (inputList.length - 1)) {
          this.parallel.ComposeSet();
        }
        params.splice_delimiter = CSL.getSpliceDelimiter.call(this, last_collapsed, pos);
        if (item && item["author-only"]) {
          this.tmp.suppress_decorations = true;
        }
        if (pos > 0) {
          preceding_item = inputList[pos - 1][1];
          var precedingEndsInPeriodOrComma = preceding_item.suffix && [".", ","].indexOf(preceding_item.suffix.slice(-1)) > -1;
          var currentStartsWithPeriodOrComma = !preceding_item.suffix && item.prefix && [".", ","].indexOf(item.prefix.slice(0, 1)) > -1;
          if (precedingEndsInPeriodOrComma || currentStartsWithPeriodOrComma) {
            var spaceidx = params.splice_delimiter.indexOf(" ");
            if (spaceidx > -1 && !currentStartsWithPeriodOrComma) {
              params.splice_delimiter = params.splice_delimiter.slice(spaceidx);
            } else {
              params.splice_delimiter = "";
            }
          }
        }
        params.suppress_decorations = this.tmp.suppress_decorations;
        params.have_collapsed = this.tmp.have_collapsed;
        myparams.push(params);
      }
      this.tmp.has_purged_parallel = false;
      this.parallel.PruneOutputQueue(this);
      empties = 0;
      myblobs = this.output.queue.slice();
      var fakeblob = {strings: {
          suffix: this.citation.opt.layout_suffix,
          delimiter: this.citation.opt.layout_delimiter
        }};
      var suffix = this.citation.opt.layout_suffix;
      var last_locale = this.tmp.cite_locales[this.tmp.cite_locales.length - 1];
      if (last_locale && this.tmp.cite_affixes[this.tmp.area][last_locale] && this.tmp.cite_affixes[this.tmp.area][last_locale].suffix) {
        suffix = this.tmp.cite_affixes[this.tmp.area][last_locale].suffix;
      }
      if (CSL.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(suffix.slice(0, 1)) > -1) {
        suffix = suffix.slice(0, 1);
      }
      var delimiter = this.citation.opt.layout_delimiter;
      if (!delimiter) {
        delimiter = "";
      }
      if (CSL.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(delimiter.slice(0, 1)) > -1) {
        delimiter = delimiter.slice(0, 1);
      }
      suffix = this.output.checkNestedBrace.update(suffix);
      for (var i = 0,
          ilen = this.output.queue.length; i < ilen; i += 1) {
        CSL.Output.Queue.purgeEmptyBlobs(this.output.queue[i]);
      }
      if (!this.tmp.suppress_decorations && this.output.queue.length) {
        if (!(this.opt.development_extensions.apply_citation_wrapper && this.sys.wrapCitationEntry && !this.tmp.just_looking && this.tmp.area === "citation")) {
          if (!suppressTrailingPunctuation) {
            this.output.queue[this.output.queue.length - 1].strings.suffix = suffix;
          }
          this.output.queue[0].strings.prefix = use_layout_prefix;
        }
      }
      if (this.opt.development_extensions.clean_up_csl_flaws) {
        for (var j = 0,
            jlen = this.output.queue.length; j < jlen; j += 1) {
          this.output.adjust.upward(this.output.queue[j]);
          this.output.adjust.leftward(this.output.queue[j]);
          this.output.adjust.downward(this.output.queue[j]);
          this.tmp.last_chr = this.output.adjust.fix(this.output.queue[j]);
        }
      }
      for (pos = 0, len = myblobs.length; pos < len; pos += 1) {
        var buffer = [];
        this.output.queue = [myblobs[pos]];
        this.tmp.suppress_decorations = myparams[pos].suppress_decorations;
        this.tmp.splice_delimiter = myparams[pos].splice_delimiter;
        if (myblobs[pos].parallel_delimiter) {
          this.tmp.splice_delimiter = myblobs[pos].parallel_delimiter;
        }
        this.tmp.have_collapsed = myparams[pos].have_collapsed;
        composite = this.output.string(this, this.output.queue);
        this.tmp.suppress_decorations = false;
        if ("string" === typeof composite) {
          this.tmp.suppress_decorations = false;
          return composite;
        }
        if ("object" === typeof composite && composite.length === 0 && !item["suppress-author"]) {
          if (this.tmp.has_purged_parallel) {
            composite.push("");
          } else {
            var errStr = "[CSL STYLE ERROR: reference with no printed form.]";
            var preStr = pos === 0 ? txt_esc(this.citation.opt.layout_prefix) : "";
            var sufStr = pos === (myblobs.length - 1) ? txt_esc(this.citation.opt.layout_suffix) : "";
            composite.push(preStr + errStr + sufStr);
          }
        }
        if (buffer.length && "string" === typeof composite[0]) {
          composite.reverse();
          var tmpstr = composite.pop();
          if (tmpstr && tmpstr.slice(0, 1) === ",") {
            buffer.push(tmpstr);
          } else if ("string" == typeof buffer.slice(-1)[0] && buffer.slice(-1)[0].slice(-1) === ",") {
            buffer.push(" " + tmpstr);
          } else if (tmpstr) {
            buffer.push(txt_esc(this.tmp.splice_delimiter) + tmpstr);
          }
        } else {
          composite.reverse();
          compie = composite.pop();
          if ("undefined" !== typeof compie) {
            if (buffer.length && "string" === typeof buffer[buffer.length - 1]) {
              buffer[buffer.length - 1] += compie.successor_prefix;
            }
            buffer.push(compie);
          }
        }
        llen = composite.length;
        for (ppos = 0; ppos < llen; ppos += 1) {
          obj = composite[ppos];
          if ("string" === typeof obj) {
            buffer.push(txt_esc(this.tmp.splice_delimiter) + obj);
            continue;
          }
          compie = composite.pop();
          if ("undefined" !== typeof compie) {
            buffer.push(compie);
          }
        }
        if (buffer.length === 0 && !inputList[pos][1]["suppress-author"]) {
          empties += 1;
        }
        if (buffer.length > 1 && typeof buffer[0] !== "string") {
          buffer = [this.output.renderBlobs(buffer)];
        }
        if (buffer.length) {
          if ("string" === typeof buffer[0]) {
            if (pos > 0) {
              if (((myblobs.length - 1) > pos && myparams[pos + 1].have_collapsed) && !myparams[pos].have_collapsed) {
                this.tmp.splice_delimiter = myparams[pos - 1].splice_delimiter;
              }
              buffer[0] = txt_esc(this.tmp.splice_delimiter) + buffer[0];
            }
          } else {
            if (pos > 0) {
              buffer[0].splice_prefix = this.tmp.splice_delimiter;
            } else {
              buffer[0].splice_prefix = "";
            }
          }
        }
        objects = objects.concat(buffer);
      }
      result += this.output.renderBlobs(objects);
      if (result) {
        if (!this.tmp.suppress_decorations) {
          len = this.citation.opt.layout_decorations.length;
          for (pos = 0; pos < len; pos += 1) {
            params = this.citation.opt.layout_decorations[pos];
            if (params[1] === "normal") {
              continue;
            }
            if (!item || !item["author-only"]) {
              result = this.fun.decorate[params[0]][params[1]](this, result);
            }
          }
        }
      }
      this.tmp.suppress_decorations = false;
      return result;
    };
    CSL.getCite = function(Item, item, prevItemID, blockShadowNumberReset) {
      var next,
          error_object;
      this.tmp.cite_renders_content = false;
      this.parallel.StartCite(Item, item, prevItemID);
      CSL.citeStart.call(this, Item, item, blockShadowNumberReset);
      next = 0;
      this.nameOutput = new CSL.NameOutput(this, Item, item);
      while (next < this[this.tmp.area].tokens.length) {
        next = CSL.tokenExec.call(this, this[this.tmp.area].tokens[next], Item, item);
      }
      CSL.citeEnd.call(this, Item, item);
      this.parallel.CloseCite(this);
      if (!this.tmp.cite_renders_content && !this.tmp.just_looking) {
        if (this.tmp.area === "bibliography") {
          error_object = {
            index: this.tmp.bibliography_pos,
            itemID: "" + Item.id,
            error_code: CSL.ERROR_NO_RENDERED_FORM
          };
          this.tmp.bibliography_errors.push(error_object);
        }
      }
      return "" + Item.id;
    };
    CSL.citeStart = function(Item, item, blockShadowNumberReset) {
      if (!blockShadowNumberReset) {
        this.tmp.shadow_numbers = {};
      }
      this.tmp.disambiguate_count = 0;
      this.tmp.disambiguate_maxMax = 0;
      this.tmp.same_author_as_previous_cite = false;
      if (!this.tmp.suppress_decorations) {
        this.tmp.subsequent_author_substitute_ok = true;
      } else {
        this.tmp.subsequent_author_substitute_ok = false;
      }
      this.tmp.lastchr = "";
      if (this.tmp.area === "citation" && this.citation.opt.collapse && this.citation.opt.collapse.length) {
        this.tmp.have_collapsed = true;
      } else {
        this.tmp.have_collapsed = false;
      }
      this.tmp.render_seen = false;
      if (this.tmp.disambig_request && !this.tmp.disambig_override) {
        this.tmp.disambig_settings = this.tmp.disambig_request;
      } else if (this.registry.registry[Item.id] && !this.tmp.disambig_override) {
        this.tmp.disambig_request = this.registry.registry[Item.id].disambig;
        this.tmp.disambig_settings = this.registry.registry[Item.id].disambig;
      } else {
        this.tmp.disambig_settings = new CSL.AmbigConfig();
      }
      if (this.tmp.area !== 'citation' && this.registry.registry[Item.id]) {
        this.tmp.disambig_restore = CSL.cloneAmbigConfig(this.registry.registry[Item.id].disambig);
        if (this.tmp.area === 'bibliography' && this.tmp.disambig_settings && this.tmp.disambig_override) {
          if (this.opt["disambiguate-add-names"]) {
            this.tmp.disambig_settings.names = this.registry.registry[Item.id].disambig.names.slice();
            this.tmp.disambig_request.names = this.registry.registry[Item.id].disambig.names.slice();
          }
          if (this.opt["disambiguate-add-givenname"]) {
            this.tmp.disambig_request = this.tmp.disambig_settings;
            this.tmp.disambig_settings.givens = this.registry.registry[Item.id].disambig.givens.slice();
            this.tmp.disambig_request.givens = this.registry.registry[Item.id].disambig.givens.slice();
            for (var i = 0,
                ilen = this.tmp.disambig_settings.givens.length; i < ilen; i += 1) {
              this.tmp.disambig_settings.givens[i] = this.registry.registry[Item.id].disambig.givens[i].slice();
            }
            for (var i = 0,
                ilen = this.tmp.disambig_request.givens.length; i < ilen; i += 1) {
              this.tmp.disambig_request.givens[i] = this.registry.registry[Item.id].disambig.givens[i].slice();
            }
          }
        }
      }
      this.tmp.names_used = [];
      this.tmp.nameset_counter = 0;
      this.tmp.years_used = [];
      this.tmp.names_max.clear();
      this.tmp.splice_delimiter = this[this.tmp.area].opt.layout_delimiter;
      this.bibliography_sort.keys = [];
      this.citation_sort.keys = [];
      this.tmp.has_done_year_suffix = false;
      this.tmp.last_cite_locale = false;
      if (!this.tmp.just_looking && item && !item.position && this.registry.registry[Item.id]) {
        this.tmp.disambig_restore = CSL.cloneAmbigConfig(this.registry.registry[Item.id].disambig);
      }
      this.tmp.first_name_string = false;
      this.tmp.authority_stop_last = 0;
    };
    CSL.citeEnd = function(Item, item) {
      if (this.tmp.disambig_restore) {
        this.registry.registry[Item.id].disambig.names = this.tmp.disambig_restore.names.slice();
        this.registry.registry[Item.id].disambig.givens = this.tmp.disambig_restore.givens.slice();
        for (var i = 0,
            ilen = this.registry.registry[Item.id].disambig.givens.length; i < ilen; i += 1) {
          this.registry.registry[Item.id].disambig.givens[i] = this.tmp.disambig_restore.givens[i].slice();
        }
      }
      this.tmp.disambig_restore = false;
      if (item && item.suffix) {
        this.tmp.last_suffix_used = item.suffix;
      } else {
        this.tmp.last_suffix_used = "";
      }
      this.tmp.last_years_used = this.tmp.years_used.slice();
      this.tmp.last_names_used = this.tmp.names_used.slice();
      this.tmp.cut_var = false;
      this.tmp.disambig_request = false;
      this.tmp.cite_locales.push(this.tmp.last_cite_locale);
      if (this.tmp.issued_date && this.tmp.renders_collection_number) {
        var buf = [];
        for (var i = this.tmp.issued_date.list.length - 1; i > this.tmp.issued_date.pos; i += -1) {
          buf.push(this.tmp.issued_date.list.pop());
        }
        this.tmp.issued_date.list.pop();
        for (i = buf.length - 1; i > -1; i += -1) {
          this.tmp.issued_date.list.push(buf.pop());
        }
        if (this.parallel.use_parallels) {
          this.parallel.cite["issued"] = false;
        }
      }
      this.tmp.issued_date = false;
      this.tmp.renders_collection_number = false;
    };
    CSL.Engine.prototype.makeBibliography = function(bibsection) {
      var debug,
          ret,
          params,
          maxoffset,
          item,
          len,
          pos,
          tok,
          tokk,
          tokkk,
          entry_ids,
          entry_strings,
          bibliography_errors;
      debug = false;
      if (!this.bibliography.tokens.length) {
        return false;
      }
      if ("string" === typeof bibsection) {
        this.opt.citation_number_slug = bibsection;
        bibsection = false;
      }
      ret = CSL.getBibliographyEntries.call(this, bibsection);
      entry_ids = ret[0];
      entry_strings = ret[1];
      var done = ret[2];
      params = {
        "maxoffset": 0,
        "entryspacing": this.bibliography.opt["entry-spacing"],
        "linespacing": this.bibliography.opt["line-spacing"],
        "second-field-align": false,
        "entry_ids": entry_ids,
        "bibliography_errors": this.tmp.bibliography_errors.slice(),
        "done": done
      };
      if (this.bibliography.opt["second-field-align"]) {
        params["second-field-align"] = this.bibliography.opt["second-field-align"];
      }
      maxoffset = 0;
      len = this.registry.reflist.length;
      for (pos = 0; pos < len; pos += 1) {
        item = this.registry.reflist[pos];
        if (item.offset > params.maxoffset) {
          params.maxoffset = item.offset;
        }
      }
      if (this.bibliography.opt.hangingindent) {
        params.hangingindent = this.bibliography.opt.hangingindent;
      }
      params.bibstart = this.fun.decorate.bibstart;
      params.bibend = this.fun.decorate.bibend;
      this.opt.citation_number_slug = false;
      return [params, entry_strings];
    };
    CSL.getBibliographyEntries = function(bibsection) {
      var ret,
          input,
          include,
          anymatch,
          allmatch,
          bib_entry,
          res,
          len,
          pos,
          item,
          llen,
          ppos,
          spec,
          lllen,
          pppos,
          bib_layout,
          topblobs,
          all_item_ids,
          entry_item_ids,
          debug,
          collapse_parallel,
          i,
          ilen,
          siblings,
          skips,
          sortedItems,
          eyetem,
          chr,
          entry_item_data,
          j,
          jlen,
          newIDs,
          originalIDs;
      ret = [];
      entry_item_data = [];
      this.tmp.area = "bibliography";
      this.tmp.last_rendered_name = false;
      this.tmp.bibliography_errors = [];
      this.tmp.bibliography_pos = 0;
      if (bibsection && bibsection.page_start && bibsection.page_length) {
        input = this.registry.getSortedIds();
      } else {
        input = this.retrieveItems(this.registry.getSortedIds());
      }
      this.tmp.disambig_override = true;
      function eval_string(a, b) {
        if (a === b) {
          return true;
        }
        return false;
      }
      function eval_list(a, lst) {
        lllen = lst.length;
        for (pppos = 0; pppos < lllen; pppos += 1) {
          if (eval_string(a, lst[pppos])) {
            return true;
          }
        }
        return false;
      }
      function eval_spec(a, b) {
        if ((a === "none" || !a) && !b) {
          return true;
        }
        if ("string" === typeof b) {
          return eval_string(a, b);
        } else if (!b) {
          return false;
        } else {
          return eval_list(a, b);
        }
      }
      skips = {};
      var page_item_count;
      if (bibsection && bibsection.page_start && bibsection.page_length) {
        page_item_count = 0;
        if (bibsection.page_start !== true) {
          for (i = 0, ilen = input.length; i < ilen; i += 1) {
            skips[input[i]] = true;
            if (bibsection.page_start == input[i]) {
              break;
            }
          }
        }
      }
      var processed_item_ids = [];
      for (i = 0, ilen = input.length; i < ilen; i += 1) {
        if (bibsection && bibsection.page_start && bibsection.page_length) {
          if (skips[input[i]]) {
            continue;
          }
          item = this.retrieveItem(input[i]);
          if (page_item_count === bibsection.page_length) {
            break;
          }
        } else {
          item = input[i];
          if (skips[item.id]) {
            continue;
          }
        }
        if (bibsection) {
          include = true;
          if (bibsection.include) {
            include = false;
            for (j = 0, jlen = bibsection.include.length; j < jlen; j += 1) {
              spec = bibsection.include[j];
              if (eval_spec(spec.value, item[spec.field])) {
                include = true;
                break;
              }
            }
          } else if (bibsection.exclude) {
            anymatch = false;
            for (j = 0, jlen = bibsection.exclude.length; j < jlen; j += 1) {
              spec = bibsection.exclude[j];
              if (eval_spec(spec.value, item[spec.field])) {
                anymatch = true;
                break;
              }
            }
            if (anymatch) {
              include = false;
            }
          } else if (bibsection.select) {
            include = false;
            allmatch = true;
            for (j = 0, jlen = bibsection.select.length; j < jlen; j += 1) {
              spec = bibsection.select[j];
              if (!eval_spec(spec.value, item[spec.field])) {
                allmatch = false;
              }
            }
            if (allmatch) {
              include = true;
            }
          }
          if (bibsection.quash) {
            allmatch = true;
            for (j = 0, jlen = bibsection.quash.length; j < jlen; j += 1) {
              spec = bibsection.quash[j];
              if (!eval_spec(spec.value, item[spec.field])) {
                allmatch = false;
              }
            }
            if (allmatch) {
              include = false;
            }
          }
          if (!include) {
            continue;
          }
        }
        bib_entry = new CSL.Token("group", CSL.START);
        bib_entry.decorations = [["@bibliography", "entry"]].concat(this.bibliography.opt.layout_decorations);
        this.output.startTag("bib_entry", bib_entry);
        if (item.system_id && this.sys.embedBibliographyEntry) {
          this.output.current.value().item_id = item.system_id;
        } else {
          this.output.current.value().system_id = item.id;
        }
        sortedItems = [[{id: "" + item.id}, item]];
        entry_item_ids = [];
        if (this.registry.registry[item.id].master && !(bibsection && bibsection.page_start && bibsection.page_length)) {
          collapse_parallel = true;
          this.parallel.StartCitation(sortedItems);
          this.output.queue[0].strings.delimiter = ", ";
          this.tmp.term_predecessor = false;
          entry_item_ids.push("" + CSL.getCite.call(this, item));
          skips[item.id] = true;
          siblings = this.registry.registry[item.id].siblings;
          for (j = 0, jlen = siblings.length; j < jlen; j += 1) {
            var k = this.registry.registry[item.id].siblings[j];
            eyetem = this.retrieveItem(k);
            entry_item_ids.push("" + CSL.getCite.call(this, eyetem));
            skips[eyetem.id] = true;
          }
          this.parallel.ComposeSet();
          this.parallel.PruneOutputQueue();
        } else if (!this.registry.registry[item.id].siblings) {
          this.parallel.StartCitation(sortedItems);
          this.tmp.term_predecessor = false;
          entry_item_ids.push("" + CSL.getCite.call(this, item));
          if (bibsection && bibsection.page_start && bibsection.page_length) {
            page_item_count += 1;
          }
        }
        entry_item_data.push("");
        this.tmp.bibliography_pos += 1;
        processed_item_ids.push(entry_item_ids);
        this.output.endTag("bib_entry");
        if (this.output.queue[0].blobs.length && this.output.queue[0].blobs[0].blobs.length) {
          if (collapse_parallel || !this.output.queue[0].blobs[0].blobs[0].strings) {
            topblobs = this.output.queue[0].blobs;
            collapse_parallel = false;
          } else {
            topblobs = this.output.queue[0].blobs[0].blobs;
          }
          topblobs[0].strings.prefix = this.bibliography.opt.layout_prefix + topblobs[0].strings.prefix;
        }
        for (var j = 0,
            jlen = this.output.queue.length; j < jlen; j += 1) {
          CSL.Output.Queue.purgeEmptyBlobs(this.output.queue[j]);
        }
        for (var j = 0,
            jlen = this.output.queue.length; j < jlen; j += 1) {
          this.output.adjust.upward(this.output.queue[j]);
          this.output.adjust.leftward(this.output.queue[j]);
          this.output.adjust.downward(this.output.queue[j], true);
          this.output.adjust.fix(this.output.queue[j]);
        }
        res = this.output.string(this, this.output.queue)[0];
        if (!res) {
          res = "\n[CSL STYLE ERROR: reference with no printed form.]\n";
        }
        ret.push(res);
      }
      var done = false;
      if (bibsection && bibsection.page_start && bibsection.page_length) {
        var last_expected_id = input.slice(-1)[0];
        var last_seen_id = processed_item_ids.slice(-1)[0];
        if (!last_expected_id || !last_seen_id || last_expected_id == last_seen_id) {
          done = true;
        }
      }
      this.tmp.disambig_override = false;
      return [processed_item_ids, ret, done];
    };
    CSL.Engine.prototype.setCitationId = function(citation, force) {
      var ret,
          id,
          direction;
      ret = false;
      if (!citation.citationID || force) {
        id = Math.floor(Math.random() * 100000000000000);
        while (true) {
          direction = 0;
          if (!this.registry.citationreg.citationById[id]) {
            citation.citationID = id.toString(32);
            break;
          } else if (!direction && id < 50000000000000) {
            direction = 1;
          } else {
            direction = -1;
          }
          if (direction === 1) {
            id += 1;
          } else {
            id += -1;
          }
        }
        ret = "" + id;
      }
      this.registry.citationreg.citationById[citation.citationID] = citation;
      return ret;
    };
    CSL.Engine.prototype.rebuildProcessorState = function(citations, mode, uncitedItemIDs) {
      if (!citations) {
        citations = [];
      }
      if (!mode) {
        mode = 'html';
      }
      var doneIDs = {};
      var itemIDs = [];
      for (var i = 0,
          ilen = citations.length; i < ilen; i += 1) {
        for (var j = 0,
            jlen = citations[i].citationItems.length; j < jlen; j += 1) {
          var itemID = "" + citations[i].citationItems[j].id;
          if (!doneIDs[itemID]) {
            itemIDs.push(itemID);
          }
          doneIDs[itemID] = true;
        }
      }
      this.updateItems(itemIDs);
      var pre = [];
      var post = [];
      var ret = [];
      var oldMode = this.opt.mode;
      this.setOutputFormat(mode);
      for (var i = 0,
          ilen = citations.length; i < ilen; i += 1) {
        var res = this.processCitationCluster(citations[i], pre, post, CSL.ASSUME_ALL_ITEMS_REGISTERED);
        pre.push([citations[i].citationID, citations[i].properties.noteIndex]);
        for (var j = 0,
            jlen = res[1].length; j < jlen; j += 1) {
          var index = res[1][j][0];
          ret[index] = [pre[index][0], pre[index][1], res[1][j][1]];
        }
      }
      this.updateUncitedItems(uncitedItemIDs);
      this.setOutputFormat(oldMode);
      return ret;
    };
    CSL.Engine.prototype.restoreProcessorState = function(citations) {
      var i,
          ilen,
          j,
          jlen,
          item,
          Item,
          newitem,
          citationList,
          itemList,
          sortedItems;
      citationList = [];
      itemList = [];
      if (!citations) {
        citations = [];
      }
      var indexNumbers = [];
      var citationIds = {};
      for (i = 0, ilen = citations.length; i < ilen; i += 1) {
        if (citationIds[citations[i].citationID]) {
          this.setCitationId(citations[i], true);
        }
        citationIds[citations[i].citationID] = true;
        indexNumbers.push(citations[i].properties.index);
      }
      var oldCitations = citations.slice();
      oldCitations.sort(function(a, b) {
        if (a.properties.index < b.properties.index) {
          return -1;
        } else if (a.properties.index > b.properties.index) {
          return 1;
        } else {
          return 0;
        }
      });
      for (i = 0, ilen = oldCitations.length; i < ilen; i += 1) {
        oldCitations[i].properties.index = i;
      }
      for (i = 0, ilen = oldCitations.length; i < ilen; i += 1) {
        sortedItems = [];
        for (j = 0, jlen = oldCitations[i].citationItems.length; j < jlen; j += 1) {
          item = oldCitations[i].citationItems[j];
          if ("undefined" === typeof item.sortkeys) {
            item.sortkeys = [];
          }
          Item = this.retrieveItem("" + item.id);
          newitem = [Item, item];
          sortedItems.push(newitem);
          oldCitations[i].citationItems[j].item = Item;
          itemList.push("" + item.id);
        }
        if (!oldCitations[i].properties.unsorted) {
          sortedItems.sort(this.citation.srt.compareCompositeKeys);
        }
        oldCitations[i].sortedItems = sortedItems;
        this.registry.citationreg.citationById[oldCitations[i].citationID] = oldCitations[i];
      }
      this.updateItems(itemList);
      for (i = 0, ilen = citations.length; i < ilen; i += 1) {
        citationList.push(["" + citations[i].citationID, citations[i].properties.noteIndex]);
      }
      var ret = [];
      if (citations && citations.length) {
        ret = this.processCitationCluster(citations[0], [], citationList.slice(1));
      } else {
        this.registry = new CSL.Registry(this);
        this.tmp = new CSL.Engine.Tmp();
        this.disambiguate = new CSL.Disambiguation(this);
      }
      return ret;
    };
    CSL.Engine.prototype.updateItems = function(idList, nosort, rerun_ambigs) {
      var debug = false;
      var oldArea = this.tmp.area;
      this.registry.init(idList);
      if (rerun_ambigs) {
        for (var ambig in this.registry.ambigcites) {
          this.registry.ambigsTouched[ambig] = true;
        }
      }
      this.registry.dodeletes(this.registry.myhash);
      this.registry.doinserts(this.registry.mylist);
      this.registry.dorefreshes();
      this.registry.rebuildlist();
      this.registry.setsortkeys();
      this.registry.setdisambigs();
      if (!nosort) {
        this.registry.sorttokens();
      }
      this.registry.renumber();
      this.tmp.area = oldArea;
      return this.registry.getSortedIds();
    };
    CSL.Engine.prototype.updateUncitedItems = function(idList, nosort) {
      var debug = false;
      if (!idList) {
        idList = [];
      }
      if ("object" == typeof idList) {
        if ("undefined" == typeof idList.length) {
          var idHash = idList;
          idList = [];
          for (var key in idHash) {
            idList.push(key);
          }
        } else if ("number" == typeof idList.length) {
          var idHash = {};
          for (var i = 0,
              ilen = idList.length; i < ilen; i += 1) {
            idHash[idList[i]] = true;
          }
        }
      }
      this.registry.init(idList, true);
      this.registry.dopurge(idHash);
      this.registry.doinserts(this.registry.mylist);
      this.registry.dorefreshes();
      this.registry.rebuildlist();
      this.registry.setsortkeys();
      this.registry.setdisambigs();
      if (!nosort) {
        this.registry.sorttokens();
      }
      this.registry.renumber();
      return this.registry.getSortedIds();
    };
    CSL.localeResolve = function(langstr, defaultLocale) {
      var ret,
          langlst;
      if (!defaultLocale) {
        defaultLocale = "en-US";
      }
      if (!langstr) {
        langstr = defaultLocale;
      }
      ret = {};
      langlst = langstr.split(/[\-_]/);
      ret.base = CSL.LANG_BASES[langlst[0]];
      if ("undefined" === typeof ret.base) {
        CSL.debug("Warning: unknown locale " + langstr + ", setting fallback to " + defaultLocale);
        return {
          base: defaultLocale,
          best: langstr,
          bare: langlst[0]
        };
      }
      if (langlst.length === 1) {
        ret.generic = true;
      }
      if (langlst.length === 1 || langlst[1] === "x") {
        ret.best = ret.base.replace("_", "-");
      } else {
        ret.best = langlst.slice(0, 2).join("-");
      }
      ret.base = ret.base.replace("_", "-");
      ret.bare = langlst[0];
      return ret;
    };
    CSL.Engine.prototype.localeConfigure = function(langspec, beShy) {
      var localexml;
      if (this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
        langspec.best = langspec.best.toLowerCase();
        langspec.bare = langspec.bare.toLowerCase();
        langspec.base = langspec.base.toLowerCase();
      }
      if (beShy && this.locale[langspec.best]) {
        return;
      }
      localexml = CSL.setupXml(this.sys.retrieveLocale("en-US"));
      this.localeSet(localexml, "en-US", langspec.best);
      if (langspec.best !== "en-US") {
        if (langspec.base !== langspec.best) {
          localexml = CSL.setupXml(this.sys.retrieveLocale(langspec.base));
          this.localeSet(localexml, langspec.base, langspec.best);
        }
        localexml = CSL.setupXml(this.sys.retrieveLocale(langspec.best));
        this.localeSet(localexml, langspec.best, langspec.best);
      }
      this.localeSet(this.cslXml, "", langspec.best);
      this.localeSet(this.cslXml, langspec.bare, langspec.best);
      if (langspec.base !== langspec.best) {
        this.localeSet(this.cslXml, langspec.base, langspec.best);
      }
      this.localeSet(this.cslXml, langspec.best, langspec.best);
      if ("undefined" === typeof this.locale[langspec.best].terms["page-range-delimiter"]) {
        if (["fr", "pt"].indexOf(langspec.best.slice(0, 2).toLowerCase()) > -1) {
          this.locale[langspec.best].terms["page-range-delimiter"] = "-";
        } else {
          this.locale[langspec.best].terms["page-range-delimiter"] = "\u2013";
        }
      }
      if ("undefined" === typeof this.locale[langspec.best].terms["year-range-delimiter"]) {
        this.locale[langspec.best].terms["year-range-delimiter"] = "\u2013";
      }
      if ("undefined" === typeof this.locale[langspec.best].terms["citation-range-delimiter"]) {
        this.locale[langspec.best].terms["citation-range-delimiter"] = "\u2013";
      }
      if (this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
        var localeLists = ["default-locale", "locale-sort", "locale-translit", "locale-translat"];
        for (var i = 0,
            ilen = localeLists.length; i < ilen; i += 1) {
          for (var j = 0,
              jlen = this.opt[localeLists[i]].length; j < jlen; j += 1) {
            this.opt[localeLists[i]][j] = this.opt[localeLists[i]][j].toLowerCase();
          }
        }
        this.opt.lang = this.opt.lang.toLowerCase();
      }
    };
    CSL.Engine.prototype.localeSet = function(myxml, lang_in, lang_out) {
      var blob,
          locale,
          nodes,
          attributes,
          pos,
          ppos,
          term,
          form,
          termname,
          styleopts,
          attr,
          date,
          attrname,
          len,
          genderform,
          target,
          i,
          ilen;
      lang_in = lang_in.replace("_", "-");
      lang_out = lang_out.replace("_", "-");
      if (this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
        lang_in = lang_in.toLowerCase();
        lang_out = lang_out.toLowerCase();
      }
      if (!this.locale[lang_out]) {
        this.locale[lang_out] = {};
        this.locale[lang_out].terms = {};
        this.locale[lang_out].opts = {};
        this.locale[lang_out].opts["skip-words"] = CSL.SKIP_WORDS;
        if (!this.locale[lang_out].opts["leading-noise-words"]) {
          this.locale[lang_out].opts["leading-noise-words"] = [];
        }
        this.locale[lang_out].dates = {};
        this.locale[lang_out].ord = {
          '1.0.1': false,
          keys: {}
        };
        this.locale[lang_out]["noun-genders"] = {};
      }
      locale = myxml.makeXml();
      if (myxml.nodeNameIs(myxml.dataObj, 'locale')) {
        locale = myxml.dataObj;
      } else {
        nodes = myxml.getNodesByName(myxml.dataObj, "locale");
        for (pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
          blob = nodes[pos];
          if (myxml.getAttributeValue(blob, 'lang', 'xml') === lang_in) {
            locale = blob;
            break;
          }
        }
      }
      nodes = myxml.getNodesByName(locale, 'type');
      for (i = 0, ilen = myxml.numberofnodes(nodes); i < ilen; i += 1) {
        var typenode = nodes[i];
        var type = myxml.getAttributeValue(typenode, 'name');
        var gender = myxml.getAttributeValue(typenode, 'gender');
        this.opt.gender[type] = gender;
      }
      var hasCslOrdinals101 = myxml.getNodesByName(locale, 'term', 'ordinal').length;
      if (hasCslOrdinals101) {
        for (var key in this.locale[lang_out].ord.keys) {
          delete this.locale[lang_out].terms[key];
        }
        this.locale[lang_out].ord = {
          "1.0.1": false,
          keys: {}
        };
      }
      nodes = myxml.getNodesByName(locale, 'term');
      var ordinals101 = {
        "last-digit": {},
        "last-two-digits": {},
        "whole-number": {}
      };
      var ordinals101_toggle = false;
      var genderized_terms = {};
      for (pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
        term = nodes[pos];
        termname = myxml.getAttributeValue(term, 'name');
        if (termname === "sub verbo") {
          termname = "sub-verbo";
        }
        if (termname.slice(0, 7) === "ordinal") {
          var termstring = myxml.getNodeValue(term);
          if (termname === "ordinal") {
            ordinals101_toggle = true;
          } else {
            var match = myxml.getAttributeValue(term, 'match');
            var termstub = termname.slice(8);
            var genderform = myxml.getAttributeValue(term, 'gender-form');
            if (!genderform) {
              genderform = "neuter";
            }
            if (!match) {
              match = "last-two-digits";
              if (termstub.slice(0, 1) === "0") {
                match = "last-digit";
              }
            }
            if (termstub.slice(0, 1) === "0") {
              termstub = termstub.slice(1);
            }
            if (!ordinals101[match][termstub]) {
              ordinals101[match][termstub] = {};
            }
            ordinals101[match][termstub][genderform] = termname;
          }
          this.locale[lang_out].ord.keys[termname] = true;
        }
        if ("undefined" === typeof this.locale[lang_out].terms[termname]) {
          this.locale[lang_out].terms[termname] = {};
        }
        form = "long";
        genderform = false;
        if (myxml.getAttributeValue(term, 'form')) {
          form = myxml.getAttributeValue(term, 'form');
        }
        if (myxml.getAttributeValue(term, 'gender-form')) {
          genderform = myxml.getAttributeValue(term, 'gender-form');
        }
        if (myxml.getAttributeValue(term, 'gender')) {
          this.locale[lang_out]["noun-genders"][termname] = myxml.getAttributeValue(term, 'gender');
        }
        if (genderform) {
          this.locale[lang_out].terms[termname][genderform] = {};
          this.locale[lang_out].terms[termname][genderform][form] = [];
          target = this.locale[lang_out].terms[termname][genderform];
          genderized_terms[termname] = true;
        } else {
          this.locale[lang_out].terms[termname][form] = [];
          target = this.locale[lang_out].terms[termname];
        }
        if (myxml.numberofnodes(myxml.getNodesByName(term, 'multiple'))) {
          target[form][0] = myxml.getNodeValue(term, 'single');
          if (target[form][0].indexOf("%s") > -1) {
            this.opt.hasPlaceholderTerm = true;
          }
          target[form][1] = myxml.getNodeValue(term, 'multiple');
          if (target[form][1].indexOf("%s") > -1) {
            this.opt.hasPlaceholderTerm = true;
          }
        } else {
          target[form] = myxml.getNodeValue(term);
          if (target[form].indexOf("%s") > -1) {
            this.opt.hasPlaceholderTerm = true;
          }
        }
      }
      if (ordinals101_toggle) {
        for (var ikey in genderized_terms) {
          var gender_segments = {};
          var form_segments = 0;
          for (var jkey in this.locale[lang_out].terms[ikey]) {
            if (["masculine", "feminine"].indexOf(jkey) > -1) {
              gender_segments[jkey] = this.locale[lang_out].terms[ikey][jkey];
            } else {
              form_segments += 1;
            }
          }
          if (!form_segments) {
            if (gender_segments.feminine) {
              for (var jkey in gender_segments.feminine) {
                this.locale[lang_out].terms[ikey][jkey] = gender_segments.feminine[jkey];
              }
            } else if (gender_segments.masculine) {
              for (var jkey in gender_segments.masculine) {
                this.locale[lang_out].terms[ikey][jkey] = gender_segments.masculine[jkey];
              }
            }
          }
        }
        this.locale[lang_out].ord['1.0.1'] = ordinals101;
      }
      for (termname in this.locale[lang_out].terms) {
        for (i = 0, ilen = 2; i < ilen; i += 1) {
          genderform = CSL.GENDERS[i];
          if (this.locale[lang_out].terms[termname][genderform]) {
            for (form in this.locale[lang_out].terms[termname]) {
              if (!this.locale[lang_out].terms[termname][genderform][form]) {
                this.locale[lang_out].terms[termname][genderform][form] = this.locale[lang_out].terms[termname][form];
              }
            }
          }
        }
      }
      nodes = myxml.getNodesByName(locale, 'style-options');
      for (pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
        if (true) {
          styleopts = nodes[pos];
          attributes = myxml.attributes(styleopts);
          for (attrname in attributes) {
            if (attributes.hasOwnProperty(attrname)) {
              if (attrname === "@punctuation-in-quote" || attrname === "@limit-day-ordinals-to-day-1") {
                if (attributes[attrname] === "true") {
                  this.locale[lang_out].opts[attrname.slice(1)] = true;
                } else {
                  this.locale[lang_out].opts[attrname.slice(1)] = false;
                }
              } else if (attrname === "@jurisdiction-preference") {
                var jurisdiction_preference = attributes[attrname].split(/\s*,\s*/);
                this.locale[lang_out].opts[attrname.slice(1)] = jurisdiction_preference;
              } else if (attrname === "@skip-words") {
                var skip_words = attributes[attrname].split(/\s*,\s*/);
                this.locale[lang_out].opts[attrname.slice(1)] = skip_words;
              } else if (attrname === "@leading-noise-words") {
                var val = attributes[attrname].split(/\s*,\s*/);
                this.locale[lang_out].opts["leading-noise-words"] = val;
              } else if (attrname === "@name-as-sort-order") {
                this.locale[lang_out].opts["name-as-sort-order"] = {};
                var lst = attributes[attrname].split(/\s+/);
                for (var i = 0,
                    ilen = lst.length; i < ilen; i += 1) {
                  this.locale[lang_out].opts["name-as-sort-order"][lst[i]] = true;
                }
              } else if (attrname === "@name-as-reverse-order") {
                this.locale[lang_out].opts["name-as-reverse-order"] = {};
                var lst = attributes[attrname].split(/\s+/);
                for (var i = 0,
                    ilen = lst.length; i < ilen; i += 1) {
                  this.locale[lang_out].opts["name-as-reverse-order"][lst[i]] = true;
                }
              } else if (attrname === "@name-never-short") {
                this.locale[lang_out].opts["name-never-short"] = {};
                var lst = attributes[attrname].split(/\s+/);
                for (var i = 0,
                    ilen = lst.length; i < ilen; i += 1) {
                  this.locale[lang_out].opts["name-never-short"][lst[i]] = true;
                }
              }
            }
          }
        }
      }
      nodes = myxml.getNodesByName(locale, 'date');
      for (pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
        if (true) {
          date = nodes[pos];
          this.locale[lang_out].dates[myxml.getAttributeValue(date, "form")] = date;
        }
      }
    };
    CSL.Node = {};
    CSL.Node.bibliography = {build: function(state, target) {
        if (this.tokentype === CSL.START) {
          state.build.area = "bibliography";
          state.build.root = "bibliography";
          state.fixOpt(this, "names-delimiter", "delimiter");
          state.fixOpt(this, "name-delimiter", "delimiter");
          state.fixOpt(this, "name-form", "form");
          state.fixOpt(this, "and", "and");
          state.fixOpt(this, "delimiter-precedes-last", "delimiter-precedes-last");
          state.fixOpt(this, "delimiter-precedes-et-al", "delimiter-precedes-et-al");
          state.fixOpt(this, "initialize-with", "initialize-with");
          state.fixOpt(this, "initialize", "initialize");
          state.fixOpt(this, "name-as-sort-order", "name-as-sort-order");
          state.fixOpt(this, "sort-separator", "sort-separator");
          state.fixOpt(this, "and", "and");
          state.fixOpt(this, "et-al-min", "et-al-min");
          state.fixOpt(this, "et-al-use-first", "et-al-use-first");
          state.fixOpt(this, "et-al-use-last", "et-al-use-last");
          state.fixOpt(this, "et-al-subsequent-min", "et-al-subsequent-min");
          state.fixOpt(this, "et-al-subsequent-use-first", "et-al-subsequent-use-first");
        }
        target.push(this);
      }};
    CSL.Node.choose = {
      build: function(state, target) {
        var func;
        if (this.tokentype === CSL.START) {
          func = function(state, Item) {
            state.tmp.jump.push(undefined, CSL.LITERAL);
          };
        }
        if (this.tokentype === CSL.END) {
          func = function(state, Item) {
            state.tmp.jump.pop();
          };
        }
        this.execs.push(func);
        target.push(this);
      },
      configure: function(state, pos) {
        if (this.tokentype === CSL.END) {
          state.configure.fail.push((pos));
          state.configure.succeed.push((pos));
        } else {
          state.configure.fail.pop();
          state.configure.succeed.pop();
        }
      }
    };
    CSL.Node.citation = {build: function(state, target) {
        if (this.tokentype === CSL.START) {
          state.fixOpt(this, "names-delimiter", "delimiter");
          state.fixOpt(this, "name-delimiter", "delimiter");
          state.fixOpt(this, "name-form", "form");
          state.fixOpt(this, "and", "and");
          state.fixOpt(this, "delimiter-precedes-last", "delimiter-precedes-last");
          state.fixOpt(this, "delimiter-precedes-et-al", "delimiter-precedes-et-al");
          state.fixOpt(this, "initialize-with", "initialize-with");
          state.fixOpt(this, "initialize", "initialize");
          state.fixOpt(this, "name-as-sort-order", "name-as-sort-order");
          state.fixOpt(this, "sort-separator", "sort-separator");
          state.fixOpt(this, "and", "and");
          state.fixOpt(this, "et-al-min", "et-al-min");
          state.fixOpt(this, "et-al-use-first", "et-al-use-first");
          state.fixOpt(this, "et-al-use-last", "et-al-use-last");
          state.fixOpt(this, "et-al-subsequent-min", "et-al-subsequent-min");
          state.fixOpt(this, "et-al-subsequent-use-first", "et-al-subsequent-use-first");
          state.build.area = "citation";
        }
        if (this.tokentype === CSL.END) {
          state.opt.grouped_sort = state.opt.xclass === "in-text" && (state.citation.opt.collapse && state.citation.opt.collapse.length) || (state.citation.opt.cite_group_delimiter && state.citation.opt.cite_group_delimiter.length) && state.opt.update_mode !== CSL.POSITION && state.opt.update_mode !== CSL.NUMERIC;
          if (state.opt.grouped_sort && state.citation_sort.opt.sort_directions.length) {
            var firstkey = state.citation_sort.opt.sort_directions[0].slice();
            state.citation_sort.opt.sort_directions = [firstkey].concat(state.citation_sort.opt.sort_directions);
          }
          state.citation.srt = new CSL.Registry.Comparifier(state, "citation_sort");
        }
      }};
    CSL.Node["#comment"] = {build: function(state, target) {}};
    CSL.Node.date = {build: function(state, target) {
        var func,
            date_obj,
            tok,
            len,
            pos,
            part,
            dpx,
            parts,
            mypos,
            start,
            end;
        if (this.tokentype === CSL.START || this.tokentype === CSL.SINGLETON) {
          state.build.date_parts = [];
          state.build.date_variables = this.variables;
          if (!state.build.extension) {
            CSL.Util.substituteStart.call(this, state, target);
          }
          if (state.build.extension) {
            func = CSL.dateMacroAsSortKey;
          } else {
            func = function(state, Item, item) {
              var key,
                  dp;
              state.tmp.element_rendered_ok = false;
              state.tmp.donesies = [];
              state.tmp.dateparts = [];
              dp = [];
              if (this.variables.length && !(state.tmp.just_looking && this.variables[0] === "accessed")) {
                date_obj = Item[this.variables[0]];
                if ("undefined" === typeof date_obj) {
                  date_obj = {"date-parts": [[0]]};
                  if (state.opt.development_extensions.locator_date_and_revision) {
                    if (item && this.variables[0] === "locator-date" && item["locator-date"]) {
                      date_obj = item["locator-date"];
                    }
                  }
                }
                state.tmp.date_object = date_obj;
                len = this.dateparts.length;
                for (pos = 0; pos < len; pos += 1) {
                  part = this.dateparts[pos];
                  if ("undefined" !== typeof state.tmp.date_object[(part + "_end")]) {
                    dp.push(part);
                  } else if (part === "month" && "undefined" !== typeof state.tmp.date_object.season_end) {
                    dp.push(part);
                  }
                }
                dpx = [];
                parts = ["year", "month", "day"];
                len = parts.length;
                for (pos = 0; pos < len; pos += 1) {
                  if (dp.indexOf(parts[pos]) > -1) {
                    dpx.push(parts[pos]);
                  }
                }
                dp = dpx.slice();
                mypos = 2;
                len = dp.length;
                for (pos = 0; pos < len; pos += 1) {
                  part = dp[pos];
                  start = state.tmp.date_object[part];
                  end = state.tmp.date_object[(part + "_end")];
                  if (start !== end) {
                    mypos = pos;
                    break;
                  }
                }
                state.tmp.date_collapse_at = dp.slice(mypos);
              } else {
                state.tmp.date_object = false;
              }
            };
          }
          this.execs.push(func);
          func = function(state, Item) {
            if (!Item[this.variables[0]])
              return;
            state.parallel.StartVariable(this.variables[0]);
            state.output.startTag("date", this);
            if (this.variables[0] === "issued" && Item.type === "legal_case" && !state.tmp.extension && "" + Item["collection-number"] === "" + state.tmp.date_object.year && this.dateparts.length === 1 && this.dateparts[0] === "year") {
              for (var key in state.tmp.date_object) {
                if (state.tmp.date_object.hasOwnProperty(key)) {
                  if (key.slice(0, 4) === "year") {
                    state.tmp.issued_date = {};
                    var lst = state.output.current.mystack.slice(-2)[0].blobs;
                    state.tmp.issued_date.list = lst;
                    state.tmp.issued_date.pos = lst.length - 1;
                  }
                }
              }
            }
          };
          this.execs.push(func);
        }
        if (!state.build.extension && (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON)) {
          func = function(state, Item) {
            if (!Item[this.variables[0]])
              return;
            state.output.endTag();
            state.parallel.CloseVariable(this.variables[0]);
          };
          this.execs.push(func);
        }
        target.push(this);
        if (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON) {
          if (!state.build.extension) {
            CSL.Util.substituteEnd.call(this, state, target);
          }
        }
      }};
    CSL.Node["date-part"] = {build: function(state, target) {
        var func,
            pos,
            len,
            decor,
            first_date,
            value,
            value_end,
            real,
            have_collapsed,
            invoked,
            precondition,
            known_year,
            bc,
            ad,
            bc_end,
            ad_end,
            ready,
            curr,
            dcurr,
            number,
            num,
            formatter,
            item,
            i,
            ilen;
        if (!this.strings.form) {
          this.strings.form = "long";
        }
        state.build.date_parts.push(this.strings.name);
        var date_variable = state.build.date_variables[0];
        func = function(state, Item) {
          if (!state.tmp.date_object) {
            return;
          }
          first_date = true;
          value = "";
          value_end = "";
          state.tmp.donesies.push(this.strings.name);
          if (state.tmp.date_object.literal && "year" === this.strings.name) {
            state.parallel.AppendToVariable(state.tmp.date_object.literal);
            state.output.append(state.tmp.date_object.literal, this);
          }
          if (state.tmp.date_object) {
            value = state.tmp.date_object[this.strings.name];
            value_end = state.tmp.date_object[(this.strings.name + "_end")];
          }
          if ("year" === this.strings.name && value === 0 && !state.tmp.suppress_decorations) {
            value = false;
          }
          real = !state.tmp.suppress_decorations;
          have_collapsed = state.tmp.have_collapsed;
          invoked = state[state.tmp.area].opt.collapse === "year-suffix" || state[state.tmp.area].opt.collapse === "year-suffix-ranged";
          precondition = state.opt["disambiguate-add-year-suffix"];
          if (real && precondition && invoked) {
            state.tmp.years_used.push(value);
            known_year = state.tmp.last_years_used.length >= state.tmp.years_used.length;
            if (known_year && have_collapsed) {
              if (state.tmp.last_years_used[(state.tmp.years_used.length - 1)] === value) {
                value = false;
              }
            }
          }
          if ("undefined" !== typeof value) {
            bc = false;
            ad = false;
            bc_end = false;
            ad_end = false;
            if ("year" === this.strings.name) {
              if (parseInt(value, 10) < 500 && parseInt(value, 10) > 0) {
                ad = state.getTerm("ad");
              }
              if (parseInt(value, 10) < 0) {
                bc = state.getTerm("bc");
                value = (parseInt(value, 10) * -1);
              }
              if (value_end) {
                if (parseInt(value_end, 10) < 500 && parseInt(value_end, 10) > 0) {
                  ad_end = state.getTerm("ad");
                }
                if (parseInt(value_end, 10) < 0) {
                  bc_end = state.getTerm("bc");
                  value_end = (parseInt(value_end, 10) * -1);
                }
              }
            }
            state.parallel.AppendToVariable(value);
            var monthnameid = "" + state.tmp.date_object.month;
            while (monthnameid.length < 2) {
              monthnameid = "0" + monthnameid;
            }
            monthnameid = "month-" + monthnameid;
            var gender = state.locale[state.opt.lang]["noun-genders"][monthnameid];
            if (this.strings.form) {
              var myform = this.strings.form;
              if (this.strings.name === "day") {
                if (myform === "ordinal" && state.locale[state.opt.lang].opts["limit-day-ordinals-to-day-1"] && ("" + value) !== "1") {
                  myform = "numeric";
                }
              }
              value = CSL.Util.Dates[this.strings.name][myform](state, value, gender, ("accessed" === date_variable));
              if ("month" === this.strings.name) {
                if (state.tmp.strip_periods) {
                  value = value.replace(/\./g, "");
                } else {
                  for (i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
                    if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                      value = value.replace(/\./g, "");
                      break;
                    }
                  }
                }
              }
              if (value_end) {
                value_end = CSL.Util.Dates[this.strings.name][myform](state, value_end, gender, ("accessed" === date_variable), "_end");
                if (state.tmp.strip_periods) {
                  value_end = value_end.replace(/\./g, "");
                } else {
                  for (i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
                    if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                      value_end = value_end.replace(/\./g, "");
                      break;
                    }
                  }
                }
              }
            }
            state.output.openLevel("empty");
            if (state.tmp.date_collapse_at.length) {
              ready = true;
              len = state.tmp.date_collapse_at.length;
              for (pos = 0; pos < len; pos += 1) {
                item = state.tmp.date_collapse_at[pos];
                if (state.tmp.donesies.indexOf(item) === -1) {
                  ready = false;
                  break;
                }
              }
              if (ready) {
                if ("" + value_end !== "0") {
                  if (state.dateput.queue.length === 0) {
                    first_date = true;
                  }
                  if (state.opt["year-range-format"] && state.opt["year-range-format"] !== "expanded" && !state.tmp.date_object.day && !state.tmp.date_object.month && !state.tmp.date_object.season && this.strings.name === "year" && value && value_end) {
                    value_end = state.fun.year_mangler(value + "-" + value_end, true);
                    var range_delimiter = state.getTerm("year-range-delimiter");
                    value_end = value_end.slice(value_end.indexOf(range_delimiter) + 1);
                  }
                  state.dateput.append(value_end, this);
                  if (first_date) {
                    state.dateput.current.value()[0].strings.prefix = "";
                  }
                }
                state.output.append(value, this);
                curr = state.output.current.value();
                curr.blobs[(curr.blobs.length - 1)].strings.suffix = "";
                state.output.append(state.getTerm("year-range-delimiter"), "empty");
                dcurr = state.dateput.current.value();
                curr.blobs = curr.blobs.concat(dcurr);
                state.dateput.string(state, state.dateput.queue);
                state.tmp.date_collapse_at = [];
              } else {
                state.output.append(value, this);
                if (state.tmp.date_collapse_at.indexOf(this.strings.name) > -1) {
                  if ("" + value_end !== "0") {
                    if (state.dateput.queue.length === 0) {
                      first_date = true;
                    }
                    state.dateput.openLevel("empty");
                    state.dateput.append(value_end, this);
                    if (first_date) {
                      state.dateput.current.value().blobs[0].strings.prefix = "";
                    }
                    if (bc) {
                      state.dateput.append(bc);
                    }
                    if (ad) {
                      state.dateput.append(ad);
                    }
                    state.dateput.closeLevel();
                  }
                }
              }
            } else {
              state.output.append(value, this);
            }
            if (bc) {
              state.output.append(bc);
            }
            if (ad) {
              state.output.append(ad);
            }
            state.output.closeLevel();
          } else if ("month" === this.strings.name) {
            if (state.tmp.date_object.season) {
              value = "" + state.tmp.date_object.season;
              if (value && value.match(/^[1-4]$/)) {
                state.tmp.group_context.tip.variable_success = true;
                state.output.append(state.getTerm(("season-0" + value)), this);
              } else if (value) {
                state.output.append(value, this);
              }
            }
          }
          state.tmp.value = [];
          if (Item[date_variable] && (value || state.tmp.have_collapsed) && !state.opt.has_year_suffix && "year" === this.strings.name && !state.tmp.just_looking) {
            if (state.registry.registry[Item.id] && state.registry.registry[Item.id].disambig.year_suffix !== false && !state.tmp.has_done_year_suffix) {
              state.tmp.has_done_year_suffix = true;
              num = parseInt(state.registry.registry[Item.id].disambig.year_suffix, 10);
              number = new CSL.NumericBlob(false, num, this, Item.id);
              this.successor_prefix = state[state.build.area].opt.layout_delimiter;
              this.splice_prefix = state[state.build.area].opt.layout_delimiter;
              formatter = new CSL.Util.Suffixator(CSL.SUFFIX_CHARS);
              number.setFormatter(formatter);
              if (state[state.tmp.area].opt.collapse === "year-suffix-ranged") {
                number.range_prefix = state.getTerm("citation-range-delimiter");
              }
              if (state[state.tmp.area].opt.cite_group_delimiter) {
                number.successor_prefix = state[state.tmp.area].opt.cite_group_delimiter;
              } else if (state[state.tmp.area].opt["year-suffix-delimiter"]) {
                number.successor_prefix = state[state.tmp.area].opt["year-suffix-delimiter"];
              } else {
                number.successor_prefix = state[state.tmp.area].opt.layout_delimiter;
              }
              number.UGLY_DELIMITER_SUPPRESS_HACK = true;
              state.output.append(number, "literal");
            }
          }
        };
        this.execs.push(func);
        target.push(this);
      }};
    CSL.Node["else-if"] = {
      build: function(state, target) {
        CSL.Conditions.TopNode.call(this, state, target);
        target.push(this);
      },
      configure: function(state, pos) {
        CSL.Conditions.Configure.call(this, state, pos);
      }
    };
    CSL.Node["else"] = {
      build: function(state, target) {
        target.push(this);
      },
      configure: function(state, pos) {
        if (this.tokentype === CSL.START) {
          state.configure.fail[(state.configure.fail.length - 1)] = pos;
        }
      }
    };
    CSL.Node["et-al"] = {build: function(state, target) {
        if (state.build.area === "citation" || state.build.area === "bibliography") {
          var func = function(state, Item, item) {
            state.tmp.etal_node = this;
            if ("string" === typeof this.strings.term) {
              state.tmp.etal_term = this.strings.term;
            }
          };
          this.execs.push(func);
        }
        target.push(this);
      }};
    CSL.Node.group = {build: function(state, target, realGroup) {
        var func,
            execs;
        this.realGroup = realGroup;
        if (this.tokentype === CSL.START) {
          CSL.Util.substituteStart.call(this, state, target);
          if (state.build.substitute_level.value()) {
            state.build.substitute_level.replace((state.build.substitute_level.value() + 1));
          }
          if (!this.juris) {
            target.push(this);
          }
          func = function(state, Item) {
            state.output.startTag("group", this);
            if (this.strings.label_form_override) {
              if (!state.tmp.group_context.tip.label_form) {
                state.tmp.group_context.tip.label_form = this.strings.label_form_override;
              }
            }
            if (this.realGroup) {
              var condition = false;
              var force_suppress = false;
              if (state.tmp.group_context.mystack.length) {
                state.output.current.value().parent = state.tmp.group_context.tip.output_tip;
              }
              var label_form = state.tmp.group_context.tip.label_form;
              if (!label_form) {
                label_form = this.strings.label_form_override;
              }
              if (state.tmp.group_context.tip.condition) {
                condition = state.tmp.group_context.tip.condition;
                force_suppress = state.tmp.group_context.tip.force_suppress;
              } else if (this.strings.reject) {
                condition = {
                  test: this.strings.reject,
                  not: true
                };
                force_suppress = true;
                done_vars = [];
              } else if (this.strings.require) {
                condition = {
                  test: this.strings.require,
                  not: false
                };
                done_vars = [];
              }
              state.tmp.group_context.push({
                term_intended: false,
                variable_attempt: false,
                variable_success: false,
                variable_success_parent: state.tmp.group_context.tip.variable_success,
                output_tip: state.output.current.tip,
                label_form: label_form,
                parallel_conditions: this.strings.set_parallel_condition,
                condition: condition,
                force_suppress: force_suppress,
                done_vars: state.tmp.group_context.tip.done_vars.slice()
              });
            }
          };
          execs = [];
          execs.push(func);
          this.execs = execs.concat(this.execs);
          if (this.strings["has-publisher-and-publisher-place"]) {
            state.build["publisher-special"] = true;
            func = function(state, Item) {
              if (this.strings["subgroup-delimiter"] && Item.publisher && Item["publisher-place"]) {
                var publisher_lst = Item.publisher.split(/;\s*/);
                var publisher_place_lst = Item["publisher-place"].split(/;\s*/);
                if (publisher_lst.length > 1 && publisher_lst.length === publisher_place_lst.length) {
                  state.publisherOutput = new CSL.PublisherOutput(state, this);
                  state.publisherOutput["publisher-list"] = publisher_lst;
                  state.publisherOutput["publisher-place-list"] = publisher_place_lst;
                }
              }
            };
            this.execs.push(func);
          }
          if (this.juris) {
            for (var x = 0,
                xlen = target.length; x < xlen; x++) {
              var token = target[x];
            }
            var choose_start = new CSL.Token("choose", CSL.START);
            CSL.Node.choose.build.call(choose_start, state, target);
            var if_start = new CSL.Token("if", CSL.START);
            func = function(macroName) {
              return function(Item) {
                if (!state.sys.retrieveStyleModule || !CSL.MODULE_MACROS[macroName] || !Item.jurisdiction)
                  return false;
                var jurisdictionList = state.getJurisdictionList(Item.jurisdiction);
                if (!state.opt.jurisdictions_seen[jurisdictionList[0]]) {
                  var res = state.retrieveAllStyleModules(jurisdictionList);
                  for (var jurisdiction in res) {
                    var macroCount = 0;
                    state.juris[jurisdiction] = {};
                    var myXml = CSL.setupXml(res[jurisdiction]);
                    var myNodes = myXml.getNodesByName(myXml.dataObj, "law-module");
                    for (var i = 0,
                        ilen = myNodes.length; i < ilen; i++) {
                      var myTypes = myXml.getAttributeValue(myNodes[i], "types");
                      if (myTypes) {
                        state.juris[jurisdiction].types = {};
                        myTypes = myTypes.split(/\s+/);
                        for (var j = 0,
                            jlen = myTypes.length; j < jlen; j++) {
                          state.juris[jurisdiction].types[myTypes[j]] = true;
                        }
                      }
                    }
                    if (!state.juris[jurisdiction].types) {
                      state.juris[jurisdiction].types = CSL.MODULE_TYPES;
                    }
                    var myNodes = myXml.getNodesByName(myXml.dataObj, "macro");
                    for (var i = 0,
                        ilen = myNodes.length; i < ilen; i++) {
                      var myName = myXml.getAttributeValue(myNodes[i], "name");
                      if (!CSL.MODULE_MACROS[myName]) {
                        CSL.debug("CSL: skipping non-modular macro name \"" + myName + "\" in module context");
                        continue;
                      }
                      ;
                      macroCount++;
                      state.juris[jurisdiction][myName] = [];
                      state.buildTokenLists(myNodes[i], state.juris[jurisdiction][myName]);
                      state.configureTokenList(state.juris[jurisdiction][myName]);
                    }
                    if (macroCount < Object.keys(state.juris[jurisdiction].types).length) {
                      throw "CSL ERROR: Incomplete jurisdiction style module for: " + jurisdiction;
                    }
                  }
                }
                for (var i = 0,
                    ilen = jurisdictionList.length; i < ilen; i++) {
                  var jurisdiction = jurisdictionList[i];
                  if (state.juris[jurisdiction] && state.juris[jurisdiction].types[Item.type]) {
                    Item["best-jurisdiction"] = jurisdiction;
                    return true;
                  }
                }
                return false;
              };
            }(this.juris);
            if_start.tests.push(func);
            if_start.test = state.fun.match.any(if_start, state, if_start.tests);
            target.push(if_start);
            var text_node = new CSL.Token("text", CSL.SINGLETON);
            func = function(state, Item, item) {
              var next = 0;
              if (state.juris[Item["best-jurisdiction"]][this.juris]) {
                while (next < state.juris[Item["best-jurisdiction"]][this.juris].length) {
                  next = CSL.tokenExec.call(state, state.juris[Item["best-jurisdiction"]][this.juris][next], Item, item);
                }
              }
            };
            text_node.juris = this.juris;
            text_node.execs.push(func);
            target.push(text_node);
            var if_end = new CSL.Token("if", CSL.END);
            CSL.Node.if.build.call(if_end, state, target);
            var else_start = new CSL.Token("else", CSL.START);
            CSL.Node.else.build.call(else_start, state, target);
          }
        }
        if (this.tokentype === CSL.END) {
          if (state.build["publisher-special"]) {
            state.build["publisher-special"] = false;
            if ("string" === typeof state[state.build.root].opt["name-delimiter"]) {
              func = function(state, Item) {
                if (state.publisherOutput) {
                  state.publisherOutput.render();
                  state.publisherOutput = false;
                }
              };
              this.execs.push(func);
            }
          }
          func = function(state, Item) {
            state.output.endTag();
            if (this.realGroup) {
              var flags = state.tmp.group_context.pop();
              if (state.tmp.group_context.tip.condition) {
                state.tmp.group_context.tip.force_suppress = flags.force_suppress;
              }
              if (!flags.force_suppress && (flags.variable_success || (flags.term_intended && !flags.variable_attempt))) {
                if (!this.isJurisLocatorLabel) {
                  state.tmp.group_context.tip.variable_success = true;
                }
                var blobs = state.output.current.value().blobs;
                var pos = state.output.current.value().blobs.length - 1;
                if (!state.tmp.just_looking && "undefined" !== typeof flags.parallel_conditions) {
                  var parallel_condition_object = {
                    blobs: blobs,
                    conditions: flags.parallel_conditions,
                    id: Item.id,
                    pos: pos
                  };
                  state.parallel.parallel_conditional_blobs_list.push(parallel_condition_object);
                }
              } else {
                state.tmp.group_context.tip.variable_attempt = flags.variable_attempt;
                if (flags.force_suppress && !state.tmp.group_context.tip.condition) {
                  state.tmp.group_context.tip.variable_attempt = true;
                  state.tmp.group_context.tip.variable_success = flags.variable_success_parent;
                  for (var i = 0,
                      ilen = flags.done_vars.length; i < ilen; i++) {
                    if (state.tmp.done_vars.indexOf(flags.done_vars[i]) > -1) {
                      state.tmp.done_vars = state.tmp.done_vars.slice(0, i).concat(state.tmp.done_vars.slice(i + 1));
                    }
                  }
                }
                if (state.output.current.value().blobs) {
                  state.output.current.value().blobs.pop();
                }
              }
            }
          };
          this.execs.push(func);
          if (this.juris) {
            var else_end = new CSL.Token("else", CSL.END);
            CSL.Node.else.build.call(else_end, state, target);
            var choose_end = new CSL.Token("choose", CSL.END);
            CSL.Node.choose.build.call(choose_end, state, target);
          }
        }
        if (this.tokentype === CSL.END) {
          if (!this.juris) {
            target.push(this);
          }
          if (state.build.substitute_level.value()) {
            state.build.substitute_level.replace((state.build.substitute_level.value() - 1));
          }
          CSL.Util.substituteEnd.call(this, state, target);
        }
      }};
    CSL.Node["if"] = {
      build: function(state, target) {
        CSL.Conditions.TopNode.call(this, state, target);
        target.push(this);
      },
      configure: function(state, pos) {
        CSL.Conditions.Configure.call(this, state, pos);
      }
    };
    CSL.Node["conditions"] = {build: function(state, target) {
        if (this.tokentype === CSL.START) {
          state.tmp.conditions.addMatch(this.match);
        }
        if (this.tokentype === CSL.END) {
          state.tmp.conditions.matchCombine();
        }
      }};
    CSL.Node["condition"] = {build: function(state, target) {
        if (this.tokentype === CSL.SINGLETON) {
          var test = state.fun.match[this.match](this, state, this.tests);
          state.tmp.conditions.addTest(test);
        }
      }};
    CSL.Conditions = {};
    CSL.Conditions.TopNode = function(state, target) {
      var func;
      if (this.tokentype === CSL.START || this.tokentype === CSL.SINGLETON) {
        if (this.locale) {
          state.opt.lang = this.locale;
        }
        if (!this.tests || !this.tests.length) {
          state.tmp.conditions = new CSL.Conditions.Engine(state, this);
        } else {
          this.test = state.fun.match[this.match](this, state, this.tests);
        }
      }
      if (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON) {
        func = function(state, Item) {
          if (this.locale_default) {
            state.output.current.value().old_locale = this.locale_default;
            state.output.closeLevel("empty");
            state.opt.lang = this.locale_default;
          }
          var next = this[state.tmp.jump.value()];
          return next;
        };
        this.execs.push(func);
        if (this.locale_default) {
          state.opt.lang = this.locale_default;
        }
      }
    };
    CSL.Conditions.Configure = function(state, pos) {
      if (this.tokentype === CSL.START) {
        this.fail = state.configure.fail.slice(-1)[0];
        this.succeed = this.next;
        state.configure.fail[(state.configure.fail.length - 1)] = pos;
      } else if (this.tokentype === CSL.SINGLETON) {
        this.fail = this.next;
        this.succeed = state.configure.succeed.slice(-1)[0];
        state.configure.fail[(state.configure.fail.length - 1)] = pos;
      } else {
        this.succeed = state.configure.succeed.slice(-1)[0];
        this.fail = this.next;
      }
    };
    CSL.Conditions.Engine = function(state, token) {
      this.token = token;
      this.state = state;
    };
    CSL.Conditions.Engine.prototype.addTest = function(test) {
      this.token.tests.push(test);
    };
    CSL.Conditions.Engine.prototype.addMatch = function(match) {
      this.token.match = match;
    };
    CSL.Conditions.Engine.prototype.matchCombine = function() {
      this.token.test = this.state.fun.match[this.token.match](this.token, this.state, this.token.tests);
    };
    CSL.Node.info = {build: function(state, target) {
        if (this.tokentype === CSL.START) {
          state.build.skip = "info";
        } else {
          state.build.skip = false;
        }
      }};
    CSL.Node.institution = {
      build: function(state, target) {
        if ([CSL.SINGLETON, CSL.START].indexOf(this.tokentype) > -1) {
          var func = function(state, Item) {
            if ("string" === typeof state.build.name_delimiter && !this.strings.delimiter) {
              this.strings.delimiter = state.tmp.name_delimiter;
            }
            var myand,
                and_default_prefix,
                and_suffix;
            if ("text" === this.strings.and) {
              this.and_term = state.getTerm("and", "long", 0);
            } else if ("symbol" === this.strings.and) {
              if (state.opt.development_extensions.expect_and_symbol_form) {
                this.and_term = state.getTerm("and", "symbol", 0);
              } else {
                this.and_term = "&";
              }
            } else if ("none" === this.strings.and) {
              this.and_term = this.strings.delimiter;
            }
            if ("undefined" === typeof this.and_term && state.tmp.and_term) {
              this.and_term = state.getTerm("and", "long", 0);
            }
            if (CSL.STARTSWITH_ROMANESQUE_REGEXP.test(this.and_term)) {
              this.and_prefix_single = " ";
              this.and_prefix_multiple = ", ";
              if ("string" === typeof this.strings.delimiter) {
                this.and_prefix_multiple = this.strings.delimiter;
              }
              this.and_suffix = " ";
            } else {
              this.and_prefix_single = "";
              this.and_prefix_multiple = "";
              this.and_suffix = "";
            }
            if (this.strings["delimiter-precedes-last"] === "always") {
              this.and_prefix_single = this.strings.delimiter;
            } else if (this.strings["delimiter-precedes-last"] === "never") {
              if (this.and_prefix_multiple) {
                this.and_prefix_multiple = " ";
              }
            }
            this.and = {};
            if ("undefined" !== typeof this.and_term) {
              state.output.append(this.and_term, "empty", true);
              this.and.single = state.output.pop();
              this.and.single.strings.prefix = this.and_prefix_single;
              this.and.single.strings.suffix = this.and_suffix;
              state.output.append(this.and_term, "empty", true);
              this.and.multiple = state.output.pop();
              this.and.multiple.strings.prefix = this.and_prefix_multiple;
              this.and.multiple.strings.suffix = this.and_suffix;
            } else if ("undefined" !== this.strings.delimiter) {
              this.and.single = new CSL.Blob(this.strings.delimiter);
              this.and.single.strings.prefix = "";
              this.and.single.strings.suffix = "";
              this.and.multiple = new CSL.Blob(this.strings.delimiter);
              this.and.multiple.strings.prefix = "";
              this.and.multiple.strings.suffix = "";
            }
            state.nameOutput.institution = this;
          };
          this.execs.push(func);
        }
        target.push(this);
      },
      configure: function(state, pos) {
        if ([CSL.SINGLETON, CSL.START].indexOf(this.tokentype) > -1) {
          state.build.has_institution = true;
        }
      }
    };
    CSL.Node["institution-part"] = {build: function(state, target) {
        var func;
        if ("long" === this.strings.name) {
          if (this.strings["if-short"]) {
            func = function(state, Item) {
              state.nameOutput.institutionpart["long-with-short"] = this;
            };
          } else {
            func = function(state, Item) {
              state.nameOutput.institutionpart["long"] = this;
            };
          }
        } else if ("short" === this.strings.name) {
          func = function(state, Item) {
            state.nameOutput.institutionpart["short"] = this;
          };
        }
        this.execs.push(func);
        target.push(this);
      }};
    CSL.Node.key = {build: function(state, target) {
        target = state[state.build.root + "_sort"].tokens;
        var func,
            i,
            ilen;
        var debug = false;
        var start_key = new CSL.Token("key", CSL.START);
        start_key.strings["et-al-min"] = this.strings["et-al-min"];
        start_key.strings["et-al-use-first"] = this.strings["et-al-use-first"];
        start_key.strings["et-al-use-last"] = this.strings["et-al-use-last"];
        func = function(state, Item) {
          state.tmp.done_vars = [];
        };
        start_key.execs.push(func);
        state.opt.citation_number_sort_direction = this.strings.sort_direction;
        func = function(state, Item) {
          state.output.openLevel("empty");
        };
        start_key.execs.push(func);
        var sort_direction = [];
        if (this.strings.sort_direction === CSL.DESCENDING) {
          sort_direction.push(1);
          sort_direction.push(-1);
        } else {
          sort_direction.push(-1);
          sort_direction.push(1);
        }
        state[state.build.area].opt.sort_directions.push(sort_direction);
        if (CSL.DATE_VARIABLES.indexOf(this.variables[0]) > -1) {
          state.build.date_key = true;
        }
        func = function(state, Item) {
          state.tmp.sort_key_flag = true;
          if (this.strings["et-al-min"]) {
            state.tmp["et-al-min"] = this.strings["et-al-min"];
          }
          if (this.strings["et-al-use-first"]) {
            state.tmp["et-al-use-first"] = this.strings["et-al-use-first"];
          }
          if ("boolean" === typeof this.strings["et-al-use-last"]) {
            state.tmp["et-al-use-last"] = this.strings["et-al-use-last"];
          }
        };
        start_key.execs.push(func);
        target.push(start_key);
        if (this.variables.length) {
          var variable = this.variables[0];
          if (variable === "citation-number") {
            if (state.build.area === "citation_sort") {
              state.opt.citation_number_sort = true;
            }
            if (state.build.area === "bibliography_sort") {
              state.opt.citation_number_sort_used = true;
            }
          }
          if (CSL.CREATORS.indexOf(variable) > -1) {
            var names_start_token = new CSL.Token("names", CSL.START);
            names_start_token.tokentype = CSL.START;
            names_start_token.variables = this.variables;
            CSL.Node.names.build.call(names_start_token, state, target);
            var name_token = new CSL.Token("name", CSL.SINGLETON);
            name_token.tokentype = CSL.SINGLETON;
            name_token.strings["name-as-sort-order"] = "all";
            name_token.strings["sort-separator"] = " ";
            name_token.strings["et-al-use-last"] = this.strings["et-al-use-last"];
            name_token.strings["et-al-min"] = this.strings["et-al-min"];
            name_token.strings["et-al-use-first"] = this.strings["et-al-use-first"];
            CSL.Node.name.build.call(name_token, state, target);
            var institution_token = new CSL.Token("institution", CSL.SINGLETON);
            institution_token.tokentype = CSL.SINGLETON;
            CSL.Node.institution.build.call(institution_token, state, target);
            var names_end_token = new CSL.Token("names", CSL.END);
            names_end_token.tokentype = CSL.END;
            CSL.Node.names.build.call(names_end_token, state, target);
          } else {
            var single_text = new CSL.Token("text", CSL.SINGLETON);
            single_text.dateparts = this.dateparts;
            if (CSL.NUMERIC_VARIABLES.indexOf(variable) > -1) {
              func = function(state, Item) {
                var num,
                    m;
                num = false;
                if ("citation-number" === variable) {
                  num = state.registry.registry[Item.id].seq.toString();
                } else {
                  num = Item[variable];
                }
                if (num) {
                  num = CSL.Util.padding(num);
                }
                state.output.append(num, this);
              };
            } else if (variable === "citation-label") {
              func = function(state, Item) {
                var trigraph = state.getCitationLabel(Item);
                state.output.append(trigraph, this);
              };
            } else if (CSL.DATE_VARIABLES.indexOf(variable) > -1) {
              func = CSL.dateAsSortKey;
              single_text.variables = this.variables;
            } else if ("title" === variable) {
              var abbrevfam = "title";
              var abbrfall = false;
              var altvar = false;
              var transfall = true;
              func = state.transform.getOutputFunction(this.variables, abbrevfam, abbrfall, altvar, transfall);
            } else {
              func = function(state, Item) {
                var varval = Item[variable];
                state.output.append(varval, "empty");
              };
            }
            single_text.execs.push(func);
            target.push(single_text);
          }
        } else {
          var token = new CSL.Token("text", CSL.SINGLETON);
          token.postponed_macro = this.postponed_macro;
          CSL.expandMacro.call(state, token, target);
        }
        var end_key = new CSL.Token("key", CSL.END);
        func = function(state, Item) {
          var keystring = state.output.string(state, state.output.queue);
          if (state.sys.normalizeUnicode) {
            keystring = state.sys.normalizeUnicode(keystring);
          }
          keystring = keystring.split(" ").join("A");
          if ("" === keystring) {
            keystring = undefined;
          }
          if ("string" !== typeof keystring || state.tmp.empty_date) {
            keystring = undefined;
            state.tmp.empty_date = false;
          }
          state[state[state.tmp.area].root + "_sort"].keys.push(keystring);
          state.tmp.value = [];
        };
        end_key.execs.push(func);
        if (state.build.date_key) {
          if (state.build.area === "citation_sort") {
            state[state.build.area].opt.sort_directions.push([-1, 1]);
            func = function(state, Item) {
              var year_suffix = state.registry.registry[Item.id].disambig.year_suffix;
              if (!year_suffix) {
                year_suffix = 0;
              }
              var key = CSL.Util.padding("" + year_suffix);
              state[state.tmp.area].keys.push(key);
            };
            end_key.execs.push(func);
          }
          state.build.date_key = false;
        }
        func = function(state, Item) {
          state.tmp["et-al-min"] = undefined;
          state.tmp["et-al-use-first"] = undefined;
          state.tmp["et-al-use-last"] = undefined;
          state.tmp.sort_key_flag = false;
        };
        end_key.execs.push(func);
        target.push(end_key);
      }};
    CSL.Node.label = {build: function(state, target) {
        var debug = false;
        if (this.strings.term) {
          var plural = false;
          if (!this.strings.form) {}
          var func = function(state, Item, item) {
            var termtxt = CSL.evaluateLabel(this, state, Item, item);
            if (item && this.strings.term === "locator") {
              state.parallel.StartVariable("label");
              state.parallel.AppendToVariable(item.label);
              item.section_form_override = this.strings.form;
            }
            if (termtxt) {
              state.tmp.group_context.tip.term_intended = true;
            }
            CSL.UPDATE_GROUP_CONTEXT_CONDITION(state, termtxt);
            if (termtxt.indexOf("%s") === -1) {
              state.output.append(termtxt, this);
            }
            if (item && this.strings.term === "locator") {
              state.parallel.CloseVariable();
            }
          };
          this.execs.push(func);
        } else {
          var namevars = state.build.names_variables.slice(-1)[0];
          if (!state.build.name_label) {
            state.build.name_label = {};
          }
          for (var i = 0,
              ilen = namevars.length; i < ilen; i += 1) {
            if (!state.build.name_label[namevars[i]]) {
              state.build.name_label[namevars[i]] = {};
            }
          }
          if (!state.build.name_flag) {
            for (var i = 0,
                ilen = namevars.length; i < ilen; i += 1) {
              state.build.name_label[namevars[i]].before = this;
            }
          } else {
            for (var i = 0,
                ilen = namevars.length; i < ilen; i += 1) {
              state.build.name_label[namevars[i]].after = this;
            }
          }
        }
        target.push(this);
      }};
    CSL.Node.layout = {build: function(state, target) {
        var func,
            prefix_token,
            suffix_token,
            tok;
        function setSuffix() {
          if (state.build.area === "bibliography") {
            suffix_token = new CSL.Token("text", CSL.SINGLETON);
            func = function(state, Item, item) {
              var last_locale = state.tmp.cite_locales[state.tmp.cite_locales.length - 1];
              var suffix;
              if (state.tmp.cite_affixes[state.tmp.area][state.tmp.last_cite_locale]) {
                suffix = state.tmp.cite_affixes[state.tmp.area][state.tmp.last_cite_locale].suffix;
              } else {
                suffix = state.bibliography.opt.layout_suffix;
              }
              var topblob = state.output.current.value();
              if (state.opt.using_display) {
                topblob.blobs[topblob.blobs.length - 1].strings.suffix = suffix;
              } else {
                topblob.strings.suffix = suffix;
              }
              if (state.bibliography.opt["second-field-align"]) {
                state.output.endTag("bib_other");
              }
            };
            suffix_token.execs.push(func);
            target.push(suffix_token);
          }
        }
        if (this.tokentype === CSL.START) {
          if (this.locale_raw) {
            state.build.current_default_locale = this.locale_raw;
          } else {
            state.build.current_default_locale = state.opt["default-locale"];
          }
          func = function(state, Item, item) {
            if (state.opt.development_extensions.apply_citation_wrapper && state.sys.wrapCitationEntry && !state.tmp.just_looking && Item.system_id && state.tmp.area === "citation") {
              cite_entry = new CSL.Token("group", CSL.START);
              cite_entry.decorations = [["@cite", "entry"]];
              state.output.startTag("cite_entry", cite_entry);
              state.output.current.value().item_id = Item.system_id;
              if (item) {
                state.output.current.value().locator_txt = item.locator_txt;
                state.output.current.value().suffix_txt = item.suffix_txt;
              }
            }
          };
          this.execs.push(func);
        }
        if (this.tokentype === CSL.START && !state.tmp.cite_affixes[state.build.area]) {
          func = function(state, Item) {
            state.tmp.done_vars = [];
            if (!state.tmp.just_looking && state.registry.registry[Item.id].parallel) {
              state.tmp.done_vars.push("first-reference-note-number");
            }
            state.tmp.rendered_name = false;
            state.tmp.name_node = {};
          };
          this.execs.push(func);
          func = function(state, Item) {
            state.tmp.sort_key_flag = false;
          };
          this.execs.push(func);
          func = function(state, Item) {
            state.tmp.nameset_counter = 0;
          };
          this.execs.push(func);
          func = function(state, Item) {
            var tok = new CSL.Token();
            if (state.opt.development_extensions.rtl_support) {
              if (["ar", "he", "fa", "ur", "yi", "ps", "syr"].indexOf(Item.language) > -1) {
                tok = new CSL.Token();
                tok.strings.prefix = "\u202b";
                tok.strings.suffix = "\u202c";
              }
            }
            state.output.openLevel(tok);
          };
          this.execs.push(func);
          target.push(this);
          if (state.opt.development_extensions.rtl_support && false) {
            this.strings.prefix = this.strings.prefix.replace(/\((.|$)/g, "(\u200e$1");
            this.strings.suffix = this.strings.suffix.replace(/\)(.|$)/g, ")\u200e$1");
          }
          if (state.build.area === "citation") {
            prefix_token = new CSL.Token("text", CSL.SINGLETON);
            func = function(state, Item, item) {
              var sp;
              if (item && item.prefix) {
                sp = "";
                var test_prefix = item.prefix.replace(/<[^>]+>/g, "").replace(/["'\u201d\u2019\u00bb\u202f\u00a0 ]+$/g, "");
                var test_char = test_prefix.slice(-1);
                if (test_prefix.match(CSL.ENDSWITH_ROMANESQUE_REGEXP)) {
                  sp = " ";
                } else if (CSL.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(test_char) > -1) {
                  sp = " ";
                } else if (test_char.match(/[\)\],0-9]/)) {
                  sp = " ";
                }
                var ignorePredecessor = false;
                if (CSL.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(test_char) > -1 && item.prefix.trim().indexOf(" ") > -1) {
                  state.tmp.term_predecessor = false;
                  ignorePredecessor = true;
                }
                prefix = (item.prefix + sp).replace(/\s+/g, " ");
                if (!state.tmp.just_looking) {
                  prefix = state.output.checkNestedBrace.update(prefix);
                }
                state.output.append(prefix, this, false, ignorePredecessor);
              }
            };
            prefix_token.execs.push(func);
            target.push(prefix_token);
          }
        }
        var my_tok;
        if (this.locale_raw) {
          my_tok = new CSL.Token("dummy", CSL.START);
          my_tok.locale = this.locale_raw;
          my_tok.strings.delimiter = this.strings.delimiter;
          my_tok.strings.suffix = this.strings.suffix;
          if (!state.tmp.cite_affixes[state.build.area]) {
            state.tmp.cite_affixes[state.build.area] = {};
          }
        }
        if (this.tokentype === CSL.START) {
          state.build.layout_flag = true;
          if (!this.locale_raw) {
            state[state.tmp.area].opt.topdecor = [this.decorations];
            state[(state.tmp.area + "_sort")].opt.topdecor = [this.decorations];
            state[state.build.area].opt.layout_prefix = this.strings.prefix;
            state[state.build.area].opt.layout_suffix = this.strings.suffix;
            state[state.build.area].opt.layout_delimiter = this.strings.delimiter;
            state[state.build.area].opt.layout_decorations = this.decorations;
            if (state.tmp.cite_affixes[state.build.area]) {
              tok = new CSL.Token("else", CSL.START);
              CSL.Node["else"].build.call(tok, state, target);
            }
          }
          if (this.locale_raw) {
            if (!state.build.layout_locale_flag) {
              var choose_tok = new CSL.Token("choose", CSL.START);
              CSL.Node.choose.build.call(choose_tok, state, target);
              my_tok.name = "if";
              CSL.Attributes["@locale-internal"].call(my_tok, state, this.locale_raw);
              CSL.Node["if"].build.call(my_tok, state, target);
            } else {
              my_tok.name = "else-if";
              CSL.Attributes["@locale-internal"].call(my_tok, state, this.locale_raw);
              CSL.Node["else-if"].build.call(my_tok, state, target);
            }
            state.tmp.cite_affixes[state.build.area][my_tok.locale] = {};
            state.tmp.cite_affixes[state.build.area][my_tok.locale].delimiter = this.strings.delimiter;
            state.tmp.cite_affixes[state.build.area][my_tok.locale].suffix = this.strings.suffix;
          }
        }
        if (this.tokentype === CSL.END) {
          if (this.locale_raw) {
            setSuffix();
            if (!state.build.layout_locale_flag) {
              my_tok.name = "if";
              my_tok.tokentype = CSL.END;
              CSL.Attributes["@locale-internal"].call(my_tok, state, this.locale_raw);
              CSL.Node["if"].build.call(my_tok, state, target);
              state.build.layout_locale_flag = true;
            } else {
              my_tok.name = "else-if";
              my_tok.tokentype = CSL.END;
              CSL.Attributes["@locale-internal"].call(my_tok, state, this.locale_raw);
              CSL.Node["else-if"].build.call(my_tok, state, target);
            }
          }
          if (!this.locale_raw) {
            setSuffix();
            if (state.tmp.cite_affixes[state.build.area]) {
              if (state.build.layout_locale_flag) {
                tok = new CSL.Token("else", CSL.END);
                CSL.Node["else"].build.call(tok, state, target);
                tok = new CSL.Token("choose", CSL.END);
                CSL.Node.choose.build.call(tok, state, target);
              }
            }
            state.build_layout_locale_flag = true;
            if (state.build.area === "citation") {
              suffix_token = new CSL.Token("text", CSL.SINGLETON);
              func = function(state, Item, item) {
                var sp;
                if (item && item.suffix) {
                  sp = "";
                  if (item.suffix.match(CSL.STARTSWITH_ROMANESQUE_REGEXP) || ['[', '('].indexOf(item.suffix.slice(0, 1)) > -1) {
                    sp = " ";
                  }
                  var suffix = item.suffix;
                  if (!state.tmp.just_looking) {
                    suffix = state.output.checkNestedBrace.update(suffix);
                  }
                  state.output.append((sp + suffix), this);
                }
              };
              suffix_token.execs.push(func);
              target.push(suffix_token);
            }
            func = function(state, Item) {
              state.output.closeLevel();
            };
            this.execs.push(func);
            func = function(state, Item) {
              if (state.opt.development_extensions.apply_citation_wrapper && state.sys.wrapCitationEntry && !state.tmp.just_looking && Item.system_id && state.tmp.area === "citation") {
                state.output.endTag();
              }
            };
            this.execs.push(func);
            target.push(this);
            state.build.layout_flag = false;
            state.build.layout_locale_flag = false;
          }
        }
      }};
    CSL.Node.macro = {build: function(state, target) {}};
    CSL.NameOutput = function(state, Item, item, variables) {
      this.debug = false;
      this.state = state;
      this.Item = Item;
      this.item = item;
      this.nameset_base = 0;
      this.etal_spec = {};
      this._first_creator_variable = false;
      this._please_chop = false;
    };
    CSL.NameOutput.prototype.init = function(names) {
      if (this.state.tmp.term_predecessor) {
        this.state.tmp.subsequent_author_substitute_ok = false;
      }
      if (this.nameset_offset) {
        this.nameset_base = this.nameset_base + this.nameset_offset;
      }
      this.nameset_offset = 0;
      this.names = names;
      this.variables = names.variables;
      this.state.tmp.value = [];
      this.state.tmp.rendered_name = [];
      this.state.tmp.label_blob = false;
      this.state.tmp.etal_node = false;
      this.state.tmp.etal_term = false;
      for (var i = 0,
          ilen = this.variables.length; i < ilen; i += 1) {
        if (this.Item[this.variables[i]] && this.Item[this.variables[i]].length) {
          this.state.tmp.value = this.state.tmp.value.concat(this.Item[this.variables[i]]);
        }
      }
      this["et-al"] = undefined;
      this["with"] = undefined;
      this.name = undefined;
      this.institutionpart = {};
      this.state.tmp.group_context.tip.variable_attempt = true;
      if (!this.state.tmp.value.length) {
        return;
      }
    };
    CSL.NameOutput.prototype.reinit = function(names) {
      if (this.state.tmp.can_substitute.value()) {
        this.nameset_offset = 0;
        this.variables = names.variables;
        var oldval = this.state.tmp.value.slice();
        this.state.tmp.value = [];
        for (var i = 0,
            ilen = this.variables.length; i < ilen; i += 1) {
          if (this.Item[this.variables[i]] && this.Item[this.variables[i]].length) {
            this.state.tmp.value = this.state.tmp.value.concat(this.Item[this.variables[i]]);
          }
        }
        if (this.state.tmp.value.length) {
          this.state.tmp.can_substitute.replace(false, CSL.LITERAL);
        }
        this.state.tmp.value = oldval;
      }
    };
    CSL.NameOutput.prototype.outputNames = function() {
      var i,
          ilen;
      var variables = this.variables;
      if (this.institution.and) {
        if (!this.institution.and.single.blobs || !this.institution.and.single.blobs.length) {
          this.institution.and.single.blobs = this.name.and.single.blobs;
        }
        if (!this.institution.and.multiple.blobs || !this.institution.and.multiple.blobs.length) {
          this.institution.and.multiple.blobs = this.name.and.multiple.blobs;
        }
      }
      this.variable_offset = {};
      if (this.family) {
        this.family_decor = CSL.Util.cloneToken(this.family);
        this.family_decor.strings.prefix = "";
        this.family_decor.strings.suffix = "";
        for (i = 0, ilen = this.family.execs.length; i < ilen; i += 1) {
          this.family.execs[i].call(this.family_decor, this.state, this.Item);
        }
      } else {
        this.family_decor = false;
      }
      if (this.given) {
        this.given_decor = CSL.Util.cloneToken(this.given);
        this.given_decor.strings.prefix = "";
        this.given_decor.strings.suffix = "";
        for (i = 0, ilen = this.given.execs.length; i < ilen; i += 1) {
          this.given.execs[i].call(this.given_decor, this.state, this.Item);
        }
      } else {
        this.given_decor = false;
      }
      this.getEtAlConfig();
      this.divideAndTransliterateNames();
      this.truncatePersonalNameLists();
      this.disambigNames();
      this.constrainNames();
      if (this.name.strings.form === "count") {
        if (this.state.tmp.extension || this.names_count != 0) {
          this.state.output.append(this.names_count, "empty");
          this.state.tmp.group_context.tip.variable_success = true;
        }
        return;
      }
      this.setEtAlParameters();
      this.setCommonTerm();
      this.state.tmp.name_node = {};
      this.state.tmp.name_node.children = [];
      this.renderAllNames();
      var blob_list = [];
      for (i = 0, ilen = variables.length; i < ilen; i += 1) {
        var v = variables[i];
        var institution_sets = [];
        var institutions = false;
        var varblob = null;
        if (!this.state.opt.development_extensions.spoof_institutional_affiliations) {
          varblob = this._join([this.freeters[v]], "");
        } else {
          for (var j = 0,
              jlen = this.institutions[v].length; j < jlen; j += 1) {
            institution_sets.push(this.joinPersonsAndInstitutions([this.persons[v][j], this.institutions[v][j]]));
          }
          if (this.institutions[v].length) {
            var pos = this.nameset_base + this.variable_offset[v];
            if (this.freeters[v].length) {
              pos += 1;
            }
            institutions = this.joinInstitutionSets(institution_sets, pos);
          }
          var varblob = this.joinFreetersAndInstitutionSets([this.freeters[v], institutions]);
        }
        if (varblob) {
          if (!this.state.tmp.extension) {
            varblob = this._applyLabels(varblob, v);
          }
          blob_list.push(varblob);
        }
        if (this.common_term) {
          break;
        }
      }
      this.state.output.openLevel("empty");
      this.state.output.current.value().strings.delimiter = this.names.strings.delimiter;
      for (i = 0, ilen = blob_list.length; i < ilen; i += 1) {
        this.state.output.append(blob_list[i], "literal", true);
      }
      this.state.output.closeLevel("empty");
      var blob = this.state.output.pop();
      this.state.output.append(blob, this.names);
      if (this.state.tmp.term_predecessor_name) {
        this.state.tmp.term_predecessor = true;
      }
      this.state.tmp.name_node.top = this.state.output.current.value();
      if (variables[0] !== "authority") {
        var name_node_string = [];
        var nameobjs = this.Item[variables[0]];
        if (nameobjs) {
          for (var i = 0,
              ilen = nameobjs.length; i < ilen; i += 1) {
            substring = CSL.Util.Names.getRawName(nameobjs[i]);
            if (substring) {
              name_node_string.push(substring);
            }
          }
        }
        name_node_string = name_node_string.join(", ");
        if (name_node_string) {
          this.state.tmp.name_node.string = name_node_string;
        }
      }
      if (this.state.tmp.name_node.string && !this.state.tmp.first_name_string) {
        this.state.tmp.first_name_string = this.state.tmp.name_node.string;
      }
      if ("classic" === this.Item.type) {
        var author_title = [];
        if (this.state.tmp.first_name_string) {
          author_title.push(this.state.tmp.first_name_string);
        }
        if (this.Item.title) {
          author_title.push(this.Item.title);
        }
        author_title = author_title.join(", ");
        if (author_title && this.state.sys.getAbbreviation) {
          this.state.transform.loadAbbreviation("default", "classic", author_title);
          if (this.state.transform.abbrevs["default"].classic[author_title]) {
            this.state.tmp.done_vars.push("title");
            this.state.output.append(this.state.transform.abbrevs["default"].classic[author_title], "empty", true);
            blob = this.state.output.pop();
            this.state.tmp.name_node.top.blobs.pop();
            this.state.tmp.name_node.top.blobs.push(blob);
          }
        }
      }
      this._collapseAuthor();
      this.variables = [];
    };
    CSL.NameOutput.prototype._applyLabels = function(blob, v) {
      var txt;
      if (!this.label || !this.label[v]) {
        return blob;
      }
      var plural = 0;
      var num = this.freeters_count[v] + this.institutions_count[v];
      if (num > 1) {
        plural = 1;
      } else {
        for (var i = 0,
            ilen = this.persons[v].length; i < ilen; i += 1) {
          num += this.persons_count[v][i];
        }
        if (num > 1) {
          plural = 1;
        }
      }
      if (this.label[v].before) {
        if ("number" === typeof this.label[v].before.strings.plural) {
          plural = this.label[v].before.strings.plural;
        }
        txt = this._buildLabel(v, plural, "before", v);
        this.state.output.openLevel("empty");
        this.state.output.append(txt, this.label[v].before, true);
        this.state.output.append(blob, "literal", true);
        this.state.output.closeLevel("empty");
        blob = this.state.output.pop();
      } else if (this.label[v].after) {
        if ("number" === typeof this.label[v].after.strings.plural) {
          plural = this.label[v].after.strings.plural;
        }
        txt = this._buildLabel(v, plural, "after", v);
        this.state.output.openLevel("empty");
        this.state.output.append(blob, "literal", true);
        this.state.output.append(txt, this.label[v].after, true);
        this.state.tmp.label_blob = this.state.output.pop();
        this.state.output.append(this.state.tmp.label_blob, "literal", true);
        this.state.output.closeLevel("empty");
        blob = this.state.output.pop();
      }
      return blob;
    };
    CSL.NameOutput.prototype._buildLabel = function(term, plural, position, v) {
      if (this.common_term) {
        term = this.common_term;
      }
      var ret = false;
      var node = this.label[v][position];
      if (node) {
        ret = CSL.castLabel(this.state, node, term, plural, CSL.TOLERANT);
      }
      return ret;
    };
    CSL.NameOutput.prototype._collapseAuthor = function() {
      var myqueue,
          mystr,
          oldchars;
      if (this.nameset_base === 0 && this.Item[this.variables[0]] && !this._first_creator_variable) {
        this._first_creator_variable = this.variables[0];
      }
      if ((this.item && this.item["suppress-author"] && this._first_creator_variable == this.variables[0]) || (this.state[this.state.tmp.area].opt.collapse && this.state[this.state.tmp.area].opt.collapse.length) || (this.state[this.state.tmp.area].opt.cite_group_delimiter && this.state[this.state.tmp.area].opt.cite_group_delimiter.length)) {
        if (this.state.tmp.authorstring_request) {
          mystr = "";
          myqueue = this.state.tmp.name_node.top.blobs.slice(-1)[0].blobs;
          oldchars = this.state.tmp.offset_characters;
          if (myqueue) {
            mystr = this.state.output.string(this.state, myqueue, false);
          }
          this.state.tmp.offset_characters = oldchars;
          this.state.registry.authorstrings[this.Item.id] = mystr;
        } else if (!this.state.tmp.just_looking && !this.state.tmp.suppress_decorations && (this.item["suppress-author"] || (this.state[this.state.tmp.area].opt.collapse && this.state[this.state.tmp.area].opt.collapse.length) || this.state[this.state.tmp.area].opt.cite_group_delimiter && this.state[this.state.tmp.area].opt.cite_group_delimiter)) {
          mystr = "";
          myqueue = this.state.tmp.name_node.top.blobs.slice(-1)[0].blobs;
          oldchars = this.state.tmp.offset_characters;
          if (myqueue) {
            mystr = this.state.output.string(this.state, myqueue, false);
          }
          if (mystr === this.state.tmp.last_primary_names_string) {
            if (this.item["suppress-author"] || (this.state[this.state.tmp.area].opt.collapse && this.state[this.state.tmp.area].opt.collapse.length)) {
              this.state.tmp.name_node.top.blobs.pop();
              this.state.tmp.name_node.children = [];
              this.state.tmp.offset_characters = oldchars;
            }
            if (this.state[this.state.tmp.area].opt.cite_group_delimiter && this.state[this.state.tmp.area].opt.cite_group_delimiter) {
              this.state.tmp.use_cite_group_delimiter = true;
            }
          } else {
            this.state.tmp.last_primary_names_string = mystr;
            if (this.variables.indexOf(this._first_creator_variable) > -1 && this.item && this.item["suppress-author"] && this.Item.type !== "legal_case") {
              this.state.tmp.name_node.top.blobs.pop();
              this.state.tmp.name_node.children = [];
              this.state.tmp.offset_characters = oldchars;
              this.state.tmp.term_predecessor = false;
            }
            this.state.tmp.have_collapsed = false;
            if (this.state[this.state.tmp.area].opt.cite_group_delimiter && this.state[this.state.tmp.area].opt.cite_group_delimiter) {
              this.state.tmp.use_cite_group_delimiter = false;
            }
          }
        }
      }
    };
    CSL.NameOutput.prototype.isPerson = function(value) {
      if (value.literal || (!value.given && value.family && value.isInstitution)) {
        return false;
      } else {
        return true;
      }
    };
    CSL.NameOutput.prototype.truncatePersonalNameLists = function() {
      var v,
          i,
          ilen,
          j,
          jlen,
          chopvar,
          values;
      this.freeters_count = {};
      this.persons_count = {};
      this.institutions_count = {};
      for (v in this.freeters) {
        if (this.freeters.hasOwnProperty(v)) {
          this.freeters_count[v] = this.freeters[v].length;
          this.freeters[v] = this._truncateNameList(this.freeters, v);
        }
      }
      for (v in this.persons) {
        if (this.persons.hasOwnProperty(v)) {
          this.institutions_count[v] = this.institutions[v].length;
          this._truncateNameList(this.institutions, v);
          this.persons[v] = this.persons[v].slice(0, this.institutions[v].length);
          this.persons_count[v] = [];
          for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            this.persons_count[v][j] = this.persons[v][j].length;
            this.persons[v][j] = this._truncateNameList(this.persons, v, j);
          }
        }
      }
      if (this.etal_min === 1 && this.etal_use_first === 1 && !(this.state.tmp.extension || this.state.tmp.just_looking)) {
        chopvar = v;
      } else {
        chopvar = false;
      }
      if (chopvar || this._please_chop) {
        for (i = 0, ilen = this.variables.length; i < ilen; i += 1) {
          v = this.variables[i];
          if (this.freeters[v].length) {
            if (this._please_chop === v) {
              this.freeters[v] = this.freeters[v].slice(1);
              this.freeters_count[v] += -1;
              this._please_chop = false;
            } else if (chopvar && !this._please_chop) {
              this.freeters[v] = this.freeters[v].slice(0, 1);
              this.freeters_count[v] = 1;
              this.institutions[v] = [];
              this.persons[v] = [];
              this._please_chop = chopvar;
            }
          }
          for (var j = 0,
              jlen = this.persons[v].length; j < jlen; j++) {
            if (this.persons[v][j].length) {
              if (this._please_chop === v) {
                this.persons[v][j] = this.persons[v][j].slice(1);
                this.persons_count[v][j] += -1;
                this._please_chop = false;
                break;
              } else if (chopvar && !this._please_chop) {
                this.freeters[v] = this.persons[v][j].slice(0, 1);
                this.freeters_count[v] = 1;
                this.institutions[v] = [];
                this.persons[v] = [];
                values = [];
                this._please_chop = chopvar;
                break;
              }
            }
          }
          if (this.institutions[v].length) {
            if (this._please_chop === v) {
              this.institutions[v] = this.institutions[v].slice(1);
              this.institutions_count[v] += -1;
              this._please_chop = false;
            } else if (chopvar && !this._please_chop) {
              this.institutions[v] = this.institutions[v].slice(0, 1);
              this.institutions_count[v] = 1;
              values = [];
              this._please_chop = chopvar;
            }
          }
        }
      }
      for (i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        if (this.institutions[v].length) {
          this.nameset_offset += 1;
        }
        for (var j = 0,
            jlen = this.persons[v].length; j < jlen; j++) {
          if (this.persons[v][j].length) {
            this.nameset_offset += 1;
          }
        }
      }
    };
    CSL.NameOutput.prototype._truncateNameList = function(container, variable, index) {
      var lst;
      if ("undefined" === typeof index) {
        lst = container[variable];
      } else {
        lst = container[variable][index];
      }
      if (this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names && lst.length > 50 && lst.length > (this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names + 2)) {
        var limit = this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names;
        lst = lst.slice(0, limit + 1).concat(lst.slice(-1));
      }
      return lst;
    };
    CSL.NameOutput.prototype.divideAndTransliterateNames = function() {
      var i,
          ilen,
          j,
          jlen;
      var Item = this.Item;
      var variables = this.variables;
      this.varnames = variables.slice();
      this.freeters = {};
      this.persons = {};
      this.institutions = {};
      for (i = 0, ilen = variables.length; i < ilen; i += 1) {
        var v = variables[i];
        this.variable_offset[v] = this.nameset_offset;
        var values = this._normalizeVariableValue(Item, v);
        if (this.name.strings["suppress-min"] && values.length >= this.name.strings["suppress-min"]) {
          values = [];
        }
        if (this.name.strings["suppress-max"] && values.length <= this.name.strings["suppress-max"]) {
          values = [];
        }
        this._getFreeters(v, values);
        this._getPersonsAndInstitutions(v, values);
        if (this.state.opt.development_extensions.spoof_institutional_affiliations) {
          if (this.name.strings["suppress-min"] === 0) {
            this.freeters[v] = [];
            for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
              this.persons[v][j] = [];
            }
          } else if (this.institution.strings["suppress-min"] === 0) {
            this.institutions[v] = [];
            this.freeters[v] = this.freeters[v].concat(this.persons[v]);
            for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
              for (var k = 0,
                  klen = this.persons[v][j].length; k < klen; k += 1) {
                this.freeters[v].push(this.persons[v][j][k]);
              }
            }
            this.persons[v] = [];
          }
        }
      }
    };
    CSL.NameOutput.prototype._normalizeVariableValue = function(Item, variable) {
      var names,
          name,
          i,
          ilen;
      if ("string" === typeof Item[variable] || "number" === typeof Item[variable]) {
        CSL.debug("name variable \"" + variable + "\" is string or number, not array. Attempting to fix.");
        names = [{literal: Item[variable] + ""}];
      } else if (!Item[variable]) {
        names = [];
      } else if ("number" !== typeof Item[variable].length) {
        CSL.debug("name variable \"" + variable + "\" is object, not array. Attempting to fix.");
        Item[variable] = [Item[variable]];
        names = Item[variable].slice();
      } else {
        names = Item[variable].slice();
      }
      return names;
    };
    CSL.NameOutput.prototype._getFreeters = function(v, values) {
      this.freeters[v] = [];
      if (this.state.opt.development_extensions.spoof_institutional_affiliations) {
        for (var i = values.length - 1; i > -1; i--) {
          if (this.isPerson(values[i])) {
            var value = this._checkNickname(values.pop());
            if (value) {
              this.freeters[v].push(value);
            }
          } else {
            break;
          }
        }
      } else {
        for (var i = values.length - 1; i > -1; i--) {
          var value = values.pop();
          if (this.isPerson(value)) {
            var value = this._checkNickname(value);
          }
          this.freeters[v].push(value);
        }
      }
      this.freeters[v].reverse();
      if (this.freeters[v].length) {
        this.nameset_offset += 1;
      }
    };
    CSL.NameOutput.prototype._getPersonsAndInstitutions = function(v, values) {
      this.persons[v] = [];
      this.institutions[v] = [];
      if (!this.state.opt.development_extensions.spoof_institutional_affiliations)
        return;
      var persons = [];
      var has_affiliates = false;
      var first = true;
      for (var i = values.length - 1; i > -1; i += -1) {
        if (this.isPerson(values[i])) {
          var value = this._checkNickname(values[i]);
          if (value) {
            persons.push(value);
          }
        } else {
          has_affiliates = true;
          this.institutions[v].push(values[i]);
          if (!first) {
            persons.reverse();
            this.persons[v].push(persons);
            persons = [];
          }
          first = false;
        }
      }
      if (has_affiliates) {
        persons.reverse();
        this.persons[v].push(persons);
        this.persons[v].reverse();
        this.institutions[v].reverse();
      }
    };
    CSL.NameOutput.prototype._clearValues = function(values) {
      for (var i = values.length - 1; i > -1; i += -1) {
        values.pop();
      }
    };
    CSL.NameOutput.prototype._checkNickname = function(name) {
      if (["interview", "personal_communication"].indexOf(this.Item.type) > -1) {
        var author = "";
        author = CSL.Util.Names.getRawName(name);
        if (author && this.state.sys.getAbbreviation && !(this.item && this.item["suppress-author"])) {
          this.state.transform.loadAbbreviation("default", "nickname", author);
          var myLocalName = this.state.transform.abbrevs["default"].nickname[author];
          if (myLocalName) {
            if (myLocalName === "!here>>>") {
              name = false;
            } else {
              name = {
                family: myLocalName,
                given: ''
              };
            }
          }
        }
      }
      return name;
    };
    CSL.NameOutput.prototype.joinPersons = function(blobs, pos, j, tokenname) {
      var ret;
      if (!tokenname) {
        tokenname = "name";
      }
      if ("undefined" === typeof j) {
        if (this.etal_spec[pos].freeters === 1) {
          ret = this._joinEtAl(blobs, tokenname);
        } else if (this.etal_spec[pos].freeters === 2) {
          ret = this._joinEllipsis(blobs, tokenname);
        } else if (!this.state.tmp.sort_key_flag) {
          ret = this._joinAnd(blobs, tokenname);
        } else {
          ret = this._join(blobs, " ");
        }
      } else {
        if (this.etal_spec[pos].persons[j] === 1) {
          ret = this._joinEtAl(blobs, tokenname);
        } else if (this.etal_spec[pos].persons[j] === 2) {
          ret = this._joinEllipsis(blobs, tokenname);
        } else if (!this.state.tmp.sort_key_flag) {
          ret = this._joinAnd(blobs, tokenname);
        } else {
          ret = this._join(blobs, " ");
        }
      }
      return ret;
    };
    CSL.NameOutput.prototype.joinInstitutionSets = function(blobs, pos) {
      var ret;
      if (this.etal_spec[pos].institutions === 1) {
        ret = this._joinEtAl(blobs, "institution");
      } else if (this.etal_spec[pos].institutions === 2) {
        ret = this._joinEllipsis(blobs, "institution");
      } else {
        ret = this._joinAnd(blobs, "institution");
      }
      return ret;
    };
    CSL.NameOutput.prototype.joinPersonsAndInstitutions = function(blobs) {
      return this._join(blobs, this.name.strings.delimiter);
    };
    CSL.NameOutput.prototype.joinFreetersAndInstitutionSets = function(blobs) {
      var ret = this._join(blobs, "[never here]", this["with"].single, this["with"].multiple);
      return ret;
    };
    CSL.NameOutput.prototype._joinEtAl = function(blobs, tokenname) {
      var blob = this._join(blobs, this.name.strings.delimiter);
      this.state.output.openLevel(this._getToken(tokenname));
      this.state.output.current.value().strings.delimiter = "";
      this.state.output.append(blob, "literal", true);
      if (blobs.length > 1) {
        this.state.output.append(this["et-al"].multiple, "literal", true);
      } else if (blobs.length === 1) {
        this.state.output.append(this["et-al"].single, "literal", true);
      }
      this.state.output.closeLevel();
      return this.state.output.pop();
    };
    CSL.NameOutput.prototype._joinEllipsis = function(blobs, tokenname) {
      return this._join(blobs, this.name.strings.delimiter, this.name.ellipsis.single, this.name.ellipsis.multiple, tokenname);
    };
    CSL.NameOutput.prototype._joinAnd = function(blobs, tokenname) {
      return this._join(blobs, this[tokenname].strings.delimiter, this[tokenname].and.single, this[tokenname].and.multiple, tokenname);
    };
    CSL.NameOutput.prototype._join = function(blobs, delimiter, single, multiple, tokenname) {
      var i,
          ilen;
      if (!blobs) {
        return false;
      }
      for (i = blobs.length - 1; i > -1; i += -1) {
        if (!blobs[i] || blobs[i].length === 0 || !blobs[i].blobs.length) {
          blobs = blobs.slice(0, i).concat(blobs.slice(i + 1));
        }
      }
      if (!blobs.length) {
        return false;
      } else if (single && blobs.length === 2) {
        if (single) {
          single = new CSL.Blob(single.blobs, single);
        }
        blobs = [blobs[0], single, blobs[1]];
      } else {
        var delimiter_offset;
        if (multiple) {
          delimiter_offset = 2;
        } else {
          delimiter_offset = 1;
        }
        for (i = 0, ilen = blobs.length - delimiter_offset; i < ilen; i += 1) {
          blobs[i].strings.suffix += delimiter;
        }
        if (blobs.length > 1) {
          var blob = blobs.pop();
          if (multiple) {
            multiple = new CSL.Blob(multiple.blobs, multiple);
            blobs.push(multiple);
          } else {
            if (single) {
              single = new CSL.Blob(single.blobs, single);
            }
            blobs.push(single);
          }
          blobs.push(blob);
        }
      }
      this.state.output.openLevel();
      if (single && multiple) {
        this.state.output.current.value().strings.delimiter = "";
      }
      for (i = 0, ilen = blobs.length; i < ilen; i += 1) {
        this.state.output.append(blobs[i], false, true);
      }
      this.state.output.closeLevel();
      return this.state.output.pop();
    };
    CSL.NameOutput.prototype._getToken = function(tokenname) {
      var token = this[tokenname];
      if (tokenname === "institution") {
        var newtoken = new CSL.Token();
        return newtoken;
      }
      return token;
    };
    CSL.NameOutput.prototype.setCommonTerm = function() {
      var variables = this.variables;
      var varnames = variables.slice();
      varnames.sort();
      this.common_term = varnames.join("");
      if (!this.common_term) {
        return false;
      }
      var has_term = false;
      if (this.label && this.label[this.variables[0]]) {
        if (this.label[this.variables[0]].before) {
          has_term = this.state.getTerm(this.common_term, this.label[this.variables[0]].before.strings.form, 0);
        } else if (this.label[this.variables[0]].after) {
          has_term = this.state.getTerm(this.common_term, this.label[this.variables[0]].after.strings.form, 0);
        }
      }
      if (!this.state.locale[this.state.opt.lang].terms[this.common_term] || !has_term || this.variables.length < 2) {
        this.common_term = false;
        return;
      }
      var freeters_offset = 0;
      for (var i = 0,
          ilen = this.variables.length - 1; i < ilen; i += 1) {
        var v = this.variables[i];
        var vv = this.variables[i + 1];
        if (this.freeters[v].length || this.freeters[vv].length) {
          if (this.etal_spec[v].freeters !== this.etal_spec[vv].freeters || !this._compareNamesets(this.freeters[v], this.freeters[vv])) {
            this.common_term = false;
            return;
          }
          freeters_offset += 1;
        }
        if (this.persons[v].length !== this.persons[vv].length) {
          this.common_term = false;
          return;
        }
        for (var j = 0,
            jlen = this.persons[v].length; j < jlen; j += 1) {
          if (this.etal_spec[v].persons[j] !== this.etal_spec[vv].persons[j] || !this._compareNamesets(this.persons[v][j], this.persons[vv][j])) {
            this.common_term = false;
            return;
          }
        }
      }
    };
    CSL.NameOutput.prototype._compareNamesets = function(base_nameset, nameset) {
      if (base_nameset.length !== nameset.length) {
        return false;
      }
      for (var i = 0,
          ilen = nameset.length; i < ilen; i += 1) {
        var name = nameset[i];
        for (var j = 0,
            jlen = CSL.NAME_PARTS.length; j < jlen; j += 1) {
          var part = CSL.NAME_PARTS[j];
          if (!base_nameset[i] || base_nameset[i][part] != nameset[i][part]) {
            return false;
          }
        }
      }
      return true;
    };
    CSL.NameOutput.prototype.constrainNames = function() {
      this.names_count = 0;
      var pos;
      for (var i = 0,
          ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        pos = this.nameset_base + i;
        if (this.freeters[v].length) {
          this.state.tmp.names_max.push(this.freeters[v].length, "literal");
          this._imposeNameConstraints(this.freeters, this.freeters_count, v, pos);
          this.names_count += this.freeters[v].length;
        }
        if (this.institutions[v].length) {
          this.state.tmp.names_max.push(this.institutions[v].length, "literal");
          this._imposeNameConstraints(this.institutions, this.institutions_count, v, pos);
          this.persons[v] = this.persons[v].slice(0, this.institutions[v].length);
          this.names_count += this.institutions[v].length;
        }
        for (var j = 0,
            jlen = this.persons[v].length; j < jlen; j += 1) {
          if (this.persons[v][j].length) {
            this.state.tmp.names_max.push(this.persons[v][j].length, "literal");
            this._imposeNameConstraints(this.persons[v], this.persons_count[v], j, pos);
            this.names_count += this.persons[v][j].length;
          }
        }
      }
    };
    CSL.NameOutput.prototype._imposeNameConstraints = function(lst, count, key, pos) {
      var display_names = lst[key];
      var discretionary_names_length = this.state.tmp["et-al-min"];
      if (this.state.tmp.suppress_decorations) {
        if (this.state.tmp.disambig_request && this.state.tmp.disambig_request.names[pos]) {
          discretionary_names_length = this.state.tmp.disambig_request.names[pos];
        } else if (count[key] >= this.etal_min) {
          discretionary_names_length = this.etal_use_first;
        }
      } else {
        if (this.state.tmp.disambig_request && this.state.tmp.disambig_request.names[pos] > this.etal_use_first) {
          if (count[key] < this.etal_min) {
            discretionary_names_length = count[key];
          } else {
            discretionary_names_length = this.state.tmp.disambig_request.names[pos];
          }
        } else if (count[key] >= this.etal_min) {
          discretionary_names_length = this.etal_use_first;
        }
        if (this.etal_use_last && discretionary_names_length > (this.etal_min - 2)) {
          discretionary_names_length = this.etal_min - 2;
        }
      }
      var sane = this.etal_min >= this.etal_use_first;
      var overlength = count[key] > discretionary_names_length;
      if (discretionary_names_length > count[key]) {
        discretionary_names_length = display_names.length;
      }
      if (sane && overlength) {
        if (this.etal_use_last) {
          lst[key] = display_names.slice(0, discretionary_names_length).concat(display_names.slice(-1));
        } else {
          lst[key] = display_names.slice(0, discretionary_names_length);
        }
      }
      this.state.tmp.disambig_settings.names[pos] = lst[key].length;
      this.state.disambiguate.padBase(this.state.tmp.disambig_settings);
    };
    CSL.NameOutput.prototype.disambigNames = function() {
      var pos;
      for (var i = 0,
          ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        pos = this.nameset_base + i;
        if (this.freeters[v].length) {
          this._runDisambigNames(this.freeters[v], pos);
        }
        if (this.institutions[v].length) {
          if ("undefined" === typeof this.state.tmp.disambig_settings.givens[pos]) {
            this.state.tmp.disambig_settings.givens[pos] = [];
          }
          for (var j = 0,
              jlen = this.institutions[v].length; j < jlen; j += 1) {
            if ("undefined" === typeof this.state.tmp.disambig_settings.givens[pos][j]) {
              this.state.tmp.disambig_settings.givens[pos].push(2);
            }
          }
        }
        for (var j = 0,
            jlen = this.persons[v].length; j < jlen; j += 1) {
          if (this.persons[v][j].length) {
            this._runDisambigNames(this.persons[v][j], pos);
          }
        }
      }
    };
    CSL.NameOutput.prototype._runDisambigNames = function(lst, pos) {
      var chk,
          myform,
          myinitials,
          param,
          i,
          ilen,
          paramx;
      for (i = 0, ilen = lst.length; i < ilen; i += 1) {
        if (!lst[i].given && !lst[i].family) {
          continue;
        }
        myinitials = this.name.strings["initialize-with"];
        this.state.registry.namereg.addname("" + this.Item.id, lst[i], i);
        chk = this.state.tmp.disambig_settings.givens[pos];
        if ("undefined" === typeof chk) {
          for (var j = 0,
              jlen = pos + 1; j < jlen; j += 1) {
            if (!this.state.tmp.disambig_settings.givens[j]) {
              this.state.tmp.disambig_settings.givens[j] = [];
            }
          }
        }
        chk = this.state.tmp.disambig_settings.givens[pos][i];
        if ("undefined" === typeof chk) {
          myform = this.name.strings.form;
          param = this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, 0, myform, myinitials);
          this.state.tmp.disambig_settings.givens[pos].push(param);
        }
        myform = this.name.strings.form;
        paramx = this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, 0, myform, myinitials);
        if (this.state.tmp.disambig_request) {
          var val = this.state.tmp.disambig_settings.givens[pos][i];
          if (val === 1 && this.state.citation.opt["givenname-disambiguation-rule"] === "by-cite" && ("undefined" === typeof this.name.strings["initialize-with"] || "undefined" === typeof lst[i].given)) {
            val = 2;
          }
          param = val;
          if (this.state.opt["disambiguate-add-givenname"] && lst[i].given) {
            param = this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, param, this.name.strings.form, this.name.strings["initialize-with"]);
          }
        } else {
          param = paramx;
        }
        if (!this.state.tmp.just_looking && this.item && this.item.position === CSL.POSITION_FIRST) {
          if (paramx > param) {
            param = paramx;
          }
        }
        if (!this.state.tmp.sort_key_flag) {
          this.state.tmp.disambig_settings.givens[pos][i] = param;
          if ("string" === typeof myinitials && ("undefined" === typeof this.name.strings["initialize"] || true === this.name.strings["initialize"])) {
            this.state.tmp.disambig_settings.use_initials = true;
          }
        }
      }
    };
    CSL.NameOutput.prototype.getEtAlConfig = function() {
      var item = this.item;
      this["et-al"] = {};
      this.state.output.append(this.etal_term, this.etal_style, true);
      this["et-al"].single = this.state.output.pop();
      this["et-al"].single.strings.suffix = this.etal_suffix;
      this["et-al"].single.strings.prefix = this.etal_prefix_single;
      this.state.output.append(this.etal_term, this.etal_style, true);
      this["et-al"].multiple = this.state.output.pop();
      this["et-al"].multiple.strings.suffix = this.etal_suffix;
      this["et-al"].multiple.strings.prefix = this.etal_prefix_multiple;
      if ("undefined" === typeof item) {
        item = {};
      }
      if (item.position) {
        if (this.name.strings["et-al-subsequent-min"]) {
          this.etal_min = this.name.strings["et-al-subsequent-min"];
        } else {
          this.etal_min = this.name.strings["et-al-min"];
        }
        if (this.name.strings["et-al-subsequent-use-first"]) {
          this.etal_use_first = this.name.strings["et-al-subsequent-use-first"];
        } else {
          this.etal_use_first = this.name.strings["et-al-use-first"];
        }
      } else {
        if (this.state.tmp["et-al-min"]) {
          this.etal_min = this.state.tmp["et-al-min"];
        } else {
          this.etal_min = this.name.strings["et-al-min"];
        }
        if (this.state.tmp["et-al-use-first"]) {
          this.etal_use_first = this.state.tmp["et-al-use-first"];
        } else {
          this.etal_use_first = this.name.strings["et-al-use-first"];
        }
        if ("boolean" === typeof this.state.tmp["et-al-use-last"]) {
          this.etal_use_last = this.state.tmp["et-al-use-last"];
        } else {
          this.etal_use_last = this.name.strings["et-al-use-last"];
        }
      }
      if (!this.state.tmp["et-al-min"]) {
        this.state.tmp["et-al-min"] = this.etal_min;
      }
    };
    CSL.NameOutput.prototype.setEtAlParameters = function() {
      var i,
          ilen,
          j,
          jlen;
      for (i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        if ("undefined" === typeof this.etal_spec[v]) {
          this.etal_spec[v] = {
            freeters: 0,
            institutions: 0,
            persons: []
          };
        }
        this.etal_spec[this.nameset_base + i] = this.etal_spec[v];
        if (this.freeters[v].length) {
          this._setEtAlParameter("freeters", v);
        }
        for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
          if ("undefined" === typeof this.etal_spec[v][j]) {
            this.etal_spec[v].persons[j] = 0;
          }
          this._setEtAlParameter("persons", v, j);
        }
        if (this.institutions[v].length) {
          this._setEtAlParameter("institutions", v);
        }
      }
    };
    CSL.NameOutput.prototype._setEtAlParameter = function(type, v, j) {
      var lst,
          count;
      if (type === "persons") {
        lst = this.persons[v][j];
        count = this.persons_count[v][j];
      } else {
        lst = this[type][v];
        count = this[type + "_count"][v];
      }
      if (lst.length < count && !this.state.tmp.sort_key_flag) {
        if (this.etal_use_last) {
          if (type === "persons") {
            this.etal_spec[v].persons[j] = 2;
          } else {
            this.etal_spec[v][type] = 2;
          }
        } else {
          if (type === "persons") {
            this.etal_spec[v].persons[j] = 1;
          } else {
            this.etal_spec[v][type] = 1;
          }
        }
      } else {
        if (type === "persons") {
          this.etal_spec[v].persons[j] = 0;
        } else {
          this.etal_spec[v][type] = 0;
        }
      }
    };
    CSL.NameOutput.prototype.renderAllNames = function() {
      var pos;
      for (var i = 0,
          ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        if (this.freeters[v].length || this.institutions[v].length) {
          if (!this.state.tmp.group_context.tip.condition) {
            this.state.tmp.just_did_number = false;
          }
        }
        pos = this.nameset_base + i;
        if (this.freeters[v].length) {
          this.freeters[v] = this._renderNames(v, this.freeters[v], pos);
        }
        for (var j = 0,
            jlen = this.institutions[v].length; j < jlen; j += 1) {
          this.persons[v][j] = this._renderNames(v, this.persons[v][j], pos, j);
        }
      }
      this.renderInstitutionNames();
    };
    CSL.NameOutput.prototype.renderInstitutionNames = function() {
      for (var i = 0,
          ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        for (var j = 0,
            jlen = this.institutions[v].length; j < jlen; j += 1) {
          var institution,
              institution_short,
              institution_long,
              short_style,
              long_style;
          var name = this.institutions[v][j];
          var j,
              ret,
              optLangTag,
              jlen,
              key,
              localesets;
          if (this.state.tmp.extension) {
            localesets = ["sort"];
          } else if (name.isInstitution) {
            localesets = this.state.opt['cite-lang-prefs'].institutions;
          } else {
            localesets = this.state.opt['cite-lang-prefs'].persons;
          }
          slot = {
            primary: 'locale-orig',
            secondary: false,
            tertiary: false
          };
          if (localesets) {
            var slotnames = ["primary", "secondary", "tertiary"];
            for (var k = 0,
                klen = slotnames.length; k < klen; k += 1) {
              if (localesets.length - 1 < k) {
                break;
              }
              if (localesets[k]) {
                slot[slotnames[k]] = 'locale-' + localesets[k];
              }
            }
          } else {
            slot.primary = 'locale-translat';
          }
          if (this.state.tmp.area !== "bibliography" && !(this.state.tmp.area === "citation" && this.state.opt.xclass === "note" && this.item && !this.item.position)) {
            slot.secondary = false;
            slot.tertiary = false;
          }
          var res;
          this.setRenderedName(name);
          var institution = this._renderInstitutionName(v, name, slot, j);
          this.institutions[v][j] = institution;
        }
      }
    };
    CSL.NameOutput.prototype._renderInstitutionName = function(v, name, slot, j) {
      res = this.getName(name, slot.primary, true);
      var primary = res.name;
      var usedOrig = res.usedOrig;
      if (primary) {
        primary = this.fixupInstitution(primary, v, j);
      }
      secondary = false;
      if (slot.secondary) {
        res = this.getName(name, slot.secondary, false, usedOrig);
        secondary = res.name;
        usedOrig = res.usedOrig;
        if (secondary) {
          secondary = this.fixupInstitution(secondary, v, j);
        }
      }
      tertiary = false;
      if (slot.tertiary) {
        res = this.getName(name, slot.tertiary, false, usedOrig);
        tertiary = res.name;
        if (tertiary) {
          tertiary = this.fixupInstitution(tertiary, v, j);
        }
      }
      switch (this.institution.strings["institution-parts"]) {
        case "short":
          if (primary["short"].length) {
            short_style = this._getShortStyle();
            institution = [this._renderOneInstitutionPart(primary["short"], short_style)];
          } else {
            long_style = this._getLongStyle(primary, v, j);
            institution_long = this._composeOneInstitutionPart([primary, secondary, tertiary], slot, long_style);
            institution = [institution_long];
          }
          break;
        case "short-long":
          long_style = this._getLongStyle(primary, v, j);
          short_style = this._getShortStyle();
          institution_short = this._renderOneInstitutionPart(primary["short"], short_style);
          institution_long = this._composeOneInstitutionPart([primary, secondary, tertiary], slot, long_style);
          institution = [institution_short, institution_long];
          break;
        case "long-short":
          long_style = this._getLongStyle(primary, v, j);
          short_style = this._getShortStyle();
          institution_short = this._renderOneInstitutionPart(primary["short"], short_style);
          institution_long = this._composeOneInstitutionPart([primary, secondary, tertiary], slot, long_style, true);
          institution = [institution_long, institution_short];
          break;
        default:
          long_style = this._getLongStyle(primary, v, j);
          institution = [this._composeOneInstitutionPart([primary, secondary, tertiary], slot, long_style)];
          break;
      }
      return this._join(institution, " ");
    };
    CSL.NameOutput.prototype._composeOneInstitutionPart = function(names, slot, style) {
      var primary = false,
          secondary = false,
          tertiary = false;
      if (names[0]) {
        primary = this._renderOneInstitutionPart(names[0]["long"], style);
      }
      if (names[1]) {
        secondary = this._renderOneInstitutionPart(names[1]["long"], style);
      }
      if (names[2]) {
        tertiary = this._renderOneInstitutionPart(names[2]["long"], style);
      }
      var institutionblob;
      if (secondary || tertiary) {
        this.state.output.openLevel("empty");
        this.state.output.append(primary);
        secondary_tok = CSL.Util.cloneToken(style);
        if (slot.secondary) {
          secondary_tok.strings.prefix = this.state.opt.citeAffixes.institutions[slot.secondary].prefix;
          secondary_tok.strings.suffix = this.state.opt.citeAffixes.institutions[slot.secondary].suffix;
          if (!secondary_tok.strings.prefix) {
            secondary_tok.strings.prefix = " ";
          }
        }
        this.state.output.append(secondary, secondary_tok);
        tertiary_tok = CSL.Util.cloneToken(style);
        if (slot.tertiary) {
          tertiary_tok.strings.prefix = this.state.opt.citeAffixes.institutions[slot.tertiary].prefix;
          tertiary_tok.strings.suffix = this.state.opt.citeAffixes.institutions[slot.tertiary].suffix;
          if (!tertiary_tok.strings.prefix) {
            tertiary_tok.strings.prefix = " ";
          }
        }
        this.state.output.append(tertiary, tertiary_tok);
        this.state.output.closeLevel();
        institutionblob = this.state.output.pop();
      } else {
        institutionblob = primary;
      }
      return institutionblob;
    };
    CSL.NameOutput.prototype._renderOneInstitutionPart = function(blobs, style) {
      for (var i = 0,
          ilen = blobs.length; i < ilen; i += 1) {
        if (blobs[i]) {
          var str = blobs[i];
          if (this.state.tmp.strip_periods) {
            str = str.replace(/\./g, "");
          } else {
            for (var j = 0,
                jlen = style.decorations.length; j < jlen; j += 1) {
              if ("@strip-periods" === style.decorations[j][0] && "true" === style.decorations[j][1]) {
                str = str.replace(/\./g, "");
                break;
              }
            }
          }
          this.state.tmp.group_context.tip.variable_success = true;
          this.state.tmp.can_substitute.replace(false, CSL.LITERAL);
          if (str === "!here>>>") {
            blobs[i] = false;
          } else {
            this.state.output.append(str, style, true);
            blobs[i] = this.state.output.pop();
          }
        }
      }
      if ("undefined" === typeof this.institution.strings["part-separator"]) {
        this.institution.strings["part-separator"] = this.name.strings.delimiter;
      }
      return this._join(blobs, this.institution.strings["part-separator"]);
    };
    CSL.NameOutput.prototype._renderNames = function(v, values, pos, j) {
      var ret = false;
      if (values.length) {
        var names = [];
        for (var i = 0,
            ilen = values.length; i < ilen; i += 1) {
          var name = values[i];
          var ret,
              optLangTag,
              jlen,
              key,
              localesets;
          if (this.state.tmp.extension) {
            localesets = ["sort"];
          } else if (name.isInstitution) {
            localesets = this.state.opt['cite-lang-prefs'].institutions;
          } else {
            localesets = this.state.opt['cite-lang-prefs'].persons;
          }
          slot = {
            primary: 'locale-orig',
            secondary: false,
            tertiary: false
          };
          if (localesets) {
            var slotnames = ["primary", "secondary", "tertiary"];
            for (var k = 0,
                klen = slotnames.length; k < klen; k += 1) {
              if (localesets.length - 1 < k) {
                break;
              }
              slot[slotnames[k]] = 'locale-' + localesets[k];
            }
          } else {
            slot.primary = 'locale-translat';
          }
          if (this.state.tmp.sort_key_flag || (this.state.tmp.area !== "bibliography" && !(this.state.tmp.area === "citation" && this.state.opt.xclass === "note" && this.item && !this.item.position))) {
            slot.secondary = false;
            slot.tertiary = false;
          }
          this.setRenderedName(name);
          if (!name.literal && !name.isInstitution) {
            var nameBlob = this._renderPersonalName(v, name, slot, pos, i, j);
            this.state.output.append(nameBlob, this.name, true);
            names.push(this.state.output.pop());
          } else {
            names.push(this._renderInstitutionName(v, name, slot, j));
          }
        }
        ret = this.joinPersons(names, pos, j);
      }
      return ret;
    };
    CSL.NameOutput.prototype._renderPersonalName = function(v, name, slot, pos, i, j) {
      var res = this.getName(name, slot.primary, true);
      var primary = this._renderOnePersonalName(res.name, pos, i, j);
      secondary = false;
      if (slot.secondary) {
        res = this.getName(name, slot.secondary, false, res.usedOrig);
        if (res.name) {
          secondary = this._renderOnePersonalName(res.name, pos, i, j);
        }
      }
      tertiary = false;
      if (slot.tertiary) {
        res = this.getName(name, slot.tertiary, false, res.usedOrig);
        if (res.name) {
          tertiary = this._renderOnePersonalName(res.name, pos, i, j);
        }
      }
      var personblob;
      if (secondary || tertiary) {
        this.state.output.openLevel("empty");
        this.state.output.append(primary);
        secondary_tok = new CSL.Token();
        if (slot.secondary) {
          secondary_tok.strings.prefix = this.state.opt.citeAffixes.persons[slot.secondary].prefix;
          secondary_tok.strings.suffix = this.state.opt.citeAffixes.persons[slot.secondary].suffix;
          if (!secondary_tok.strings.prefix) {
            secondary_tok.strings.prefix = " ";
          }
        }
        this.state.output.append(secondary, secondary_tok);
        tertiary_tok = new CSL.Token();
        if (slot.tertiary) {
          tertiary_tok.strings.prefix = this.state.opt.citeAffixes.persons[slot.tertiary].prefix;
          tertiary_tok.strings.suffix = this.state.opt.citeAffixes.persons[slot.tertiary].suffix;
          if (!tertiary_tok.strings.prefix) {
            tertiary_tok.strings.prefix = " ";
          }
        }
        this.state.output.append(tertiary, tertiary_tok);
        this.state.output.closeLevel();
        personblob = this.state.output.pop();
      } else {
        personblob = primary;
      }
      return personblob;
    };
    CSL.NameOutput.prototype._isRomanesque = function(name) {
      var ret = 2;
      if (!name.family.replace(/\"/g, '').match(CSL.ROMANESQUE_REGEXP)) {
        ret = 0;
      }
      if (!ret && name.given && name.given.match(CSL.STARTSWITH_ROMANESQUE_REGEXP)) {
        ret = 1;
      }
      if (ret == 2) {
        if (name.multi && name.multi.main) {
          var top_locale = name.multi.main.slice(0, 2);
        } else if (this.Item.language) {
          top_locale = this.Item.language.slice(0, 2);
        }
        if (["ja", "zh"].indexOf(top_locale) > -1) {
          ret = 1;
        }
      }
      return ret;
    };
    CSL.NameOutput.prototype._renderOnePersonalName = function(value, pos, i, j) {
      var name = value;
      var dropping_particle = this._droppingParticle(name, pos, j);
      var family = this._familyName(name);
      var non_dropping_particle = this._nonDroppingParticle(name);
      var given = this._givenName(name, pos, i);
      var suffix = this._nameSuffix(name);
      if (this._isShort(pos, i) && !name["full-form-always"]) {
        dropping_particle = false;
        given = false;
        suffix = false;
      }
      var sort_sep = this.name.strings["sort-separator"];
      if (!sort_sep) {
        sort_sep = "";
      }
      var suffix_sep;
      if (name["comma-suffix"]) {
        suffix_sep = ", ";
      } else {
        suffix_sep = " ";
      }
      var romanesque = this._isRomanesque(name);
      var has_hyphenated_non_dropping_particle = (non_dropping_particle && ["\u2019", "\'", "-", " "].indexOf(non_dropping_particle.blobs.slice(-1)) > -1);
      var blob,
          merged,
          first,
          second;
      if (romanesque === 0) {
        blob = this._join([non_dropping_particle, family, given], "");
      } else if (romanesque === 1 || name["static-ordering"]) {
        blob = this._join([non_dropping_particle, family, given], " ");
      } else if (name["reverse-ordering"]) {
        blob = this._join([given, non_dropping_particle, family], " ");
      } else if (this.state.tmp.sort_key_flag) {
        if (this.state.opt["demote-non-dropping-particle"] === "never") {
          first = this._join([non_dropping_particle, family, dropping_particle], " ");
          merged = this._join([first, given], "0");
          blob = this._join([merged, suffix], " ");
        } else {
          second = this._join([given, dropping_particle, non_dropping_particle], " ");
          merged = this._join([family, second], "0");
          blob = this._join([merged, suffix], " ");
        }
      } else if (this.name.strings["name-as-sort-order"] === "all" || (this.name.strings["name-as-sort-order"] === "first" && i === 0 && (j === 0 || "undefined" === typeof j))) {
        if (["Lord", "Lady"].indexOf(name.given) > -1) {
          sort_sep = ", ";
        }
        if (["always", "display-and-sort"].indexOf(this.state.opt["demote-non-dropping-particle"]) > -1) {
          second = this._join([given, dropping_particle], (name["comma-dropping-particle"] + " "));
          second = this._join([second, non_dropping_particle], " ");
          if (second && this.given) {
            second.strings.prefix = this.given.strings.prefix;
            second.strings.suffix = this.given.strings.suffix;
          }
          if (family && this.family) {
            family.strings.prefix = this.family.strings.prefix;
            family.strings.suffix = this.family.strings.suffix;
          }
          merged = this._join([family, second], sort_sep);
          blob = this._join([merged, suffix], sort_sep);
        } else {
          if (has_hyphenated_non_dropping_particle) {
            first = this._join([non_dropping_particle, family], "");
          } else {
            first = this._join([non_dropping_particle, family], " ");
          }
          if (first && this.family) {
            first.strings.prefix = this.family.strings.prefix;
            first.strings.suffix = this.family.strings.suffix;
          }
          second = this._join([given, dropping_particle], (name["comma-dropping-particle"] + " "));
          if (second && this.given) {
            second.strings.prefix = this.given.strings.prefix;
            second.strings.suffix = this.given.strings.suffix;
          }
          merged = this._join([first, second], sort_sep);
          blob = this._join([merged, suffix], sort_sep);
        }
      } else {
        if (name["dropping-particle"] && name.family && !name["non-dropping-particle"]) {
          if (["'", "\u02bc", "\u2019", "-"].indexOf(name["dropping-particle"].slice(-1)) > -1) {
            family = this._join([dropping_particle, family], "");
            dropping_particle = false;
          }
        }
        if (!this.state.tmp.term_predecessor) {}
        var space = " ";
        if (this.name.strings["initialize-with"] && this.name.strings["initialize-with"].match(/[\u00a0\ufeff]/) && ["fr", "ru"].indexOf(this.state.opt["default-locale"][0].slice(0, 2)) > -1) {
          space = "\u00a0";
        }
        if (has_hyphenated_non_dropping_particle) {
          second = this._join([non_dropping_particle, family], "");
          second = this._join([dropping_particle, second], space);
        } else {
          second = this._join([dropping_particle, non_dropping_particle, family], space);
        }
        second = this._join([second, suffix], suffix_sep);
        if (second && this.family) {
          second.strings.prefix = this.family.strings.prefix;
          second.strings.suffix = this.family.strings.suffix;
        }
        if (given && this.given) {
          given.strings.prefix = this.given.strings.prefix;
          given.strings.suffix = this.given.strings.suffix;
        }
        if (second.strings.prefix) {
          name["comma-dropping-particle"] = "";
        }
        blob = this._join([given, second], (name["comma-dropping-particle"] + space));
      }
      this.state.tmp.group_context.tip.variable_success = true;
      this.state.tmp.can_substitute.replace(false, CSL.LITERAL);
      this.state.tmp.term_predecessor = true;
      this.state.tmp.name_node.children.push(blob);
      return blob;
    };
    CSL.NameOutput.prototype._isShort = function(pos, i) {
      if (0 === this.state.tmp.disambig_settings.givens[pos][i]) {
        return true;
      } else {
        return false;
      }
    };
    CSL.NameOutput.prototype._normalizeNameInput = function(value) {
      var name = {
        literal: value.literal,
        family: value.family,
        isInstitution: value.isInstitution,
        given: value.given,
        suffix: value.suffix,
        "comma-suffix": value["comma-suffix"],
        "non-dropping-particle": value["non-dropping-particle"],
        "dropping-particle": value["dropping-particle"],
        "static-ordering": value["static-ordering"],
        "static-particles": value["static-particles"],
        "reverse-ordering": value["reverse-ordering"],
        "full-form-always": value["full-form-always"],
        "parse-names": value["parse-names"],
        "comma-dropping-particle": "",
        block_initialize: value.block_initialize,
        multi: value.multi
      };
      this._parseName(name);
      return name;
    };
    CSL.NameOutput.prototype._stripPeriods = function(tokname, str) {
      var decor_tok = this[tokname + "_decor"];
      if (str) {
        if (this.state.tmp.strip_periods) {
          str = str.replace(/\./g, "");
        } else if (decor_tok) {
          for (var i = 0,
              ilen = decor_tok.decorations.length; i < ilen; i += 1) {
            if ("@strip-periods" === decor_tok.decorations[i][0] && "true" === decor_tok.decorations[i][1]) {
              str = str.replace(/\./g, "");
              break;
            }
          }
        }
      }
      return str;
    };
    CSL.NameOutput.prototype._nonDroppingParticle = function(name) {
      var ndp = name["non-dropping-particle"];
      if (ndp && this.state.tmp.sort_key_flag) {
        ndp = ndp.replace(/[\'\u2019]/, "");
      }
      var str = this._stripPeriods("family", ndp);
      if (this.state.output.append(str, this.family_decor, true)) {
        return this.state.output.pop();
      }
      return false;
    };
    CSL.NameOutput.prototype._droppingParticle = function(name, pos, j) {
      var dp = name["dropping-particle"];
      if (dp && this.state.tmp.sort_key_flag) {
        dp = dp.replace(/[\'\u2019]/, "");
      }
      var str = this._stripPeriods("given", dp);
      if (name["dropping-particle"] && name["dropping-particle"].match(/^et.?al[^a-z]$/)) {
        if (this.name.strings["et-al-use-last"]) {
          if ("undefined" === typeof j) {
            this.etal_spec[pos].freeters = 2;
          } else {
            this.etal_spec[pos].persons = 2;
          }
        } else {
          if ("undefined" === typeof j) {
            this.etal_spec[pos].freeters = 1;
          } else {
            this.etal_spec[pos].persons = 1;
          }
        }
        name["comma-dropping-particle"] = "";
      } else if (this.state.output.append(str, this.given_decor, true)) {
        return this.state.output.pop();
      }
      return false;
    };
    CSL.NameOutput.prototype._familyName = function(name) {
      var str = this._stripPeriods("family", name.family);
      if (this.state.output.append(str, this.family_decor, true)) {
        return this.state.output.pop();
      }
      return false;
    };
    CSL.NameOutput.prototype._givenName = function(name, pos, i) {
      if (this.name.strings.initialize === false) {
        if (name.family && name.given && this.name.strings.initialize === false) {
          name.given = CSL.Util.Names.initializeWith(this.state, name.given, this.name.strings["initialize-with"], true);
        }
        name.given = CSL.Util.Names.unInitialize(this.state, name.given);
      } else {
        if (name.family && 1 === this.state.tmp.disambig_settings.givens[pos][i] && !name.block_initialize) {
          var initialize_with = this.name.strings["initialize-with"];
          name.given = CSL.Util.Names.initializeWith(this.state, name.given, initialize_with);
        } else {
          name.given = CSL.Util.Names.unInitialize(this.state, name.given);
        }
      }
      var str = this._stripPeriods("given", name.given);
      var rendered = this.state.output.append(str, this.given_decor, true);
      if (rendered) {
        ret = this.state.output.pop();
        return ret;
      }
      return false;
    };
    CSL.NameOutput.prototype._nameSuffix = function(name) {
      var str = name.suffix;
      if ("string" === typeof this.name.strings["initialize-with"]) {
        str = CSL.Util.Names.initializeWith(this.state, name.suffix, this.name.strings["initialize-with"], true);
      }
      str = this._stripPeriods("family", str);
      var toSuffix = '';
      if (str && str.slice(-1) === '.') {
        str = str.slice(0, -1);
        toSuffix = '.';
      }
      var rendered = this.state.output.append(str, "empty", true);
      if (rendered) {
        ret = this.state.output.pop();
        ret.strings.suffix = toSuffix + ret.strings.suffix;
        return ret;
      }
      return false;
    };
    CSL.NameOutput.prototype._getLongStyle = function(name, v, i) {
      var long_style,
          short_style;
      if (name["short"].length) {
        if (this.institutionpart["long-with-short"]) {
          long_style = this.institutionpart["long-with-short"];
        } else {
          long_style = this.institutionpart["long"];
        }
      } else {
        long_style = this.institutionpart["long"];
      }
      if (!long_style) {
        long_style = new CSL.Token();
      }
      return long_style;
    };
    CSL.NameOutput.prototype._getShortStyle = function() {
      var short_style;
      if (this.institutionpart["short"]) {
        short_style = this.institutionpart["short"];
      } else {
        short_style = new CSL.Token();
      }
      return short_style;
    };
    CSL.NameOutput.prototype._parseName = function(name) {
      var m,
          idx;
      if (!name["parse-names"] && "undefined" !== typeof name["parse-names"]) {
        return name;
      }
      if (name.family && !name.given && name.isInstitution) {
        name.literal = name.family;
        name.family = undefined;
        name.isInstitution = undefined;
      }
      var noparse;
      if (name.family && (name.family.slice(0, 1) === '"' && name.family.slice(-1) === '"') || (!name["parse-names"] && "undefined" !== typeof name["parse-names"])) {
        name.family = name.family.slice(1, -1);
        noparse = true;
        name["parse-names"] = 0;
      } else {
        noparse = false;
      }
      if (this.state.opt.development_extensions.parse_names) {
        if (!name["non-dropping-particle"] && name.family && !noparse && name.given) {
          if (!name["static-particles"]) {
            CSL.parseParticles(name, true);
          }
        }
      }
    };
    CSL.NameOutput.prototype.getName = function(name, slotLocaleset, fallback, stopOrig) {
      if (stopOrig && slotLocaleset === 'locale-orig') {
        return {
          name: false,
          usedOrig: stopOrig
        };
      }
      if (!name.family) {
        name.family = "";
      }
      if (!name.given) {
        name.given = "";
      }
      var name_params = {};
      name_params["static-ordering"] = this.getStaticOrder(name);
      var foundTag = true;
      if (slotLocaleset !== 'locale-orig') {
        foundTag = false;
        if (name.multi) {
          var langTags = this.state.opt[slotLocaleset];
          for (i = 0, ilen = langTags.length; i < ilen; i += 1) {
            langTag = langTags[i];
            if (name.multi._key[langTag]) {
              foundTag = true;
              var isInstitution = name.isInstitution;
              name = name.multi._key[langTag];
              name.isInstitution = isInstitution;
              name_params = this.getNameParams(langTag);
              name_params.transliterated = true;
              break;
            }
          }
        }
      }
      if (!foundTag) {
        var langTag = false;
        if (name.multi && name.multi.main) {
          langTag = name.multi.main;
        } else if (this.Item.language) {
          langTag = this.Item.language;
        }
        if (langTag) {
          name_params = this.getNameParams(langTag);
        }
      }
      if (!fallback && !foundTag) {
        return {
          name: false,
          usedOrig: stopOrig
        };
      }
      if (!name.family) {
        name.family = "";
      }
      if (!name.given) {
        name.given = "";
      }
      name = {
        family: name.family,
        given: name.given,
        "non-dropping-particle": name["non-dropping-particle"],
        "dropping-particle": name["dropping-particle"],
        suffix: name.suffix,
        "static-ordering": name_params["static-ordering"],
        "static-particles": name["static-particles"],
        "reverse-ordering": name_params["reverse-ordering"],
        "full-form-always": name_params["full-form-always"],
        "parse-names": name["parse-names"],
        "comma-suffix": name["comma-suffix"],
        "comma-dropping-particle": name["comma-dropping-particle"],
        transliterated: name_params.transliterated,
        block_initialize: name_params["block-initialize"],
        literal: name.literal,
        isInstitution: name.isInstitution,
        multi: name.multi
      };
      if (!name.literal && (!name.given && name.family && name.isInstitution)) {
        name.literal = name.family;
      }
      if (name.literal) {
        delete name.family;
        delete name.given;
      }
      name = this._normalizeNameInput(name);
      var usedOrig;
      if (stopOrig) {
        usedOrig = stopOrig;
      } else {
        usedOrig = !foundTag;
      }
      return {
        name: name,
        usedOrig: usedOrig
      };
    };
    CSL.NameOutput.prototype.getNameParams = function(langTag) {
      var ret = {};
      var langspec = CSL.localeResolve(this.Item.language, this.state.opt["default-locale"][0]);
      var try_locale = this.state.locale[langspec.best] ? langspec.best : this.state.opt["default-locale"][0];
      var name_as_sort_order = this.state.locale[try_locale].opts["name-as-sort-order"];
      var name_as_reverse_order = this.state.locale[try_locale].opts["name-as-reverse-order"];
      var name_never_short = this.state.locale[try_locale].opts["name-never-short"];
      var field_lang_bare = langTag.split("-")[0];
      if (name_as_sort_order && name_as_sort_order[field_lang_bare]) {
        ret["static-ordering"] = true;
        ret["reverse-ordering"] = false;
      }
      if (name_as_reverse_order && name_as_reverse_order[field_lang_bare]) {
        ret["reverse-ordering"] = true;
        ret["static-ordering"] = false;
      }
      if (name_never_short && name_never_short[field_lang_bare]) {
        ret["full-form-always"] = true;
      }
      if (ret["static-ordering"]) {
        ret["block-initialize"] = true;
      }
      return ret;
    };
    CSL.NameOutput.prototype.setRenderedName = function(name) {
      if (this.state.tmp.area === "bibliography") {
        var strname = "";
        for (var j = 0,
            jlen = CSL.NAME_PARTS.length; j < jlen; j += 1) {
          if (name[CSL.NAME_PARTS[j]]) {
            strname += name[CSL.NAME_PARTS[j]];
          }
        }
        this.state.tmp.rendered_name.push(strname);
      }
    };
    CSL.NameOutput.prototype.fixupInstitution = function(name, varname, listpos) {
      if (this.state.sys.getHumanForm && "legal_case" === this.Item.type && "authority" === varname) {
        name.literal = this.state.sys.getHumanForm(this.Item.jurisdiction, name.literal);
      }
      name = this._splitInstitution(name, varname, listpos);
      if (this.institution.strings["reverse-order"]) {
        name["long"].reverse();
      }
      var long_form = name["long"];
      var short_form = name["long"].slice();
      var use_short_form = false;
      if (this.state.sys.getAbbreviation) {
        var jurisdiction = this.Item.jurisdiction;
        for (var j = 0,
            jlen = long_form.length; j < jlen; j += 1) {
          jurisdiction = this.state.transform.loadAbbreviation(jurisdiction, "institution-part", long_form[j]);
          if (this.state.transform.abbrevs[jurisdiction]["institution-part"][long_form[j]]) {
            short_form[j] = this.state.transform.abbrevs[jurisdiction]["institution-part"][long_form[j]];
            use_short_form = true;
          }
        }
      }
      if (use_short_form) {
        name["short"] = short_form;
      } else {
        name["short"] = [];
      }
      return name;
    };
    CSL.NameOutput.prototype.getStaticOrder = function(name, refresh) {
      var static_ordering_val = false;
      if (!refresh && name["static-ordering"]) {
        static_ordering_val = true;
      } else if (this._isRomanesque(name) === 0) {
        static_ordering_val = true;
      } else if ((!name.multi || !name.multi.main) && this.Item.language && ['vi', 'hu'].indexOf(this.Item.language) > -1) {
        static_ordering_val = true;
      } else if (name.multi && name.multi.main && ['vi', 'hu'].indexOf(name.multi.main.slice(0, 2)) > -1) {
        static_ordering_val = true;
      } else {
        if (this.state.opt['auto-vietnamese-names'] && (CSL.VIETNAMESE_NAMES.exec(name.family + " " + name.given) && CSL.VIETNAMESE_SPECIALS.exec(name.family + name.given))) {
          static_ordering_val = true;
        }
      }
      return static_ordering_val;
    };
    CSL.NameOutput.prototype._splitInstitution = function(value, v, i) {
      var ret = {};
      var splitInstitution = value.literal.replace(/\s*\|\s*/g, "|");
      splitInstitution = splitInstitution.split("|");
      if (this.institution.strings.form === "short" && this.state.sys.getAbbreviation) {
        var jurisdiction = this.Item.jurisdiction;
        for (var j = splitInstitution.length; j > 0; j += -1) {
          var str = splitInstitution.slice(0, j).join("|");
          jurisdiction = this.state.transform.loadAbbreviation(jurisdiction, "institution-entire", str);
          if (this.state.transform.abbrevs[jurisdiction]["institution-entire"][str]) {
            var splitLst = this.state.transform.abbrevs[jurisdiction]["institution-entire"][str];
            splitLst = this.state.transform.quashCheck(splitLst);
            var splitSplitLst = splitLst.split(/>>[0-9]{4}>>/);
            var m = splitLst.match(/>>([0-9]{4})>>/);
            splitLst = splitSplitLst.pop();
            if (splitSplitLst.length > 0 && this.Item["original-date"] && this.Item["original-date"].year) {
              for (var k = m.length - 1; k > 0; k += -1) {
                if (parseInt(this.Item["original-date"].year, 10) >= parseInt(m[k], 10)) {
                  break;
                }
                splitLst = splitSplitLst.pop();
              }
            }
            splitLst = splitLst.replace(/\s*\|\s*/g, "|");
            splitInstitution = [splitLst];
            break;
          }
        }
      }
      splitInstitution.reverse();
      ret["long"] = this._trimInstitution(splitInstitution, v, i);
      return ret;
    };
    CSL.NameOutput.prototype._trimInstitution = function(subunits, v, i) {
      var use_first = false;
      var append_last = false;
      var s = subunits.slice();
      var stop_last = false;
      if (this.institution) {
        if ("undefined" !== typeof this.institution.strings["use-first"]) {
          use_first = this.institution.strings["use-first"];
        }
        if ("undefined" !== typeof this.institution.strings["stop-last"]) {
          stop_last = this.institution.strings["stop-last"];
        } else if ("authority" === v && this.state.tmp.authority_stop_last) {
          stop_last = this.state.tmp.authority_stop_last;
        }
        if (stop_last) {
          s = s.slice(0, stop_last);
          subunits = subunits.slice(0, stop_last);
        }
        if ("undefined" !== typeof this.institution.strings["use-last"]) {
          append_last = this.institution.strings["use-last"];
        }
        if ("authority" === v) {
          if (stop_last) {
            this.state.tmp.authority_stop_last = stop_last;
          }
          if (append_last) {
            this.state.tmp.authority_stop_last += (append_last * -1);
          }
        }
      }
      if (false === use_first) {
        if (this.persons[v].length === 0) {
          use_first = this.institution.strings["substitute-use-first"];
        }
        if (!use_first) {
          use_first = 0;
        }
      }
      if (false === append_last) {
        if (!use_first) {
          append_last = subunits.length;
        } else {
          append_last = 0;
        }
      }
      if (use_first > subunits.length - append_last) {
        use_first = subunits.length - append_last;
      }
      subunits = subunits.slice(0, use_first);
      s = s.slice(use_first);
      if (append_last) {
        if (append_last > s.length) {
          append_last = s.length;
        }
        if (append_last) {
          subunits = subunits.concat(s.slice((s.length - append_last)));
        }
      }
      return subunits;
    };
    CSL.PublisherOutput = function(state, group_tok) {
      this.state = state;
      this.group_tok = group_tok;
      this.varlist = [];
    };
    CSL.PublisherOutput.prototype.render = function() {
      this.clearVars();
      this.composeAndBlob();
      this.composeElements();
      this.composePublishers();
      this.joinPublishers();
    };
    CSL.PublisherOutput.prototype.composeAndBlob = function() {
      this.and_blob = {};
      var and_term = false;
      if (this.group_tok.strings.and === "text") {
        and_term = this.state.getTerm("and");
      } else if (this.group_tok.strings.and === "symbol") {
        and_term = "&";
      }
      var tok = new CSL.Token();
      tok.strings.suffix = " ";
      tok.strings.prefix = " ";
      this.state.output.append(and_term, tok, true);
      var no_delim = this.state.output.pop();
      tok.strings.prefix = this.group_tok.strings["subgroup-delimiter"];
      this.state.output.append(and_term, tok, true);
      var with_delim = this.state.output.pop();
      this.and_blob.single = false;
      this.and_blob.multiple = false;
      if (and_term) {
        if (this.group_tok.strings["subgroup-delimiter-precedes-last"] === "always") {
          this.and_blob.single = with_delim;
        } else if (this.group_tok.strings["subgroup-delimiter-precedes-last"] === "never") {
          this.and_blob.single = no_delim;
          this.and_blob.multiple = no_delim;
        } else {
          this.and_blob.single = no_delim;
          this.and_blob.multiple = with_delim;
        }
      }
    };
    CSL.PublisherOutput.prototype.composeElements = function() {
      for (var i = 0,
          ilen = 2; i < ilen; i += 1) {
        var varname = ["publisher", "publisher-place"][i];
        for (var j = 0,
            jlen = this["publisher-list"].length; j < jlen; j += 1) {
          var str = this[varname + "-list"][j];
          var tok = this[varname + "-token"];
          this.state.output.append(str, tok, true);
          this[varname + "-list"][j] = this.state.output.pop();
        }
      }
    };
    CSL.PublisherOutput.prototype.composePublishers = function() {
      var blobs;
      for (var i = 0,
          ilen = this["publisher-list"].length; i < ilen; i += 1) {
        var ordered_list = [];
        blobs = [this[this.varlist[0] + "-list"][i], this[this.varlist[1] + "-list"][i]];
        this["publisher-list"][i] = this._join(blobs, this.group_tok.strings.delimiter);
      }
    };
    CSL.PublisherOutput.prototype.joinPublishers = function() {
      var blobs = this["publisher-list"];
      var delim = this.name_delimiter;
      var publishers = this._join(blobs, this.group_tok.strings["subgroup-delimiter"], this.and_blob.single, this.and_blob.multiple, this.group_tok);
      this.state.output.append(publishers, "literal");
    };
    CSL.PublisherOutput.prototype._join = CSL.NameOutput.prototype._join;
    CSL.PublisherOutput.prototype._getToken = CSL.NameOutput.prototype._getToken;
    CSL.PublisherOutput.prototype.clearVars = function() {
      this.state.tmp["publisher-list"] = false;
      this.state.tmp["publisher-place-list"] = false;
      this.state.tmp["publisher-group-token"] = false;
      this.state.tmp["publisher-token"] = false;
      this.state.tmp["publisher-place-token"] = false;
    };
    CSL.evaluateLabel = function(node, state, Item, item) {
      var myterm;
      if ("locator" === node.strings.term) {
        if (item && item.label) {
          if (item.label === "sub verbo") {
            myterm = "sub-verbo";
          } else {
            myterm = item.label;
          }
        }
        if (!myterm) {
          myterm = "page";
        }
      } else {
        myterm = node.strings.term;
      }
      var plural = node.strings.plural;
      if ("number" !== typeof plural) {
        var theItem = node.strings.term === "locator" ? item : Item;
        state.processNumber(false, theItem, node.strings.term, Item.type);
        plural = state.tmp.shadow_numbers[node.strings.term].plural;
        if (!state.tmp.shadow_numbers[node.strings.term].labelForm && !state.tmp.shadow_numbers[node.strings.term].labelDecorations) {
          state.tmp.shadow_numbers[node.strings.term].labelForm = node.strings.form;
          state.tmp.shadow_numbers[node.strings.term].labelDecorations = node.decorations.slice();
        }
        if (["locator", "number", "page"].indexOf(node.strings.term) > -1 && state.tmp.shadow_numbers[node.strings.term].label) {
          myterm = state.tmp.shadow_numbers[node.strings.term].label;
        }
        if (node.decorations && (state.opt.development_extensions.csl_reverse_lookup_support || state.sys.csl_reverse_lookup_support)) {
          node.decorations.reverse();
          node.decorations.push(["@showid", "true", node.cslid]);
          node.decorations.reverse();
        }
      }
      return CSL.castLabel(state, node, myterm, plural, CSL.TOLERANT);
    };
    CSL.castLabel = function(state, node, term, plural, mode) {
      var label_form = node.strings.form;
      if (state.tmp.group_context.tip.label_form && label_form !== "static") {
        label_form = state.tmp.group_context.tip.label_form;
      }
      var ret = state.getTerm(term, label_form, plural, false, mode);
      if (state.tmp.strip_periods) {
        ret = ret.replace(/\./g, "");
      } else {
        for (var i = 0,
            ilen = node.decorations.length; i < ilen; i += 1) {
          if ("@strip-periods" === node.decorations[i][0] && "true" === node.decorations[i][1]) {
            ret = ret.replace(/\./g, "");
            break;
          }
        }
      }
      return ret;
    };
    CSL.Node.name = {build: function(state, target) {
        var func,
            pos,
            len,
            attrname;
        if ([CSL.SINGLETON, CSL.START].indexOf(this.tokentype) > -1) {
          state.fixOpt(this, "name-delimiter", "name_delimiter");
          state.fixOpt(this, "name-form", "form");
          state.fixOpt(this, "and", "and");
          state.fixOpt(this, "delimiter-precedes-last", "delimiter-precedes-last");
          state.fixOpt(this, "delimiter-precedes-et-al", "delimiter-precedes-et-al");
          state.fixOpt(this, "initialize-with", "initialize-with");
          state.fixOpt(this, "initialize", "initialize");
          state.fixOpt(this, "name-as-sort-order", "name-as-sort-order");
          state.fixOpt(this, "sort-separator", "sort-separator");
          state.fixOpt(this, "and", "and");
          state.fixOpt(this, "et-al-min", "et-al-min");
          state.fixOpt(this, "et-al-use-first", "et-al-use-first");
          state.fixOpt(this, "et-al-use-last", "et-al-use-last");
          state.fixOpt(this, "et-al-subsequent-min", "et-al-subsequent-min");
          state.fixOpt(this, "et-al-subsequent-use-first", "et-al-subsequent-use-first");
          if (this.strings["et-al-subsequent-min"] && (this.strings["et-al-subsequent-min"] !== this.strings["et-al-min"])) {
            state.opt.update_mode = CSL.POSITION;
          }
          if (this.strings["et-al-subsequent-use-first"] && (this.strings["et-al-subsequent-use-first"] !== this.strings["et-al-use-first"])) {
            state.opt.update_mode = CSL.POSITION;
          }
          if ("undefined" == typeof this.strings.name_delimiter) {
            this.strings.delimiter = ", ";
          } else {
            this.strings.delimiter = this.strings.name_delimiter;
          }
          if (this.strings["et-al-use-last"]) {
            this.ellipsis_term = "\u2026";
            this.ellipsis_prefix_single = " ";
            this.ellipsis_prefix_multiple = this.strings.delimiter;
            this.ellipsis_suffix = " ";
          }
          func = function(state, Item) {
            state.tmp.etal_term = "et-al";
            state.tmp.name_delimiter = this.strings.delimiter;
            state.tmp["delimiter-precedes-et-al"] = this.strings["delimiter-precedes-et-al"];
            if ("text" === this.strings.and) {
              this.and_term = state.getTerm("and", "long", 0);
            } else if ("symbol" === this.strings.and) {
              if (state.opt.development_extensions.expect_and_symbol_form) {
                this.and_term = state.getTerm("and", "symbol", 0);
              } else {
                this.and_term = "&";
              }
            }
            state.tmp.and_term = this.and_term;
            if (CSL.STARTSWITH_ROMANESQUE_REGEXP.test(this.and_term)) {
              this.and_prefix_single = " ";
              this.and_prefix_multiple = ", ";
              if ("string" === typeof this.strings.delimiter) {
                this.and_prefix_multiple = this.strings.delimiter;
              }
              this.and_suffix = " ";
              state.build.name_delimiter = this.strings.delimiter;
            } else {
              this.and_prefix_single = "";
              this.and_prefix_multiple = "";
              this.and_suffix = "";
            }
            if (this.strings["delimiter-precedes-last"] === "always") {
              this.and_prefix_single = this.strings.delimiter;
            } else if (this.strings["delimiter-precedes-last"] === "never") {
              if (this.and_prefix_multiple) {
                this.and_prefix_multiple = " ";
              }
            } else if (this.strings["delimiter-precedes-last"] === "after-inverted-name") {
              if (this.and_prefix_single) {
                this.and_prefix_single = this.strings.delimiter;
                ;
              }
              if (this.and_prefix_multiple) {
                this.and_prefix_multiple = " ";
              }
            }
            this.and = {};
            if (this.strings.and) {
              state.output.append(this.and_term, "empty", true);
              this.and.single = state.output.pop();
              this.and.single.strings.prefix = this.and_prefix_single;
              this.and.single.strings.suffix = this.and_suffix;
              state.output.append(this.and_term, "empty", true);
              this.and.multiple = state.output.pop();
              this.and.multiple.strings.prefix = this.and_prefix_multiple;
              this.and.multiple.strings.suffix = this.and_suffix;
            } else if (this.strings.delimiter) {
              this.and.single = new CSL.Blob(this.strings.delimiter);
              this.and.single.strings.prefix = "";
              this.and.single.strings.suffix = "";
              this.and.multiple = new CSL.Blob(this.strings.delimiter);
              this.and.multiple.strings.prefix = "";
              this.and.multiple.strings.suffix = "";
            }
            this.ellipsis = {};
            if (this.strings["et-al-use-last"]) {
              this.ellipsis.single = new CSL.Blob(this.ellipsis_term);
              this.ellipsis.single.strings.prefix = this.ellipsis_prefix_single;
              this.ellipsis.single.strings.suffix = this.ellipsis_suffix;
              this.ellipsis.multiple = new CSL.Blob(this.ellipsis_term);
              this.ellipsis.multiple.strings.prefix = this.ellipsis_prefix_multiple;
              this.ellipsis.multiple.strings.suffix = this.ellipsis_suffix;
            }
            if ("undefined" === typeof state.tmp["et-al-min"]) {
              state.tmp["et-al-min"] = this.strings["et-al-min"];
            }
            if ("undefined" === typeof state.tmp["et-al-use-first"]) {
              state.tmp["et-al-use-first"] = this.strings["et-al-use-first"];
            }
            if ("undefined" === typeof state.tmp["et-al-use-last"]) {
              state.tmp["et-al-use-last"] = this.strings["et-al-use-last"];
            }
            state.nameOutput.name = this;
          };
          state.build.name_flag = true;
          this.execs.push(func);
        }
        target.push(this);
      }};
    CSL.Node["name-part"] = {build: function(state, target) {
        state.build[this.strings.name] = this;
      }};
    CSL.Node.names = {build: function(state, target) {
        var func,
            len,
            pos,
            attrname;
        var debug = false;
        if (this.tokentype === CSL.START || this.tokentype === CSL.SINGLETON) {
          CSL.Util.substituteStart.call(this, state, target);
          state.build.substitute_level.push(1);
          state.fixOpt(this, "names-delimiter", "delimiter");
        }
        if (this.tokentype === CSL.SINGLETON) {
          state.build.names_variables.push(this.variables);
          for (var i = 0,
              ilen = this.variables.length; i < ilen; i += 1) {
            state.build.name_label[this.variables[i]] = state.build.name_label[state.build.names_variables.slice(0)[0]];
          }
          func = function(state, Item, item) {
            state.nameOutput.reinit(this);
          };
          this.execs.push(func);
        }
        if (this.tokentype === CSL.START) {
          state.build.names_flag = true;
          state.build.names_level += 1;
          if (state.build.names_level === 1) {
            state.build.names_variables = [];
            state.build.name_label = {};
          }
          state.build.names_variables.push(this.variables);
          func = function(state, Item, item) {
            state.tmp.can_substitute.push(true);
            state.parallel.StartVariable("names", this.variables[0]);
            state.nameOutput.init(this);
          };
          this.execs.push(func);
        }
        if (this.tokentype === CSL.END) {
          for (var i = 0,
              ilen = 3; i < ilen; i += 1) {
            var key = ["family", "given", "et-al"][i];
            this[key] = state.build[key];
            if (state.build.names_level === 1) {
              state.build[key] = undefined;
            }
          }
          this.label = state.build.name_label;
          if (state.build.names_level === 1) {
            state.build.name_label = {};
          }
          state.build.names_level += -1;
          state.build.names_variables.pop();
          var mywith = "with";
          var with_default_prefix = "";
          var with_suffix = "";
          if (CSL.STARTSWITH_ROMANESQUE_REGEXP.test(mywith)) {
            with_default_prefix = " ";
            with_suffix = " ";
          }
          this["with"] = {};
          this["with"].single = new CSL.Blob(mywith);
          this["with"].single.strings.suffix = with_suffix;
          this["with"].multiple = new CSL.Blob(mywith);
          this["with"].multiple.strings.suffix = with_suffix;
          if (this.strings["delimiter-precedes-last"] === "always") {
            this["with"].single.strings.prefix = this.strings.delimiter;
            this["with"].multiple.strings.prefix = this.strings.delimiter;
          } else if (this.strings["delimiter-precedes-last"] === "contextual") {
            this["with"].single.strings.prefix = with_default_prefix;
            this["with"].multiple.strings.prefix = this.strings.delimiter;
          } else if (this.strings["delimiter-precedes-last"] === "after-inverted-name") {
            this["with"].single.strings.prefix = this.strings.delimiter;
            this["with"].multiple.strings.prefix = with_default_prefix;
          } else {
            this["with"].single.strings.prefix = with_default_prefix;
            this["with"].multiple.strings.prefix = with_default_prefix;
          }
          func = function(state, Item, item) {
            if (state.tmp.etal_node) {
              this.etal_style = state.tmp.etal_node;
            } else {
              this.etal_style = "empty";
            }
            this.etal_term = state.getTerm(state.tmp.etal_term, "long", 0);
            if (CSL.STARTSWITH_ROMANESQUE_REGEXP.test(this.etal_term)) {
              this.etal_prefix_single = " ";
              this.etal_prefix_multiple = state.tmp.name_delimiter;
              if (state.tmp["delimiter-precedes-et-al"] === "always") {
                this.etal_prefix_single = state.tmp.name_delimiter;
              } else if (state.tmp["delimiter-precedes-et-al"] === "never") {
                this.etal_prefix_multiple = " ";
              } else if (state.tmp["delimiter-precedes-et-al"] === "after-inverted-name") {
                this.etal_prefix_single = state.tmp.name_delimiter;
                this.etal_prefix_multiple = " ";
              }
              this.etal_suffix = "";
            } else {
              this.etal_prefix_single = "";
              this.etal_prefix_multiple = "";
              this.etal_suffix = "";
            }
            for (var i = 0,
                ilen = 3; i < ilen; i += 1) {
              var key = ["family", "given"][i];
              state.nameOutput[key] = this[key];
            }
            state.nameOutput["with"] = this["with"];
            state.nameOutput.label = this.label;
            state.nameOutput.etal_style = this.etal_style;
            state.nameOutput.etal_term = this.etal_term;
            state.nameOutput.etal_prefix_single = this.etal_prefix_single;
            state.nameOutput.etal_prefix_multiple = this.etal_prefix_multiple;
            state.nameOutput.etal_suffix = this.etal_suffix;
            state.nameOutput.outputNames();
            state.tmp["et-al-use-first"] = undefined;
            state.tmp["et-al-min"] = undefined;
            state.tmp["et-al-use-last"] = undefined;
          };
          this.execs.push(func);
          func = function(state, Item) {
            if (!state.tmp.can_substitute.pop()) {
              state.tmp.can_substitute.replace(false, CSL.LITERAL);
            }
            state.parallel.CloseVariable("names");
            if (state.tmp.can_substitute.mystack.length === 1) {
              state.tmp.can_block_substitute = false;
            }
          };
          this.execs.push(func);
          state.build.name_flag = false;
        }
        target.push(this);
        if (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON) {
          state.build.substitute_level.pop();
          CSL.Util.substituteEnd.call(this, state, target);
        }
      }};
    CSL.Node.number = {build: function(state, target) {
        var func;
        CSL.Util.substituteStart.call(this, state, target);
        if (this.strings.form === "roman") {
          this.formatter = state.fun.romanizer;
        } else if (this.strings.form === "ordinal") {
          this.formatter = state.fun.ordinalizer;
        } else if (this.strings.form === "long-ordinal") {
          this.formatter = state.fun.long_ordinalizer;
        }
        if ("undefined" === typeof this.successor_prefix) {
          this.successor_prefix = state[state.build.area].opt.layout_delimiter;
        }
        if ("undefined" === typeof this.splice_prefix) {
          this.splice_prefix = state[state.build.area].opt.layout_delimiter;
        }
        func = function(state, Item, item) {
          var i,
              ilen,
              newlst,
              lst;
          if (this.variables.length === 0) {
            return;
          }
          if ("undefined" === typeof item) {
            var item = {};
          }
          var varname,
              num,
              number,
              m,
              j,
              jlen;
          varname = this.variables[0];
          if (varname === "locator" && state.tmp.just_looking) {
            return;
          }
          state.parallel.StartVariable(this.variables[0]);
          if (this.variables[0] === "locator") {
            state.parallel.AppendToVariable(Item.section);
          } else {
            state.parallel.AppendToVariable(Item[this.variables[0]]);
          }
          var rex = new RegExp("(?:&|, | and |" + state.getTerm("page-range-delimiter") + ")");
          if (varname === 'collection-number' && Item.type === 'legal_case') {
            state.tmp.renders_collection_number = true;
          }
          var value = Item[this.variables[0]];
          var form = "long";
          if (this.strings.label_form_override) {
            form = this.strings.label_form_override;
          }
          var node = this;
          if (state.tmp.group_context.tip.force_suppress) {
            return false;
          }
          if (varname === "locator") {
            state.processNumber(node, item, varname, Item.type);
          } else {
            if (!state.tmp.group_context.tip.condition && Item[varname]) {
              state.tmp.just_did_number = true;
            }
            state.processNumber(node, Item, varname, Item.type);
          }
          CSL.Util.outputNumericField(state, varname, Item.id);
          state.parallel.CloseVariable("number");
          if (["locator", "locator-extra"].indexOf(this.variables_real[0]) > -1 && !state.tmp.just_looking) {
            state.tmp.done_vars.push(this.variables_real[0]);
            state.tmp.group_context.tip.done_vars.push(this.variables_real[0]);
          }
        };
        this.execs.push(func);
        target.push(this);
        CSL.Util.substituteEnd.call(this, state, target);
      }};
    CSL.Node.sort = {build: function(state, target) {
        target = state[state.build.root + "_sort"].tokens;
        if (this.tokentype === CSL.START) {
          if (state.build.area === "citation") {
            state.parallel.use_parallels = false;
            state.opt.sort_citations = true;
          }
          state.build.area = state.build.root + "_sort";
          state.build.extension = "_sort";
          var func = function(state, Item) {
            if (state.opt.has_layout_locale) {
              var langspec = CSL.localeResolve(Item.language, state.opt["default-locale"][0]);
              var sort_locales = state[state.tmp.area.slice(0, -5)].opt.sort_locales;
              var langForItem;
              for (var i = 0,
                  ilen = sort_locales.length; i < ilen; i += 1) {
                langForItem = sort_locales[i][langspec.bare];
                if (!langForItem) {
                  langForItem = sort_locales[i][langspec.best];
                }
                if (langForItem) {
                  break;
                }
              }
              if (!langForItem) {
                langForItem = state.opt["default-locale"][0];
              }
              state.tmp.lang_sort_hold = state.opt.lang;
              state.opt.lang = langForItem;
            }
          };
          this.execs.push(func);
        }
        if (this.tokentype === CSL.END) {
          state.build.area = state.build.root;
          state.build.extension = "";
          var func = function(state, Item) {
            if (state.opt.has_layout_locale) {
              state.opt.lang = state.tmp.lang_sort_hold;
              delete state.tmp.lang_sort_hold;
            }
          };
          this.execs.push(func);
        }
        target.push(this);
      }};
    CSL.Node.substitute = {build: function(state, target) {
        var func;
        if (this.tokentype === CSL.START) {
          func = function(state, Item) {
            state.tmp.can_block_substitute = true;
            if (state.tmp.value.length) {
              state.tmp.can_substitute.replace(false, CSL.LITERAL);
            }
          };
          this.execs.push(func);
        }
        target.push(this);
      }};
    CSL.Node.text = {build: function(state, target) {
        var variable,
            func,
            form,
            plural,
            id,
            num,
            number,
            formatter,
            firstoutput,
            specialdelimiter,
            label,
            myname,
            names,
            name,
            year,
            suffix,
            term,
            dp,
            len,
            pos,
            n,
            m,
            value,
            flag;
        if (this.postponed_macro) {
          var group_start = CSL.Util.cloneToken(this);
          group_start.name = "group";
          group_start.tokentype = CSL.START;
          CSL.Node.group.build.call(group_start, state, target);
          CSL.expandMacro.call(state, this, target);
          var group_end = CSL.Util.cloneToken(this);
          group_end.name = "group";
          group_end.tokentype = CSL.END;
          if (this.postponed_macro === 'juris-locator-label') {
            group_end.isJurisLocatorLabel = true;
          }
          CSL.Node.group.build.call(group_end, state, target);
        } else {
          CSL.Util.substituteStart.call(this, state, target);
          if (!this.variables_real) {
            this.variables_real = [];
          }
          if (!this.variables) {
            this.variables = [];
          }
          form = "long";
          plural = 0;
          if (this.strings.form) {
            form = this.strings.form;
          }
          if (this.strings.plural) {
            plural = this.strings.plural;
          }
          if ("citation-number" === this.variables_real[0] || "citation-label" === this.variables_real[0]) {
            if (this.variables_real[0] === "citation-number") {
              if (state.build.root === "citation") {
                state.opt.update_mode = CSL.NUMERIC;
              }
              if (state.build.root === "bibliography") {
                state.opt.bib_mode = CSL.NUMERIC;
              }
              if (state.build.area === "bibliography_sort") {
                state.opt.citation_number_sort_used = true;
              }
              if ("citation-number" === state[state.tmp.area].opt.collapse) {
                this.range_prefix = state.getTerm("citation-range-delimiter");
              }
              this.successor_prefix = state[state.build.area].opt.layout_delimiter;
              this.splice_prefix = state[state.build.area].opt.layout_delimiter;
              func = function(state, Item, item) {
                id = "" + Item.id;
                if (!state.tmp.just_looking) {
                  if (item && item["author-only"]) {
                    state.tmp.element_trace.replace("do-not-suppress-me");
                    var reference_term = state.getTerm("reference", "long", "singular");
                    if ("undefined" === typeof reference_term) {
                      reference_term = "reference";
                    }
                    term = CSL.Output.Formatters["capitalize-first"](state, reference_term);
                    state.output.append(term + " ");
                    state.tmp.last_element_trace = true;
                  }
                  if (item && item["suppress-author"]) {
                    if (state.tmp.last_element_trace) {
                      state.tmp.element_trace.replace("suppress-me");
                    }
                    state.tmp.last_element_trace = false;
                  }
                  num = state.registry.registry[id].seq;
                  if (state.opt.citation_number_slug) {
                    state.output.append(state.opt.citation_number_slug, this);
                  } else {
                    number = new CSL.NumericBlob(false, num, this, Item.id);
                    state.output.append(number, "literal");
                  }
                }
              };
              this.execs.push(func);
            } else if (this.variables_real[0] === "citation-label") {
              func = function(state, Item) {
                state.tmp.has_done_year_suffix = true;
                label = Item["citation-label"];
                if (!label) {
                  label = state.getCitationLabel(Item);
                }
                if (!state.tmp.just_looking) {
                  suffix = "";
                  if (state.registry.registry[Item.id] && state.registry.registry[Item.id].disambig.year_suffix !== false) {
                    num = parseInt(state.registry.registry[Item.id].disambig.year_suffix, 10);
                    suffix = state.fun.suffixator.format(num);
                  }
                  label += suffix;
                }
                state.output.append(label, this);
              };
              this.execs.push(func);
            }
          } else {
            if (this.strings.term) {
              func = function(state, Item, item) {
                var gender = state.opt.gender[Item.type];
                var term = this.strings.term;
                term = state.getTerm(term, form, plural, gender, false, ("accessed" === term));
                var myterm;
                if (term !== "") {
                  state.tmp.group_context.tip.term_intended = true;
                }
                CSL.UPDATE_GROUP_CONTEXT_CONDITION(state, term);
                if (!state.tmp.term_predecessor && !(state.opt["class"] === "in-text" && state.tmp.area === "citation")) {
                  myterm = CSL.Output.Formatters["capitalize-first"](state, term);
                } else {
                  myterm = term;
                }
                if (state.tmp.strip_periods) {
                  myterm = myterm.replace(/\./g, "");
                } else {
                  for (var i = 0,
                      ilen = this.decorations.length; i < ilen; i += 1) {
                    if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                      myterm = myterm.replace(/\./g, "");
                      break;
                    }
                  }
                }
                state.output.append(myterm, this);
              };
              this.execs.push(func);
              state.build.term = false;
              state.build.form = false;
              state.build.plural = false;
            } else if (this.variables_real.length) {
              func = function(state, Item, item) {
                var parallel_variable = this.variables[0];
                if (parallel_variable === "title" && (form === "short" || Item["title-short"])) {
                  parallel_variable = "title-short";
                }
                state.parallel.StartVariable(parallel_variable);
                state.parallel.AppendToVariable(Item[parallel_variable], parallel_variable);
                if (!state.tmp.group_context.tip.condition && Item[this.variables[0]]) {
                  state.tmp.just_did_number = false;
                }
              };
              this.execs.push(func);
              if (CSL.MULTI_FIELDS.indexOf(this.variables_real[0]) > -1 || ["language-name", "language-name-original"].indexOf(this.variables_real[0]) > -1) {
                var abbrevfam = this.variables[0];
                var abbrfall = false;
                var altvar = false;
                var transfall = false;
                if (form === "short") {
                  if (this.variables_real[0] === "container-title") {
                    altvar = "journalAbbreviation";
                  } else if (this.variables_real[0] === "title") {
                    altvar = "title-short";
                  }
                } else {
                  abbrevfam = false;
                }
                if (state.build.extension) {
                  transfall = true;
                } else {
                  transfall = true;
                  abbrfall = true;
                }
                func = state.transform.getOutputFunction(this.variables, abbrevfam, abbrfall, altvar, transfall);
              } else {
                if (CSL.CITE_FIELDS.indexOf(this.variables_real[0]) > -1) {
                  func = function(state, Item, item) {
                    if (item && item[this.variables[0]]) {
                      state.processNumber(this, item, this.variables[0], Item.type);
                      CSL.Util.outputNumericField(state, this.variables[0], Item.id);
                      state.output.append(value, this, false, false, true);
                      if (["locator", "locator-extra"].indexOf(this.variables_real[0]) > -1 && !state.tmp.just_looking) {
                        state.tmp.done_vars.push(this.variables_real[0]);
                      }
                    }
                  };
                } else if (["page", "page-first", "chapter-number", "collection-number", "edition", "issue", "number", "number-of-pages", "number-of-volumes", "volume", "year-suffix"].indexOf(this.variables_real[0]) > -1) {
                  if (this.variables_real[0] === "year-suffix") {
                    state.opt.has_year_suffix = true;
                    if (state[state.tmp.area].opt.collapse === "year-suffix-ranged") {
                      this.range_prefix = state.getTerm("citation-range-delimiter");
                    }
                    this.successor_prefix = state[state.build.area].opt.layout_delimiter;
                    if (state[state.tmp.area].opt["year-suffix-delimiter"]) {
                      this.successor_prefix = state[state.build.area].opt["year-suffix-delimiter"];
                    }
                  }
                  func = function(state, Item) {
                    state.processNumber(this, Item, this.variables[0], Item.type);
                    CSL.Util.outputNumericField(state, this.variables[0], Item.id);
                  };
                } else if (["URL", "DOI"].indexOf(this.variables_real[0]) > -1) {
                  func = function(state, Item) {
                    var value;
                    if (this.variables[0]) {
                      value = state.getVariable(Item, this.variables[0], form);
                      if (value) {
                        if (state.opt.development_extensions.wrap_url_and_doi) {
                          if (!this.decorations.length || this.decorations[0][0] !== "@" + this.variables[0]) {
                            this.decorations = [["@" + this.variables[0], "true"]].concat(this.decorations);
                          }
                        } else {
                          if (this.decorations.length && this.decorations[0][0] === "@" + this.variables[0]) {
                            this.decorations = this.decorations.slice(1);
                          }
                        }
                        state.output.append(value, this, false, false, true);
                      }
                    }
                  };
                } else if (this.variables_real[0] === "section") {
                  func = function(state, Item) {
                    var value;
                    value = state.getVariable(Item, this.variables[0], form);
                    if (value) {
                      state.output.append(value, this);
                    }
                  };
                } else if (this.variables_real[0] === "hereinafter") {
                  func = function(state, Item) {
                    var value = state.transform.abbrevs["default"]["hereinafter"][Item.id];
                    if (value) {
                      state.output.append(value, this);
                      state.tmp.group_context.tip.variable_success = true;
                    }
                  };
                } else {
                  func = function(state, Item) {
                    var value;
                    if (this.variables[0]) {
                      value = state.getVariable(Item, this.variables[0], form);
                      if (value) {
                        value = "" + value;
                        value = value.split("\\").join("");
                        state.output.append(value, this);
                      }
                    }
                  };
                }
              }
              this.execs.push(func);
              func = function(state, Item) {
                state.parallel.CloseVariable("text");
              };
              this.execs.push(func);
            } else if (this.strings.value) {
              func = function(state, Item) {
                state.tmp.group_context.tip.term_intended = true;
                CSL.UPDATE_GROUP_CONTEXT_CONDITION(state, this.strings.value, true);
                state.output.append(this.strings.value, this);
              };
              this.execs.push(func);
            }
          }
          target.push(this);
          CSL.Util.substituteEnd.call(this, state, target);
        }
      }};
    CSL.Attributes = {};
    CSL.Attributes["@genre"] = function(state, arg) {
      arg = arg.replace("-", " ");
      var func = function(Item, item) {
        var ret;
        if (arg === Item.genre) {
          return true;
        }
        return false;
      };
      this.tests.push(func);
    };
    CSL.Attributes["@disambiguate"] = function(state, arg) {
      if (arg === "true") {
        state.opt.has_disambiguate = true;
        var func = function(Item, item) {
          state.tmp.disambiguate_maxMax += 1;
          if (state.tmp.disambig_settings.disambiguate && state.tmp.disambiguate_count < state.tmp.disambig_settings.disambiguate) {
            state.tmp.disambiguate_count += 1;
            return true;
          }
          return false;
        };
        this.tests.push(func);
      } else if (arg === "check-ambiguity-and-backreference") {
        var func = function(Item, item) {
          if (state.registry.registry[Item.id].disambig.disambiguate && state.registry.registry[Item.id]["citation-count"] > 1) {
            return true;
          }
          return false;
        };
        this.tests.push(func);
      }
    };
    CSL.Attributes["@is-numeric"] = function(state, arg, joiner) {
      var variables = arg.split(/\s+/);
      var maketest = function(variable) {
        return function(Item, item) {
          var myitem = Item;
          if (["locator", "locator-extra"].indexOf(variable) > -1) {
            myitem = item;
          }
          if ("undefined" === typeof myitem) {
            return false;
          }
          if (CSL.NUMERIC_VARIABLES.indexOf(variable) > -1) {
            if (!state.tmp.shadow_numbers[variable]) {
              state.processNumber(false, myitem, variable, Item.type);
            }
            if (myitem[variable] && state.tmp.shadow_numbers[variable].numeric) {
              return true;
            }
          } else if (["title", "locator-extra", "version"].indexOf(variable) > -1) {
            if (myitem[variable]) {
              if (myitem[variable].slice(-1) === "" + parseInt(myitem[variable].slice(-1), 10)) {
                return true;
              }
            }
          }
          return false;
        };
      };
      for (var i = 0; i < variables.length; i += 1) {
        this.tests.push(maketest(variables[i]));
      }
    };
    CSL.Attributes["@is-uncertain-date"] = function(state, arg) {
      var variables = arg.split(/\s+/);
      var maketest = function(myvariable) {
        return function(Item, item) {
          if (Item[myvariable] && Item[myvariable].circa) {
            return true;
          } else {
            return false;
          }
        };
      };
      for (var i = 0,
          ilen = variables.length; i < ilen; i += 1) {
        this.tests.push(maketest(variables[i]));
      }
      ;
    };
    CSL.Attributes["@locator"] = function(state, arg) {
      var trylabels = arg.replace("sub verbo", "sub-verbo");
      trylabels = trylabels.split(/\s+/);
      var maketest = function(trylabel) {
        return function(Item, item) {
          var label;
          state.processNumber(false, item, "locator");
          label = state.tmp.shadow_numbers.locator.label;
          if (trylabel === label) {
            return true;
          } else {
            return false;
          }
        };
      };
      for (var i = 0,
          ilen = trylabels.length; i < ilen; i += 1) {
        this.tests.push(maketest(trylabels[i]));
      }
    };
    CSL.Attributes["@position"] = function(state, arg) {
      var tryposition;
      state.opt.update_mode = CSL.POSITION;
      state.parallel.use_parallels = null;
      var trypositions = arg.split(/\s+/);
      var maketest = function(tryposition) {
        return function(Item, item) {
          if (state.tmp.area === "bibliography") {
            return false;
          }
          if (item && "undefined" === typeof item.position) {
            item.position = 0;
          }
          if (item && typeof item.position === "number") {
            if (item.position === 0 && tryposition === 0) {
              return true;
            } else if (tryposition > 0 && item.position >= tryposition) {
              return true;
            }
          } else if (tryposition === 0) {
            return true;
          }
          return false;
        };
      };
      for (var i = 0,
          ilen = trypositions.length; i < ilen; i += 1) {
        var tryposition = trypositions[i];
        if (tryposition === "first") {
          tryposition = CSL.POSITION_FIRST;
        } else if (tryposition === "subsequent") {
          tryposition = CSL.POSITION_SUBSEQUENT;
        } else if (tryposition === "ibid") {
          tryposition = CSL.POSITION_IBID;
        } else if (tryposition === "ibid-with-locator") {
          tryposition = CSL.POSITION_IBID_WITH_LOCATOR;
        }
        if ("near-note" === tryposition) {
          this.tests.push(function(Item, item) {
            if (item && item.position >= CSL.POSITION_SUBSEQUENT && item["near-note"]) {
              return true;
            }
            return false;
          });
        } else if ("far-note" === tryposition) {
          this.tests.push(function(Item, item) {
            if (item && item.position == CSL.POSITION_SUBSEQUENT && !item["near-note"]) {
              return true;
            }
            return false;
          });
        } else {
          this.tests.push(maketest(tryposition));
        }
      }
    };
    CSL.Attributes["@type"] = function(state, arg) {
      var types = arg.split(/\s+/);
      var maketest = function(mytype) {
        return function(Item, item) {
          var ret = (Item.type === mytype);
          if (ret) {
            return true;
          } else {
            return false;
          }
        };
      };
      var tests = [];
      for (var i = 0,
          ilen = types.length; i < ilen; i += 1) {
        tests.push(maketest(types[i]));
      }
      this.tests.push(state.fun.match.any(this, state, tests));
    };
    CSL.Attributes["@variable"] = function(state, arg) {
      var func;
      this.variables = arg.split(/\s+/);
      this.variables_real = this.variables.slice();
      if ("label" === this.name && this.variables[0]) {
        this.strings.term = this.variables[0];
      } else if (["names", "date", "text", "number"].indexOf(this.name) > -1) {
        func = function(state, Item, item) {
          for (var i = this.variables.length - 1; i > -1; i += -1) {
            this.variables.pop();
          }
          for (var i = 0,
              ilen = this.variables_real.length; i < ilen; i++) {
            if (state.tmp.done_vars.indexOf(this.variables_real[i]) === -1 && !(item && Item.type === "legal_case" && item["suppress-author"] && this.variables_real[i] === "title")) {
              this.variables.push(this.variables_real[i]);
            }
            if (state.tmp.can_block_substitute) {
              state.tmp.done_vars.push(this.variables_real[i]);
            }
          }
        };
        this.execs.push(func);
        func = function(state, Item, item) {
          var mydate;
          output = false;
          for (var i = 0,
              ilen = this.variables.length; i < ilen; i++) {
            var variable = this.variables[i];
            if (["authority", "committee"].indexOf(variable) > -1 && "string" === typeof Item[variable] && "names" === this.name) {
              var creatorParent = {
                literal: Item[variable],
                multi: {_key: {}}
              };
              if (Item.multi && Item.multi._keys && Item.multi._keys[variable]) {
                for (var langTag in Item.multi._keys[variable]) {
                  var creatorChild = {literal: Item.multi._keys[variable][langTag]};
                  creatorParent.multi._key[langTag] = creatorChild;
                }
              }
              Item[variable] = [creatorParent];
            }
            if (this.strings.form === "short" && !Item[variable]) {
              if (variable === "title") {
                variable = "title-short";
              } else if (variable === "container-title") {
                variable = "journalAbbreviation";
              }
            }
            if (variable === "year-suffix") {
              output = true;
              break;
            } else if (CSL.DATE_VARIABLES.indexOf(variable) > -1) {
              if (state.opt.development_extensions.locator_date_and_revision && "locator-date" === variable) {
                output = true;
                break;
              }
              if (Item[variable]) {
                for (var key in Item[variable]) {
                  if (this.dateparts.indexOf(key) === -1 && "literal" !== key) {
                    continue;
                  }
                  if (Item[variable][key]) {
                    output = true;
                    break;
                  }
                }
                if (output) {
                  break;
                }
              }
            } else if ("locator" === variable) {
              if (item && item.locator) {
                output = true;
              }
              break;
            } else if ("locator-extra" === variable) {
              if (item && item["locator-extra"]) {
                output = true;
              }
              break;
            } else if (["citation-number", "citation-label"].indexOf(variable) > -1) {
              output = true;
              break;
            } else if ("first-reference-note-number" === variable) {
              if (item && item["first-reference-note-number"]) {
                output = true;
              }
              break;
            } else if ("hereinafter" === variable) {
              if (state.transform.abbrevs["default"].hereinafter[Item.id] && state.sys.getAbbreviation && Item.id) {
                output = true;
              }
              break;
            } else if ("object" === typeof Item[variable]) {
              if (Item[variable].length) {}
              break;
            } else if ("string" === typeof Item[variable] && Item[variable]) {
              output = true;
              break;
            } else if ("number" === typeof Item[variable]) {
              output = true;
              break;
            }
            if (output) {
              break;
            }
          }
          if (output) {
            for (var i = 0,
                ilen = this.variables_real.length; i < ilen; i++) {
              var variable = this.variables_real[i];
              if (variable !== "citation-number" || state.tmp.area !== "bibliography") {
                state.tmp.cite_renders_content = true;
              }
              state.tmp.group_context.tip.variable_success = true;
              if (state.tmp.can_substitute.value() && state.tmp.area === "bibliography" && "string" === typeof Item[variable]) {
                state.tmp.rendered_name.push(Item[variable]);
              }
            }
            state.tmp.can_substitute.replace(false, CSL.LITERAL);
          } else {
            state.tmp.group_context.tip.variable_attempt = true;
          }
        };
        this.execs.push(func);
      } else if (["if", "else-if", "condition"].indexOf(this.name) > -1) {
        var maketest = function(variable) {
          return function(Item, item) {
            var myitem = Item;
            if (item && ["locator", "locator-extra", "first-reference-note-number", "locator-date"].indexOf(variable) > -1) {
              myitem = item;
            }
            if (variable === "hereinafter" && state.sys.getAbbreviation && myitem.id) {
              if (state.transform.abbrevs["default"].hereinafter[myitem.id]) {
                return true;
              }
            } else if (myitem[variable]) {
              if ("number" === typeof myitem[variable] || "string" === typeof myitem[variable]) {
                return true;
              } else if ("object" === typeof myitem[variable]) {
                for (key in myitem[variable]) {
                  if (myitem[variable][key]) {
                    return true;
                  }
                }
              }
            }
            return false;
          };
        };
        for (var i = 0,
            ilen = this.variables.length; i < ilen; i += 1) {
          this.tests.push(maketest(this.variables[i]));
        }
      }
    };
    CSL.Attributes["@page"] = function(state, arg) {
      var trylabels = arg.replace("sub verbo", "sub-verbo");
      trylabels = trylabels.split(/\s+/);
      var maketest = function(trylabel) {
        return function(Item, item) {
          var label;
          state.processNumber(false, Item, "page", Item.type);
          if (!state.tmp.shadow_numbers.page.label) {
            label = "page";
          } else if (state.tmp.shadow_numbers.page.label === "sub verbo") {
            label = "sub-verbo";
          } else {
            label = state.tmp.shadow_numbers.page.label;
          }
          if (trylabel === label) {
            return true;
          } else {
            return false;
          }
        };
      };
      for (var i = 0,
          ilen = trylabels.length; i < ilen; i += 1) {
        this.tests.push(maketest(trylabels[i]));
      }
    };
    CSL.Attributes["@number"] = function(state, arg) {
      var trylabels = arg.replace("sub verbo", "sub-verbo");
      trylabels = trylabels.split(/\s+/);
      var maketest = function(trylabel) {
        return function(Item, item) {
          var label;
          state.processNumber(false, Item, "number", Item.type);
          if (!state.tmp.shadow_numbers.number.label) {
            label = "number";
          } else if (state.tmp.shadow_numbers.number.label === "sub verbo") {
            label = "sub-verbo";
          } else {
            label = state.tmp.shadow_numbers.number.label;
          }
          if (trylabel === label) {
            return true;
          } else {
            return false;
          }
        };
      };
      for (var i = 0,
          ilen = trylabels.length; i < ilen; i += 1) {
        this.tests.push(maketest(trylabels[i]));
      }
    };
    CSL.Attributes["@jurisdiction"] = function(state, arg) {
      var tryjurisdictions = arg.split(/\s+/);
      for (var i = 0,
          ilen = tryjurisdictions.length; i < ilen; i += 1) {
        tryjurisdictions[i] = tryjurisdictions[i].split(":");
      }
      var maketests = function(tryjurisdiction) {
        return function(Item, item) {
          if (!Item.jurisdiction) {
            return false;
          }
          var jurisdictions = Item.jurisdiction.split(":");
          for (var i = 0,
              ilen = jurisdictions.length; i < ilen; i += 1) {
            jurisdictions[i] = jurisdictions[i].split(":");
          }
          for (i = tryjurisdiction.length; i > 0; i += -1) {
            var tryjurisdictionStr = tryjurisdiction.slice(0, i).join(":");
            var jurisdiction = jurisdictions.slice(0, i).join(":");
            if (tryjurisdictionStr !== jurisdiction) {
              return false;
            }
          }
          return true;
        };
      };
      for (var i = 0,
          ilen = tryjurisdictions.length; i < ilen; i += 1) {
        var tryjurisdictionSlice = tryjurisdictions[i].slice();
        this.tests.push(maketests(tryjurisdictionSlice));
      }
    };
    CSL.Attributes["@context"] = function(state, arg) {
      var func = function(Item, item) {
        var area = state.tmp.area.slice(0, arg.length);
        if (area === arg) {
          return true;
        }
        return false;
      };
      this.tests.push(func);
    };
    CSL.Attributes["@has-year-only"] = function(state, arg) {
      var trydates = arg.split(/\s+/);
      var maketest = function(trydate) {
        return function(Item, item) {
          var date = Item[trydate];
          if (!date || date.month || date.season) {
            return false;
          } else {
            return true;
          }
        };
      };
      for (var i = 0,
          ilen = trydates.length; i < ilen; i += 1) {
        this.tests.push(maketest(trydates[i]));
      }
    };
    CSL.Attributes["@has-to-month-or-season"] = function(state, arg) {
      var trydates = arg.split(/\s+/);
      var maketest = function(trydate) {
        return function(Item, item) {
          var date = Item[trydate];
          if (!date || (!date.month && !date.season) || date.day) {
            return false;
          } else {
            return true;
          }
        };
      };
      for (var i = 0,
          ilen = trydates.length; i < ilen; i += 1) {
        this.tests.push(maketest(trydates[i]));
      }
    };
    CSL.Attributes["@has-day"] = function(state, arg) {
      var trydates = arg.split(/\s+/);
      var maketest = function(trydate) {
        return function(Item, item) {
          var date = Item[trydate];
          if (!date || !date.day) {
            return false;
          } else {
            return true;
          }
        };
      };
      for (var i = 0,
          ilen = trydates.length; i < ilen; i += 1) {
        this.tests.push(maketest(trydates[i]));
      }
      ;
    };
    CSL.Attributes["@subjurisdictions"] = function(state, arg) {
      var trysubjurisdictions = parseInt(arg, 10);
      var func = function(Item, item) {
        var subjurisdictions = 0;
        if (Item.jurisdiction) {
          subjurisdictions = Item.jurisdiction.split(":").length;
        }
        if (subjurisdictions) {
          subjurisdictions += -1;
        }
        if (subjurisdictions >= trysubjurisdictions) {
          return true;
        }
        return false;
      };
      this.tests.push(func);
    };
    CSL.Attributes["@is-plural"] = function(state, arg) {
      var func = function(Item, item) {
        var nameList = Item[arg];
        if (nameList && nameList.length) {
          var persons = 0;
          var institutions = 0;
          var last_is_person = false;
          for (var i = 0,
              ilen = nameList.length; i < ilen; i += 1) {
            if (state.opt.development_extensions.spoof_institutional_affiliations && (nameList[i].literal || (nameList[i].isInstitution && nameList[i].family && !nameList[i].given))) {
              institutions += 1;
              last_is_person = false;
            } else {
              persons += 1;
              last_is_person = true;
            }
          }
          if (persons > 1) {
            return true;
          } else if (institutions > 1) {
            return true;
          } else if (institutions && last_is_person) {
            return true;
          }
        }
        return false;
      };
      this.tests.push(func);
    };
    CSL.Attributes["@locale"] = function(state, arg) {
      var func,
          ret,
          len,
          pos,
          variable,
          myitem,
          langspec,
          lang,
          lst,
          i,
          ilen,
          fallback;
      var locale_default = state.opt["default-locale"][0];
      if (this.name === "layout") {
        this.locale_raw = arg;
        if (this.tokentype === CSL.START) {
          var locales = arg.split(/\s+/);
          var sort_locale = {};
          var localeMaster = CSL.localeResolve(locales[0], locale_default);
          if (localeMaster.generic) {
            sort_locale[localeMaster.generic] = localeMaster.best;
          } else {
            sort_locale[localeMaster.best] = localeMaster.best;
          }
          for (var i = 1,
              ilen = locales.length; i < ilen; i += 1) {
            var localeServant = CSL.localeResolve(locales[i], locale_default);
            if (localeServant.generic) {
              sort_locale[localeServant.generic] = localeMaster.best;
            } else {
              sort_locale[localeServant.best] = localeMaster.best;
            }
          }
          state[state.build.area].opt.sort_locales.push(sort_locale);
        }
        state.opt.has_layout_locale = true;
      } else {
        lst = arg.split(/\s+/);
        var locale_bares = [];
        for (i = 0, ilen = lst.length; i < ilen; i += 1) {
          lang = lst[i];
          langspec = CSL.localeResolve(lang, locale_default);
          if (lst[i].length === 2) {
            locale_bares.push(langspec.bare);
          }
          state.localeConfigure(langspec, true);
          lst[i] = langspec;
        }
        var locale_list = lst.slice();
        var maketest = function(locale_list, locale_default, locale_bares) {
          return function(Item, item) {
            var key,
                res;
            ret = [];
            res = false;
            var langspec = false;
            var lang;
            if (!Item.language) {
              lang = locale_default;
            } else {
              lang = Item.language;
            }
            langspec = CSL.localeResolve(lang, locale_default);
            for (i = 0, ilen = locale_list.length; i < ilen; i += 1) {
              if (langspec.best === locale_list[i].best) {
                res = true;
                break;
              }
            }
            if (!res && locale_bares.indexOf(langspec.bare) > -1) {
              res = true;
            }
            return res;
          };
        };
        this.tests.push(maketest(locale_list, locale_default, locale_bares));
      }
    };
    CSL.Attributes["@authority-residue"] = function(state, arg) {
      var maketest = function() {
        var succeed = (arg === "true") ? true : false;
        return function(Item, item) {
          if (!Item.authority || !Item.authority[0] || !Item.authority[0].family)
            return !succeed;
          var varLen = Item.authority[0].family.split("|").length;
          var stopLast = state.tmp.authority_stop_last;
          if ((varLen + stopLast) > 0) {
            return succeed;
          } else {
            return !succeed;
          }
        };
      };
      this.tests.push(maketest());
    };
    CSL.Attributes["@locale-internal"] = function(state, arg) {
      var func,
          ret,
          len,
          pos,
          variable,
          myitem,
          langspec,
          lang,
          lst,
          i,
          ilen,
          fallback;
      lst = arg.split(/\s+/);
      this.locale_bares = [];
      for (i = 0, ilen = lst.length; i < ilen; i += 1) {
        lang = lst[i];
        langspec = CSL.localeResolve(lang, state.opt["default-locale"][0]);
        if (lst[i].length === 2) {
          this.locale_bares.push(langspec.bare);
        }
        state.localeConfigure(langspec);
        lst[i] = langspec;
      }
      this.locale_default = state.opt["default-locale"][0];
      this.locale = lst[0].best;
      this.locale_list = lst.slice();
      var maketest = function(me) {
        return function(Item, item) {
          var key,
              res;
          ret = [];
          res = false;
          var langspec = false;
          if (Item.language) {
            lang = Item.language;
            langspec = CSL.localeResolve(lang, state.opt["default-locale"][0]);
            if (langspec.best === state.opt["default-locale"][0]) {
              langspec = false;
            }
          }
          if (langspec) {
            for (i = 0, ilen = me.locale_list.length; i < ilen; i += 1) {
              if (langspec.best === me.locale_list[i].best) {
                state.opt.lang = me.locale;
                state.tmp.last_cite_locale = me.locale;
                state.output.openLevel("empty");
                state.output.current.value().new_locale = me.locale;
                res = true;
                break;
              }
            }
            if (!res && me.locale_bares.indexOf(langspec.bare) > -1) {
              state.opt.lang = me.locale;
              state.tmp.last_cite_locale = me.locale;
              state.output.openLevel("empty");
              state.output.current.value().new_locale = me.locale;
              res = true;
            }
          }
          return res;
        };
      };
      var me = this;
      this.tests.push(maketest(me));
    };
    CSL.Attributes["@is-parallel"] = function(state, arg) {
      var values = arg.split(" ");
      for (var i = 0,
          ilen = values.length; i < ilen; i += 1) {
        if (values[i] === "true") {
          values[i] = true;
        } else if (values[i] === "false") {
          values[i] = false;
        }
      }
      this.strings.set_parallel_condition = values;
    };
    CSL.Attributes["@require"] = function(state, arg) {
      this.strings.require = arg;
    };
    CSL.Attributes["@reject"] = function(state, arg) {
      this.strings.reject = arg;
    };
    CSL.Attributes["@gender"] = function(state, arg) {
      this.gender = arg;
    };
    CSL.Attributes["@cslid"] = function(state, arg) {
      this.cslid = parseInt(arg, 10);
    };
    CSL.Attributes["@label-form"] = function(state, arg) {
      this.strings.label_form_override = arg;
    };
    CSL.Attributes["@part-separator"] = function(state, arg) {
      this.strings["part-separator"] = arg;
    };
    CSL.Attributes["@leading-noise-words"] = function(state, arg) {
      this["leading-noise-words"] = arg;
    };
    CSL.Attributes["@name-never-short"] = function(state, arg) {
      this["name-never-short"] = arg;
    };
    CSL.Attributes["@class"] = function(state, arg) {
      state.opt["class"] = arg;
    };
    CSL.Attributes["@version"] = function(state, arg) {
      state.opt.version = arg;
    };
    CSL.Attributes["@value"] = function(state, arg) {
      this.strings.value = arg;
    };
    CSL.Attributes["@name"] = function(state, arg) {
      this.strings.name = arg;
    };
    CSL.Attributes["@form"] = function(state, arg) {
      this.strings.form = arg;
    };
    CSL.Attributes["@date-parts"] = function(state, arg) {
      this.strings["date-parts"] = arg;
    };
    CSL.Attributes["@range-delimiter"] = function(state, arg) {
      this.strings["range-delimiter"] = arg;
    };
    CSL.Attributes["@macro"] = function(state, arg) {
      this.postponed_macro = arg;
    };
    CSL.Attributes["@term"] = function(state, arg) {
      if (arg === "sub verbo") {
        this.strings.term = "sub-verbo";
      } else {
        this.strings.term = arg;
      }
    };
    CSL.Attributes["@xmlns"] = function(state, arg) {};
    CSL.Attributes["@lang"] = function(state, arg) {
      if (arg) {
        state.build.lang = arg;
      }
    };
    CSL.Attributes["@lingo"] = function(state, arg) {};
    CSL.Attributes["@macro-has-date"] = function(state, arg) {
      this["macro-has-date"] = true;
    };
    CSL.Attributes["@suffix"] = function(state, arg) {
      this.strings.suffix = arg;
    };
    CSL.Attributes["@prefix"] = function(state, arg) {
      this.strings.prefix = arg;
    };
    CSL.Attributes["@delimiter"] = function(state, arg) {
      if ("name" == this.name) {
        this.strings.name_delimiter = arg;
      } else {
        this.strings.delimiter = arg;
      }
    };
    CSL.Attributes["@match"] = function(state, arg) {
      this.match = arg;
    };
    CSL.Attributes["@names-min"] = function(state, arg) {
      var val = parseInt(arg, 10);
      if (state[state.build.area].opt.max_number_of_names < val) {
        state[state.build.area].opt.max_number_of_names = val;
      }
      this.strings["et-al-min"] = val;
    };
    CSL.Attributes["@names-use-first"] = function(state, arg) {
      this.strings["et-al-use-first"] = parseInt(arg, 10);
    };
    CSL.Attributes["@names-use-last"] = function(state, arg) {
      if (arg === "true") {
        this.strings["et-al-use-last"] = true;
      } else {
        this.strings["et-al-use-last"] = false;
      }
    };
    CSL.Attributes["@sort"] = function(state, arg) {
      if (arg === "descending") {
        this.strings.sort_direction = CSL.DESCENDING;
      }
    };
    CSL.Attributes["@plural"] = function(state, arg) {
      if ("always" === arg || "true" === arg) {
        this.strings.plural = 1;
      } else if ("never" === arg || "false" === arg) {
        this.strings.plural = 0;
      } else if ("contextual" === arg) {
        this.strings.plural = false;
      }
    };
    CSL.Attributes["@has-publisher-and-publisher-place"] = function(state, arg) {
      this.strings["has-publisher-and-publisher-place"] = true;
    };
    CSL.Attributes["@publisher-delimiter-precedes-last"] = function(state, arg) {
      this.strings["publisher-delimiter-precedes-last"] = arg;
    };
    CSL.Attributes["@publisher-delimiter"] = function(state, arg) {
      this.strings["publisher-delimiter"] = arg;
    };
    CSL.Attributes["@publisher-and"] = function(state, arg) {
      this.strings["publisher-and"] = arg;
    };
    CSL.Attributes["@newdate"] = function(state, arg) {};
    CSL.Attributes["@givenname-disambiguation-rule"] = function(state, arg) {
      if (CSL.GIVENNAME_DISAMBIGUATION_RULES.indexOf(arg) > -1) {
        state.citation.opt["givenname-disambiguation-rule"] = arg;
      }
    };
    CSL.Attributes["@collapse"] = function(state, arg) {
      if (arg) {
        state[this.name].opt.collapse = arg;
      }
    };
    CSL.Attributes["@cite-group-delimiter"] = function(state, arg) {
      if (arg) {
        state[state.tmp.area].opt.cite_group_delimiter = arg;
      }
    };
    CSL.Attributes["@names-delimiter"] = function(state, arg) {
      state.setOpt(this, "names-delimiter", arg);
    };
    CSL.Attributes["@name-form"] = function(state, arg) {
      state.setOpt(this, "name-form", arg);
    };
    CSL.Attributes["@subgroup-delimiter"] = function(state, arg) {
      this.strings["subgroup-delimiter"] = arg;
    };
    CSL.Attributes["@subgroup-delimiter-precedes-last"] = function(state, arg) {
      this.strings["subgroup-delimiter-precedes-last"] = arg;
    };
    CSL.Attributes["@name-delimiter"] = function(state, arg) {
      state.setOpt(this, "name-delimiter", arg);
    };
    CSL.Attributes["@et-al-min"] = function(state, arg) {
      var val = parseInt(arg, 10);
      if (state[state.build.area].opt.max_number_of_names < val) {
        state[state.build.area].opt.max_number_of_names = val;
      }
      state.setOpt(this, "et-al-min", val);
    };
    CSL.Attributes["@et-al-use-first"] = function(state, arg) {
      state.setOpt(this, "et-al-use-first", parseInt(arg, 10));
    };
    CSL.Attributes["@et-al-use-last"] = function(state, arg) {
      if (arg === "true") {
        state.setOpt(this, "et-al-use-last", true);
      } else {
        state.setOpt(this, "et-al-use-last", false);
      }
    };
    CSL.Attributes["@et-al-subsequent-min"] = function(state, arg) {
      var val = parseInt(arg, 10);
      if (state[state.build.area].opt.max_number_of_names < val) {
        state[state.build.area].opt.max_number_of_names = val;
      }
      state.setOpt(this, "et-al-subsequent-min", val);
    };
    CSL.Attributes["@et-al-subsequent-use-first"] = function(state, arg) {
      state.setOpt(this, "et-al-subsequent-use-first", parseInt(arg, 10));
    };
    CSL.Attributes["@suppress-min"] = function(state, arg) {
      this.strings["suppress-min"] = parseInt(arg, 10);
    };
    CSL.Attributes["@suppress-max"] = function(state, arg) {
      this.strings["suppress-max"] = parseInt(arg, 10);
    };
    CSL.Attributes["@and"] = function(state, arg) {
      state.setOpt(this, "and", arg);
    };
    CSL.Attributes["@delimiter-precedes-last"] = function(state, arg) {
      state.setOpt(this, "delimiter-precedes-last", arg);
    };
    CSL.Attributes["@delimiter-precedes-et-al"] = function(state, arg) {
      state.setOpt(this, "delimiter-precedes-et-al", arg);
    };
    CSL.Attributes["@initialize-with"] = function(state, arg) {
      state.setOpt(this, "initialize-with", arg);
    };
    CSL.Attributes["@initialize"] = function(state, arg) {
      if (arg === "false") {
        state.setOpt(this, "initialize", false);
      }
    };
    CSL.Attributes["@name-as-reverse-order"] = function(state, arg) {
      this["name-as-reverse-order"] = arg;
    };
    CSL.Attributes["@name-as-sort-order"] = function(state, arg) {
      if (this.name === "style-options") {
        this["name-as-sort-order"] = arg;
      } else {
        state.setOpt(this, "name-as-sort-order", arg);
      }
    };
    CSL.Attributes["@sort-separator"] = function(state, arg) {
      state.setOpt(this, "sort-separator", arg);
    };
    CSL.Attributes["@year-suffix-delimiter"] = function(state, arg) {
      state[this.name].opt["year-suffix-delimiter"] = arg;
    };
    CSL.Attributes["@after-collapse-delimiter"] = function(state, arg) {
      state[this.name].opt["after-collapse-delimiter"] = arg;
    };
    CSL.Attributes["@subsequent-author-substitute"] = function(state, arg) {
      state[this.name].opt["subsequent-author-substitute"] = arg;
    };
    CSL.Attributes["@subsequent-author-substitute-rule"] = function(state, arg) {
      state[this.name].opt["subsequent-author-substitute-rule"] = arg;
    };
    CSL.Attributes["@disambiguate-add-names"] = function(state, arg) {
      if (arg === "true") {
        state.opt["disambiguate-add-names"] = true;
      }
    };
    CSL.Attributes["@disambiguate-add-givenname"] = function(state, arg) {
      if (arg === "true") {
        state.opt["disambiguate-add-givenname"] = true;
      }
    };
    CSL.Attributes["@disambiguate-add-year-suffix"] = function(state, arg) {
      if (arg === "true" && state.opt.xclass !== "numeric") {
        state.opt["disambiguate-add-year-suffix"] = true;
      }
    };
    CSL.Attributes["@second-field-align"] = function(state, arg) {
      if (arg === "flush" || arg === "margin") {
        state[this.name].opt["second-field-align"] = arg;
      }
    };
    CSL.Attributes["@hanging-indent"] = function(state, arg) {
      if (arg === "true") {
        state[this.name].opt.hangingindent = 2;
      }
    };
    CSL.Attributes["@line-spacing"] = function(state, arg) {
      if (arg && arg.match(/^[.0-9]+$/)) {
        state[this.name].opt["line-spacing"] = parseFloat(arg, 10);
      }
    };
    CSL.Attributes["@entry-spacing"] = function(state, arg) {
      if (arg && arg.match(/^[.0-9]+$/)) {
        state[this.name].opt["entry-spacing"] = parseFloat(arg, 10);
      }
    };
    CSL.Attributes["@near-note-distance"] = function(state, arg) {
      state[this.name].opt["near-note-distance"] = parseInt(arg, 10);
    };
    CSL.Attributes["@text-case"] = function(state, arg) {
      var func = function(state, Item) {
        if (arg === "normal") {
          this.text_case_normal = true;
        } else {
          this.strings["text-case"] = arg;
          if (arg === "title") {
            var m = false;
            var default_locale = state.opt["default-locale"][0].slice(0, 2);
            if (Item.jurisdiction) {
              this.strings["text-case"] = "passthrough";
            }
          }
        }
      };
      this.execs.push(func);
    };
    CSL.Attributes["@page-range-format"] = function(state, arg) {
      state.opt["page-range-format"] = arg;
    };
    CSL.Attributes["@year-range-format"] = function(state, arg) {
      state.opt["year-range-format"] = arg;
    };
    CSL.Attributes["@default-locale"] = function(state, arg) {
      var lst,
          len,
          pos,
          m,
          ret;
      m = arg.match(/-x-(sort|translit|translat)-/g);
      if (m) {
        for (pos = 0, len = m.length; pos < len; pos += 1) {
          m[pos] = m[pos].replace(/^-x-/, "").replace(/-$/, "");
        }
      }
      lst = arg.split(/-x-(?:sort|translit|translat)-/);
      ret = [lst[0]];
      for (pos = 1, len = lst.length; pos < len; pos += 1) {
        ret.push(m[pos - 1]);
        ret.push(lst[pos]);
      }
      lst = ret.slice();
      len = lst.length;
      for (pos = 1; pos < len; pos += 2) {
        state.opt[("locale-" + lst[pos])].push(lst[(pos + 1)].replace(/^\s*/g, "").replace(/\s*$/g, ""));
      }
      if (lst.length) {
        state.opt["default-locale"] = lst.slice(0, 1);
      } else {
        state.opt["default-locale"] = ["en"];
      }
    };
    CSL.Attributes["@default-locale-sort"] = function(state, arg) {
      var lst,
          len,
          pos,
          m,
          ret;
      state.opt["default-locale-sort"] = arg;
    };
    CSL.Attributes["@demote-non-dropping-particle"] = function(state, arg) {
      state.opt["demote-non-dropping-particle"] = arg;
    };
    CSL.Attributes["@initialize-with-hyphen"] = function(state, arg) {
      if (arg === "false") {
        state.opt["initialize-with-hyphen"] = false;
      }
    };
    CSL.Attributes["@institution-parts"] = function(state, arg) {
      this.strings["institution-parts"] = arg;
    };
    CSL.Attributes["@if-short"] = function(state, arg) {
      if (arg === "true") {
        this.strings["if-short"] = true;
      }
    };
    CSL.Attributes["@substitute-use-first"] = function(state, arg) {
      this.strings["substitute-use-first"] = parseInt(arg, 10);
    };
    CSL.Attributes["@use-first"] = function(state, arg) {
      this.strings["use-first"] = parseInt(arg, 10);
    };
    CSL.Attributes["@stop-last"] = function(state, arg) {
      this.strings["stop-last"] = parseInt(arg, 10) * -1;
    };
    CSL.Attributes["@use-last"] = function(state, arg) {
      this.strings["use-last"] = parseInt(arg, 10);
    };
    CSL.Attributes["@reverse-order"] = function(state, arg) {
      if ("true" === arg) {
        this.strings["reverse-order"] = true;
      }
    };
    CSL.Attributes["@display"] = function(state, arg) {
      state.opt.using_display = true;
      this.strings.cls = arg;
    };
    CSL.Stack = function(val, literal) {
      this.mystack = [];
      if (literal || val) {
        this.mystack.push(val);
      }
      this.tip = this.mystack[0];
    };
    CSL.Stack.prototype.push = function(val, literal) {
      if (literal || val) {
        this.mystack.push(val);
      } else {
        this.mystack.push("");
      }
      this.tip = this.mystack[this.mystack.length - 1];
    };
    CSL.Stack.prototype.clear = function() {
      this.mystack = [];
      this.tip = {};
    };
    CSL.Stack.prototype.replace = function(val, literal) {
      if (this.mystack.length === 0) {
        throw "Internal CSL processor error: attempt to replace nonexistent stack item with " + val;
      }
      if (literal || val) {
        this.mystack[(this.mystack.length - 1)] = val;
      } else {
        this.mystack[(this.mystack.length - 1)] = "";
      }
      this.tip = this.mystack[this.mystack.length - 1];
    };
    CSL.Stack.prototype.pop = function() {
      var ret = this.mystack.pop();
      if (this.mystack.length) {
        this.tip = this.mystack[this.mystack.length - 1];
      } else {
        this.tip = {};
      }
      return ret;
    };
    CSL.Stack.prototype.value = function() {
      return this.mystack.slice(-1)[0];
    };
    CSL.Stack.prototype.length = function() {
      return this.mystack.length;
    };
    CSL.Parallel = function(state) {
      this.state = state;
      this.sets = new CSL.Stack([]);
      this.try_cite = true;
      this.use_parallels = false;
      this.midVars = ["section", "volume", "container-title", "collection-number", "issue", "page-first", "page", "number"];
      this.ignoreVarsLawGeneral = ["first-reference-note-number", "locator", "label", "page-first", "page", "genre"];
      this.ignoreVarsLawProceduralHistory = ["issued", "first-reference-note-number", "locator", "label", "page-first", "page", "genre", "jurisdiction"];
      this.ignoreVarsOrders = ["first-reference-note-number"];
      this.ignoreVarsOther = ["first-reference-note-number", "locator", "label", "section", "page-first", "page"];
    };
    CSL.Parallel.prototype.isMid = function(variable) {
      return (this.midVars.indexOf(variable) > -1);
    };
    CSL.Parallel.prototype.StartCitation = function(sortedItems, out) {
      this.parallel_conditional_blobs_list = [];
      if (this.use_parallels) {
        this.sortedItems = sortedItems;
        this.sortedItemsPos = -1;
        this.sets.clear();
        this.sets.push([]);
        this.in_series = true;
        this.delim_counter = 0;
        this.delim_pointers = [];
        if (out) {
          this.out = out;
        } else {
          this.out = this.state.output.queue;
        }
        this.master_was_neutral_cite = true;
      }
    };
    CSL.Parallel.prototype.StartCite = function(Item, item, prevItemID) {
      var position,
          len,
          pos,
          x,
          curr,
          master,
          last_id,
          prev_locator,
          curr_locator,
          is_master,
          parallel;
      if (this.use_parallels) {
        if (this.sets.value().length && this.sets.value()[0].itemId == Item.id) {
          this.ComposeSet();
        }
        this.sortedItemsPos += 1;
        if (item) {
          position = item.position;
        }
        this.try_cite = true;
        var has_required_var = false;
        for (var i = 0,
            ilen = CSL.PARALLEL_MATCH_VARS.length; i < ilen; i += 1) {
          if (Item[CSL.PARALLEL_MATCH_VARS[i]]) {
            has_required_var = true;
            break;
          }
        }
        var basics_ok = true;
        var last_cite = this.sets.value().slice(-1)[0];
        if (last_cite && last_cite.Item) {
          var lastJuris = last_cite.Item.jurisdiction ? last_cite.Item.jurisdiction.split(":")[0] : "";
          var thisJuris = Item.jurisdiction ? Item.jurisdiction.split(":")[0] : "";
          if (last_cite.Item.title !== Item.title) {
            basics_ok = false;
          } else if (lastJuris !== thisJuris) {
            basics_ok = false;
          } else if (last_cite.Item.type !== Item.type) {
            basics_ok = false;
          } else if (["article-journal", "article-magazine"].indexOf(Item.type) > -1) {
            if (!this.state.opt.development_extensions.handle_parallel_articles || last_cite.Item["container-title"] !== Item["container-title"]) {
              basics_ok = false;
            }
          }
        }
        if (!basics_ok || !has_required_var || CSL.PARALLEL_TYPES.indexOf(Item.type) === -1) {
          this.try_cite = true;
          if (this.in_series) {
            this.in_series = false;
          }
        }
        this.cite = {};
        this.cite.front = [];
        this.cite.mid = [];
        this.cite.back = [];
        this.cite.front_collapse = {};
        this.cite.back_forceme = [];
        this.cite.position = position;
        this.cite.Item = Item;
        this.cite.itemId = "" + Item.id;
        this.cite.prevItemID = "" + prevItemID;
        this.target = "front";
        if (["treaty"].indexOf(Item.type) > -1) {
          this.ignoreVars = this.ignoreVarsOrders;
        } else if (["article-journal", "article-magazine"].indexOf(Item.type) > -1) {
          this.ignoreVars = this.ignoreVarsOther;
        } else if (item && item.prefix) {
          this.ignoreVars = this.ignoreVarsLawProceduralHistory;
          this.cite.useProceduralHistory = true;
          var prev = this.sets.value()[(this.sets.value().length - 1)];
          if (prev && prev.back) {
            for (var i = prev.back.length - 1; i > -1; i += -1) {
              if (prev.back[i] && prev[prev.back[i]]) {
                delete prev[prev.back[i]];
              }
            }
          }
        } else {
          this.ignoreVars = this.ignoreVarsLawGeneral;
        }
        if (this.sortedItems && this.sortedItemsPos > 0 && this.sortedItemsPos < this.sortedItems.length) {
          curr = this.sortedItems[this.sortedItemsPos][1];
          last_id = "" + this.sortedItems[(this.sortedItemsPos - 1)][1].id;
          master = this.state.registry.registry[last_id].parallel;
          prev_locator = false;
          if (master == curr.id) {
            len = this.sortedItemsPos - 1;
            for (pos = len; pos > -1; pos += -1) {
              if (this.sortedItems[pos][1].id == Item.id) {
                prev_locator = this.sortedItems[pos][1].locator;
                break;
              }
            }
            curr_locator = this.sortedItems[this.sortedItemsPos][1].locator;
            if (!prev_locator && curr_locator) {
              curr.position = CSL.POSITION_IBID_WITH_LOCATOR;
            } else if (curr_locator === prev_locator) {
              curr.position = CSL.POSITION_IBID;
            } else {
              curr.position = CSL.POSITION_IBID_WITH_LOCATOR;
            }
          }
        } else if (this.state.registry.registry[Item.id]) {
          this.state.registry.registry[Item.id].parallel = false;
        } else {
          this.try_cite = false;
          this.force_collapse = false;
          return;
        }
        this.force_collapse = false;
        if (this.state.registry.registry[Item.id].parallel) {
          this.force_collapse = true;
        }
      }
    };
    CSL.Parallel.prototype.StartVariable = function(variable, real_variable) {
      if (this.use_parallels && (this.try_cite || this.force_collapse)) {
        if (variable === "names") {
          this.variable = variable + ":" + this.target;
        } else {
          this.variable = variable;
        }
        if (this.ignoreVars.indexOf(variable) > -1) {
          return;
        }
        if (variable === "container-title" && this.sets.value().length === 0) {
          this.master_was_neutral_cite = false;
        }
        this.data = {};
        this.data.value = "";
        this.data.blobs = [];
        var is_mid = this.isMid(variable);
        if (real_variable === "authority" && this.variable === "names:front" && this.sets.value().length) {
          var prev = this.sets.value()[(this.sets.value().length - 1)].Item;
          var thisAuthority = false;
          if (this.cite.Item.authority && this.cite.Item.authority.length) {
            thisAuthority = this.cite.Item.authority[0].literal;
          }
          var thatAuthority = false;
          if (prev.authority && prev.authority.length) {
            thatAuthority = prev.authority[0].literal;
          }
          if (thisAuthority !== thatAuthority) {
            this.try_cite = true;
            this.in_series = false;
          }
        } else if (this.target === "front" && is_mid) {
          this.target = "mid";
        } else if (this.target === "mid" && !is_mid && this.cite.Item.title && variable !== "names") {
          this.target = "back";
        } else if (this.target === "back" && is_mid) {
          this.try_cite = true;
          this.in_series = false;
        }
        if (variable === "number") {
          this.cite.front.push(this.variable);
        } else if (CSL.PARALLEL_COLLAPSING_MID_VARSET.indexOf(variable) > -1) {
          if (["article-journal", "article-magazine"].indexOf(this.cite.Item.type) > -1) {
            this.cite.mid.push(this.variable);
          } else {
            this.cite.front.push(this.variable);
          }
        } else {
          this.cite[this.target].push(this.variable);
        }
      }
    };
    CSL.Parallel.prototype.AppendBlobPointer = function(blob) {
      if (this.use_parallels) {
        if (this.ignoreVars.indexOf(this.variable) > -1) {
          return;
        }
        if (this.use_parallels && (this.force_collapse || this.try_cite)) {
          if (["article-journal", "article-magazine"].indexOf(this.cite.Item.type) > -1) {
            if (["volume", "page", "page-first", "issue"].indexOf(this.variable) > -1) {
              return;
            }
            if ("container-title" === this.variable && this.cite.mid.length > 1) {
              return;
            }
          }
          if (this.variable && (this.try_cite || this.force_collapse) && blob && blob.blobs) {
            if (!(this.cite.useProceduralHistory && this.target === "back")) {
              this.data.blobs.push([blob, blob.blobs.length]);
            }
          }
        }
      }
    };
    CSL.Parallel.prototype.AppendToVariable = function(str, varname) {
      if (this.use_parallels) {
        if (this.ignoreVars.indexOf(this.variable) > -1) {
          return;
        }
        if (this.try_cite || this.force_collapse) {
          if (this.target !== "back" || true) {
            this.data.value += "::" + str;
          } else {
            var prev = this.sets.value()[(this.sets.value().length - 1)];
            if (prev) {
              if (prev[this.variable]) {
                if (prev[this.variable].value) {
                  this.data.value += "::" + str;
                }
              }
            }
          }
        }
      }
    };
    CSL.Parallel.prototype.CloseVariable = function() {
      if (this.use_parallels) {
        if (this.ignoreVars.indexOf(this.variable) > -1) {
          return;
        }
        if (this.try_cite || this.force_collapse) {
          this.cite[this.variable] = this.data;
          if (this.sets.value().length > 0) {
            var prev = this.sets.value()[(this.sets.value().length - 1)];
            if (this.target === "front" && this.variable === "issued") {
              if (this.data.value && this.master_was_neutral_cite) {
                this.target = "mid";
              }
            }
            if (this.target === "front") {
              if ((prev[this.variable] || this.data.value) && (!prev[this.variable] || this.data.value !== prev[this.variable].value)) {
                if ("issued" !== this.variable) {
                  this.in_series = false;
                }
              }
            } else if (this.target === "mid") {
              if (CSL.PARALLEL_COLLAPSING_MID_VARSET.indexOf(this.variable) > -1) {
                if (prev[this.variable]) {
                  if (prev[this.variable].value === this.data.value) {
                    this.cite.front_collapse[this.variable] = true;
                  } else {
                    this.cite.front_collapse[this.variable] = false;
                  }
                } else {
                  this.cite.front_collapse[this.variable] = false;
                }
              }
            } else if (this.target === "back") {
              if (prev[this.variable]) {
                if (this.data.value !== prev[this.variable].value && this.sets.value().slice(-1)[0].back_forceme.indexOf(this.variable) === -1) {
                  this.in_series = false;
                }
              }
            }
          }
        }
        this.variable = false;
      }
    };
    CSL.Parallel.prototype.CloseCite = function() {
      var x,
          pos,
          len,
          has_issued,
          use_journal_info,
          volume_pos,
          container_title_pos,
          section_pos;
      if (this.use_parallels && (this.force_collapse || this.try_cite)) {
        use_journal_info = false;
        if (!this.cite.front_collapse["container-title"]) {
          use_journal_info = true;
        }
        if (this.cite.front_collapse.volume === false) {
          use_journal_info = true;
        }
        if (this.cite.front_collapse["collection-number"] === false) {
          use_journal_info = true;
        }
        if (this.cite.front_collapse.section === false) {
          use_journal_info = true;
        }
        if (use_journal_info) {
          this.cite.use_journal_info = true;
          section_pos = this.cite.front.indexOf("section");
          if (section_pos > -1) {
            this.cite.front = this.cite.front.slice(0, section_pos).concat(this.cite.front.slice(section_pos + 1));
          }
          volume_pos = this.cite.front.indexOf("volume");
          if (volume_pos > -1) {
            this.cite.front = this.cite.front.slice(0, volume_pos).concat(this.cite.front.slice(volume_pos + 1));
          }
          container_title_pos = this.cite.front.indexOf("container-title");
          if (container_title_pos > -1) {
            this.cite.front = this.cite.front.slice(0, container_title_pos).concat(this.cite.front.slice(container_title_pos + 1));
          }
          collection_number_pos = this.cite.front.indexOf("collection-number");
          if (collection_number_pos > -1) {
            this.cite.front = this.cite.front.slice(0, collection_number_pos).concat(this.cite.front.slice(collection_number_pos + 1));
          }
        }
        if (!this.in_series && !this.force_collapse) {
          this.ComposeSet(true);
        }
        if (this.sets.value().length === 0) {
          has_date = false;
          for (pos = 0, len = this.cite.back.length; pos < len; pos += 1) {
            x = this.cite.back[pos];
            if (x === "issued" && this.cite["issued"] && this.cite["issued"].value) {
              has_date = true;
              break;
            }
          }
          if (!has_date) {
            this.cite.back_forceme.push("issued");
          }
        } else {
          var idx = this.cite.front.indexOf("issued");
          if (idx === -1 || this.master_was_neutral_cite) {
            this.cite.back_forceme = this.sets.value().slice(-1)[0].back_forceme;
          }
          if (idx > -1) {
            var prev = this.sets.value()[this.sets.value().length - 1];
            if (!prev["issued"]) {
              this.cite.front = this.cite.front.slice(0, idx).concat(this.cite.front.slice(idx + 1));
            }
          }
          if (this.master_was_neutral_cite && this.cite.mid.indexOf("names:mid") > -1) {
            this.cite.front.push("names:mid");
          }
        }
        this.sets.value().push(this.cite);
      }
    };
    CSL.Parallel.prototype.ComposeSet = function(next_output_in_progress) {
      var cite,
          pos,
          master,
          len;
      if (this.use_parallels && (this.force_collapse || this.try_cite)) {
        var lengthCheck = this.sets.value().length;
        if (this.sets.value().length === 1) {
          if (!this.in_series) {
            this.sets.value().pop();
            this.delim_counter += 1;
          }
        } else {
          len = this.sets.value().length;
          for (pos = 0; pos < len; pos += 1) {
            cite = this.sets.value()[pos];
            if (pos === 0) {
              this.delim_counter += 1;
            } else {
              if (!cite.Item.title && cite.use_journal_info) {
                this.delim_pointers.push(false);
              } else {
                this.delim_pointers.push(this.delim_counter);
              }
              this.delim_counter += 1;
            }
            if (CSL.POSITION_FIRST === cite.position) {
              if (pos === 0) {
                this.state.registry.registry[cite.itemId].master = true;
                this.state.registry.registry[cite.itemId].siblings = [];
                this.state.registry.registry[cite.itemId].parallel = false;
              } else {
                if (cite.prevItemID) {
                  if (!this.state.registry.registry[cite.prevItemID].parallel) {
                    this.state.registry.registry[cite.itemId].parallel = cite.prevItemID;
                  } else {
                    this.state.registry.registry[cite.itemId].parallel = this.state.registry.registry[cite.prevItemID].parallel;
                  }
                  this.state.registry.registry[cite.itemId].siblings = this.state.registry.registry[cite.prevItemID].siblings;
                  if (!this.state.registry.registry[cite.itemId].siblings) {
                    this.state.registry.registry[cite.itemId].siblings = [];
                    CSL.debug("WARNING: adding missing siblings array to registry object");
                  }
                  this.state.registry.registry[cite.itemId].siblings.push(cite.itemId);
                }
              }
            }
          }
          this.sets.push([]);
        }
        if (lengthCheck < 2) {
          this.purgeGroupsIfParallel(false);
        } else {
          this.purgeGroupsIfParallel(true);
        }
        this.in_series = true;
      }
    };
    CSL.Parallel.prototype.PruneOutputQueue = function() {
      var len,
          pos,
          series,
          ppos,
          llen,
          cite;
      if (this.use_parallels) {
        len = this.sets.mystack.length;
        for (pos = 0; pos < len; pos += 1) {
          series = this.sets.mystack[pos];
          if (series.length > 1) {
            llen = series.length;
            for (ppos = 0; ppos < llen; ppos += 1) {
              cite = series[ppos];
              if (ppos === 0) {
                this.purgeVariableBlobs(cite, cite.back);
              } else if (ppos === (series.length - 1)) {
                this.purgeVariableBlobs(cite, cite.front.concat(cite.back_forceme));
              } else {
                this.purgeVariableBlobs(cite, cite.front.concat(cite.back));
              }
            }
          }
        }
      }
    };
    CSL.Parallel.prototype.purgeVariableBlobs = function(cite, varnames) {
      var len,
          pos,
          varname,
          b,
          llen,
          ppos,
          out;
      if (this.use_parallels) {
        out = this.state.output.current.value();
        if ("undefined" === typeof out.length) {
          out = out.blobs;
        }
        for (pos = 0, len = this.delim_pointers.length; pos < len; pos += 1) {
          ppos = this.delim_pointers[pos];
          if (ppos !== false) {
            out[ppos].parallel_delimiter = ", ";
          }
        }
        len = varnames.length - 1;
        for (pos = len; pos > -1; pos += -1) {
          varname = varnames[pos];
          if (cite[varname]) {
            llen = cite[varname].blobs.length - 1;
            for (ppos = llen; ppos > -1; ppos += -1) {
              b = cite[varname].blobs[ppos];
              b[0].blobs = b[0].blobs.slice(0, b[1]).concat(b[0].blobs.slice((b[1] + 1)));
              this.state.tmp.has_purged_parallel = true;
              if (b[0] && b[0].strings && "string" == typeof b[0].strings.oops && b[0].parent && b[0].parent) {
                b[0].parent.parent.strings.delimiter = b[0].strings.oops;
              }
            }
          }
        }
      }
    };
    CSL.Parallel.prototype.purgeGroupsIfParallel = function(original_condition) {
      for (var i = this.parallel_conditional_blobs_list.length - 1; i > -1; i += -1) {
        var obj = this.parallel_conditional_blobs_list[i];
        var purgeme = true;
        for (var j = 0,
            jlen = obj.conditions.length; j < jlen; j += 1) {
          if (!(!obj.conditions[j] === !!original_condition || ("master" === obj.conditions[j] && !this.state.registry.registry[obj.id].master) || ("servant" === obj.conditions[j] && !this.state.registry.registry[obj.id].parallel))) {
            var purgeme = false;
            break;
          }
        }
        if (purgeme) {
          var buffer = [];
          while (obj.blobs.length > obj.pos) {
            buffer.push(obj.blobs.pop());
          }
          if (buffer.length) {
            buffer.pop();
          }
          while (buffer.length) {
            obj.blobs.push(buffer.pop());
          }
        }
        this.parallel_conditional_blobs_list.pop();
      }
    };
    CSL.Util = {};
    CSL.Util.Match = function() {
      this.any = function(token, state, tests) {
        return function(Item, item) {
          for (var i = 0,
              ilen = tests.length; i < ilen; i += 1) {
            result = tests[i](Item, item);
            if (result) {
              return true;
            }
          }
          return false;
        };
      };
      this.none = function(token, state, tests) {
        return function(Item, item) {
          for (var i = 0,
              ilen = tests.length; i < ilen; i += 1) {
            result = tests[i](Item, item);
            if (result) {
              return false;
            }
          }
          return true;
        };
      };
      this.all = function(token, state, tests) {
        return function(Item, item) {
          for (var i = 0,
              ilen = tests.length; i < ilen; i += 1) {
            result = tests[i](Item, item);
            if (!result) {
              return false;
            }
          }
          return true;
        };
      };
      this[undefined] = this.all;
      this.nand = function(token, state, tests) {
        return function(Item, item) {
          for (var i = 0,
              ilen = tests.length; i < ilen; i += 1) {
            result = tests[i](Item, item);
            if (!result) {
              return true;
            }
          }
          return false;
        };
      };
    };
    CSL.Transform = function(state) {
      var debug = false,
          abbreviations,
          token,
          fieldname,
          abbrev_family,
          opt;
      this.abbrevs = {};
      this.abbrevs["default"] = new state.sys.AbbreviationSegments();
      this.getTextSubField = getTextSubField;
      function abbreviate(state, Item, altvar, basevalue, myabbrev_family, use_field) {
        var value;
        if (!myabbrev_family) {
          return basevalue;
        }
        var variable = myabbrev_family;
        var noHints = false;
        if (["title", "title-short"].indexOf(variable) > -1 && !Item.jurisdiction) {
          noHints = true;
        }
        if (CSL.NUMERIC_VARIABLES.indexOf(myabbrev_family) > -1) {
          myabbrev_family = "number";
        }
        if (["publisher-place", "event-place", "jurisdiction", "archive-place", "language-name", "language-name-original"].indexOf(myabbrev_family) > -1) {
          myabbrev_family = "place";
        }
        if (["publisher", "authority"].indexOf(myabbrev_family) > -1) {
          myabbrev_family = "institution-part";
        }
        if (["genre", "event", "medium", "title-short"].indexOf(myabbrev_family) > -1) {
          myabbrev_family = "title";
        }
        if (["archive"].indexOf(myabbrev_family) > -1) {
          myabbrev_family = "collection-title";
        }
        value = "";
        if (state.sys.getAbbreviation) {
          var jurisdiction = state.transform.loadAbbreviation(Item.jurisdiction, myabbrev_family, basevalue, Item.type, noHints);
          if (state.transform.abbrevs[jurisdiction][myabbrev_family] && basevalue && state.sys.getAbbreviation) {
            if (state.transform.abbrevs[jurisdiction][myabbrev_family][basevalue]) {
              value = state.transform.abbrevs[jurisdiction][myabbrev_family][basevalue].replace("{stet}", basevalue);
            }
          }
        }
        if (!value && (!state.opt.development_extensions.require_explicit_legal_case_title_short || Item.type !== 'legal_case') && altvar && Item[altvar] && use_field) {
          value = Item[altvar];
        }
        if (!value) {
          value = basevalue;
        }
        if (value && value.match(/^\!(?:[^>]+,)*here(?:,[^>]+)*>>>/)) {
          if (variable === "jurisdiction" && ["treaty", "patent"].indexOf(Item.type) > -1) {
            value = value.replace(/^\![^>]*>>>\s*/, "");
          } else {
            value = false;
          }
        }
        return value;
      }
      function getFieldLocale(Item, field) {
        var ret = state.opt["default-locale"][0].slice(0, 2);
        var localeRex;
        if (state.opt.development_extensions.strict_text_case_locales) {
          localeRex = new RegExp("^([a-zA-Z]{2})(?:$|-.*| .*)");
        } else {
          localeRex = new RegExp("^([a-zA-Z]{2})(?:$|-.*|.*)");
        }
        if (Item.language) {
          m = ("" + Item.language).match(localeRex);
          if (m) {
            ret = m[1];
          } else {
            ret = "tlh";
          }
        }
        if (Item.multi && Item.multi && Item.multi.main && Item.multi.main[field]) {
          ret = Item.multi.main[field];
        }
        if (!state.opt.development_extensions.strict_text_case_locales || state.opt.development_extensions.normalize_lang_keys_to_lowercase) {
          ret = ret.toLowerCase();
        }
        return ret;
      }
      ;
      function getTextSubField(Item, field, locale_type, use_default, stopOrig) {
        var m,
            lst,
            opt,
            o,
            oo,
            pos,
            key,
            ret,
            len,
            myret,
            opts;
        var usedOrig = stopOrig;
        if (!Item[field]) {
          return {
            name: "",
            usedOrig: stopOrig
          };
        }
        ret = {
          name: "",
          usedOrig: stopOrig,
          locale: getFieldLocale(Item, field)
        };
        opts = state.opt[locale_type];
        var hasVal = false;
        var jurisdictionName = false;
        if (locale_type === 'locale-orig') {
          if (stopOrig) {
            ret = {
              name: "",
              usedOrig: stopOrig
            };
          } else {
            ret = {
              name: Item[field],
              usedOrig: false,
              locale: getFieldLocale(Item, field)
            };
          }
          hasVal = true;
        } else if (use_default && ("undefined" === typeof opts || opts.length === 0)) {
          var ret = {
            name: Item[field],
            usedOrig: true,
            locale: getFieldLocale(Item, field)
          };
          hasVal = true;
        }
        if (!hasVal) {
          for (var i = 0,
              ilen = opts.length; i < ilen; i += 1) {
            opt = opts[i];
            o = opt.split(/[\-_]/)[0];
            if (opt && Item.multi && Item.multi._keys[field] && Item.multi._keys[field][opt]) {
              ret.name = Item.multi._keys[field][opt];
              ret.locale = o;
              if (field === 'jurisdiction')
                jurisdictionName = ret.name;
              break;
            } else if (o && Item.multi && Item.multi._keys[field] && Item.multi._keys[field][o]) {
              ret.name = Item.multi._keys[field][o];
              ret.locale = o;
              if (field === 'jurisdiction')
                jurisdictionName = ret.name;
              break;
            }
          }
          if (!ret.name && use_default) {
            ret = {
              name: Item[field],
              usedOrig: true,
              locale: getFieldLocale(Item, field)
            };
          }
        }
        if (field === 'jurisdiction' && CSL.getSuppressedJurisdictionName) {
          if (ret.name && !jurisdictionName) {
            jurisdictionName = state.sys.getHumanForm(Item[field]);
          }
          if (jurisdictionName) {
            ret.name = CSL.getSuppressedJurisdictionName.call(state, Item[field], jurisdictionName);
          }
        }
        return ret;
      }
      function loadAbbreviation(jurisdiction, category, orig, itemType, noHints) {
        var pos,
            len;
        if (!jurisdiction) {
          jurisdiction = "default";
        }
        if (!orig) {
          if (!state.transform.abbrevs[jurisdiction]) {
            state.transform.abbrevs[jurisdiction] = new state.sys.AbbreviationSegments();
          }
          return jurisdiction;
        }
        if (state.sys.getAbbreviation) {
          var tryList = ['default'];
          if (jurisdiction !== 'default') {
            var workLst = jurisdiction.split(":");
            for (var i = 0,
                ilen = workLst.length; i < ilen; i += 1) {
              tryList.push(workLst.slice(0, i + 1).join(":"));
            }
          }
          var found = false;
          for (var i = tryList.length - 1; i > -1; i += -1) {
            if (!state.transform.abbrevs[tryList[i]]) {
              state.transform.abbrevs[tryList[i]] = new state.sys.AbbreviationSegments();
            }
            if (!state.transform.abbrevs[tryList[i]][category][orig]) {
              state.sys.getAbbreviation(state.opt.styleID, state.transform.abbrevs, tryList[i], category, orig, itemType, noHints);
            }
            if (!found && state.transform.abbrevs[tryList[i]][category][orig]) {
              if (i < tryList.length) {
                state.transform.abbrevs[jurisdiction][category][orig] = state.transform.abbrevs[tryList[i]][category][orig];
              }
              found = true;
            }
          }
        }
        return jurisdiction;
      }
      this.loadAbbreviation = loadAbbreviation;
      function publisherCheck(tok, Item, primary, myabbrev_family) {
        var varname = tok.variables[0];
        if (state.publisherOutput && primary) {
          if (["publisher", "publisher-place"].indexOf(varname) === -1) {
            return false;
          } else {
            state.publisherOutput[varname + "-token"] = tok;
            state.publisherOutput.varlist.push(varname);
            var lst = primary.split(/;\s*/);
            if (lst.length === state.publisherOutput[varname + "-list"].length) {
              state.publisherOutput[varname + "-list"] = lst;
            }
            for (var i = 0,
                ilen = lst.length; i < ilen; i += 1) {
              lst[i] = abbreviate(state, Item, false, lst[i], myabbrev_family, true);
            }
            state.tmp[varname + "-token"] = tok;
            return true;
          }
        }
        return false;
      }
      function getOutputFunction(variables, myabbrev_family, abbreviation_fallback, alternative_varname, transform_fallback) {
        var localesets;
        var langPrefs = CSL.LangPrefsMap[variables[0]];
        if (!langPrefs) {
          localesets = false;
        } else {
          localesets = state.opt['cite-lang-prefs'][langPrefs];
        }
        return function(state, Item, item, usedOrig) {
          var primary,
              primary_locale,
              secondary,
              secondary_locale,
              tertiary,
              tertiary_locale,
              primary_tok,
              group_tok,
              key;
          if (!variables[0] || (!Item[variables[0]] && !Item[alternative_varname])) {
            return null;
          }
          var slot = {
            primary: false,
            secondary: false,
            tertiary: false
          };
          if (state.tmp.area.slice(-5) === "_sort") {
            slot.primary = 'locale-sort';
          } else {
            if (localesets) {
              var slotnames = ["primary", "secondary", "tertiary"];
              for (var i = 0,
                  ilen = slotnames.length; i < ilen; i += 1) {
                if (localesets.length - 1 < i) {
                  break;
                }
                if (localesets[i]) {
                  slot[slotnames[i]] = 'locale-' + localesets[i];
                }
              }
            } else {
              slot.primary = 'locale-orig';
            }
          }
          if ((state.tmp.area !== "bibliography" && !(state.tmp.area === "citation" && state.opt.xclass === "note" && item && !item.position))) {
            slot.secondary = false;
            slot.tertiary = false;
          }
          if (state.tmp["publisher-list"]) {
            if (variables[0] === "publisher") {
              state.tmp["publisher-token"] = this;
            } else if (variables[0] === "publisher-place") {
              state.tmp["publisher-place-token"] = this;
            }
            return null;
          }
          var res = getTextSubField(Item, variables[0], slot.primary, true);
          primary = res.name;
          primary_locale = res.locale;
          var primaryUsedOrig = res.usedOrig;
          if (publisherCheck(this, Item, primary, myabbrev_family)) {
            return null;
          }
          secondary = false;
          tertiary = false;
          if (slot.secondary) {
            res = getTextSubField(Item, variables[0], slot.secondary, false, res.usedOrig);
            secondary = res.name;
            secondary_locale = res.locale;
          }
          if (slot.tertiary) {
            res = getTextSubField(Item, variables[0], slot.tertiary, false, res.usedOrig);
            tertiary = res.name;
            tertiary_locale = res.locale;
          }
          if (myabbrev_family) {
            primary = abbreviate(state, Item, alternative_varname, primary, myabbrev_family, true);
            if (primary) {
              primary = quashCheck(primary);
            }
            secondary = abbreviate(state, Item, false, secondary, myabbrev_family, true);
            tertiary = abbreviate(state, Item, false, tertiary, myabbrev_family, true);
          }
          var template_tok = CSL.Util.cloneToken(this);
          var primary_tok = CSL.Util.cloneToken(this);
          var primaryPrefix;
          if (slot.primary === "locale-translit") {
            primaryPrefix = state.opt.citeAffixes[langPrefs][slot.primary].prefix;
          }
          if (primaryPrefix === "<i>" && variables[0] === 'title' && !primaryUsedOrig) {
            var hasItalic = false;
            for (var i = 0,
                ilen = primary_tok.decorations.length; i < ilen; i += 1) {
              if (primary_tok.decorations[i][0] === "@font-style" && primary_tok.decorations[i][1] === "italic") {
                hasItalic = true;
              }
            }
            if (!hasItalic) {
              primary_tok.decorations.push(["@font-style", "italic"]);
            }
          }
          if (primary_locale !== "en" && primary_tok.strings["text-case"] === "title") {
            primary_tok.strings["text-case"] = "passthrough";
          }
          if ("title" === variables[0]) {
            primary = CSL.demoteNoiseWords(state, primary, this["leading-noise-words"]);
          }
          if (secondary || tertiary) {
            state.output.openLevel("empty");
            primary_tok.strings.suffix = primary_tok.strings.suffix.replace(/[ .,]+$/, "");
            state.output.append(primary, primary_tok);
            if (secondary) {
              secondary_tok = CSL.Util.cloneToken(template_tok);
              secondary_tok.strings.prefix = state.opt.citeAffixes[langPrefs][slot.secondary].prefix;
              secondary_tok.strings.suffix = state.opt.citeAffixes[langPrefs][slot.secondary].suffix;
              if (!secondary_tok.strings.prefix) {
                secondary_tok.strings.prefix = " ";
              }
              for (var i = secondary_tok.decorations.length - 1; i > -1; i += -1) {
                if (['@quotes/true', '@font-style/italic', '@font-style/oblique', '@font-weight/bold'].indexOf(secondary_tok.decorations[i].join('/')) > -1) {
                  secondary_tok.decorations = secondary_tok.decorations.slice(0, i).concat(secondary_tok.decorations.slice(i + 1));
                }
              }
              if (secondary_locale !== "en" && secondary_tok.strings["text-case"] === "title") {
                secondary_tok.strings["text-case"] = "passthrough";
              }
              state.output.append(secondary, secondary_tok);
              var blob_obj = state.output.current.value();
              var blobs_pos = state.output.current.value().blobs.length - 1;
              if (state.parallel.use_parallels) {
                state.parallel.cite.front.push(variables[0] + ":secondary");
                state.parallel.cite[variables[0] + ":secondary"] = {blobs: [[blob_obj, blobs_pos]]};
              }
            }
            if (tertiary) {
              tertiary_tok = CSL.Util.cloneToken(template_tok);
              tertiary_tok.strings.prefix = state.opt.citeAffixes[langPrefs][slot.tertiary].prefix;
              tertiary_tok.strings.suffix = state.opt.citeAffixes[langPrefs][slot.tertiary].suffix;
              if (!tertiary_tok.strings.prefix) {
                tertiary_tok.strings.prefix = " ";
              }
              for (var i = tertiary_tok.decorations.length - 1; i > -1; i += -1) {
                if (['@quotes/true', '@font-style/italic', '@font-style/oblique', '@font-weight/bold'].indexOf(tertiary_tok.decorations[i].join('/')) > -1) {
                  tertiary_tok.decorations = tertiary_tok.decorations.slice(0, i).concat(tertiary_tok.decorations.slice(i + 1));
                }
              }
              if (tertiary_locale !== "en" && tertiary_tok.strings["text-case"] === "title") {
                tertiary_tok.strings["text-case"] = "passthrough";
              }
              state.output.append(tertiary, tertiary_tok);
              var blob_obj = state.output.current.value();
              var blobs_pos = state.output.current.value().blobs.length - 1;
              if (state.parallel.use_parallels) {
                state.parallel.cite.front.push(variables[0] + ":tertiary");
                state.parallel.cite[variables[0] + ":tertiary"] = {blobs: [[blob_obj, blobs_pos]]};
              }
            }
            state.output.closeLevel();
          } else {
            state.output.append(primary, primary_tok);
          }
          return null;
        };
      }
      this.getOutputFunction = getOutputFunction;
      function quashCheck(value) {
        var m = value.match(/^!([-,_a-z]+)>>>/);
        if (m) {
          var fields = m[1].split(",");
          value = value.slice(m[0].length);
          for (var i = 0,
              ilen = fields.length; i < ilen; i += 1) {
            if (state.tmp.done_vars.indexOf(fields[i]) === -1) {
              state.tmp.done_vars.push(fields[i]);
            }
          }
        }
        return value;
      }
      this.quashCheck = quashCheck;
    };
    CSL.Token = function(name, tokentype) {
      this.name = name;
      this.strings = {};
      this.strings.delimiter = undefined;
      this.strings.prefix = "";
      this.strings.suffix = "";
      this.decorations = [];
      this.variables = [];
      this.execs = [];
      this.tokentype = tokentype;
      this.evaluator = false;
      this.tests = [];
      this.rawtests = [];
      this.succeed = false;
      this.fail = false;
      this.next = false;
    };
    CSL.Util.cloneToken = function(token) {
      var newtok,
          key,
          pos,
          len;
      if ("string" === typeof token) {
        return token;
      }
      newtok = new CSL.Token(token.name, token.tokentype);
      for (key in token.strings) {
        if (token.strings.hasOwnProperty(key)) {
          newtok.strings[key] = token.strings[key];
        }
      }
      if (token.decorations) {
        newtok.decorations = [];
        for (pos = 0, len = token.decorations.length; pos < len; pos += 1) {
          newtok.decorations.push(token.decorations[pos].slice());
        }
      }
      if (token.variables) {
        newtok.variables = token.variables.slice();
      }
      if (token.execs) {
        newtok.execs = token.execs.slice();
        newtok.tests = token.tests.slice();
        newtok.rawtests = token.tests.slice();
      }
      return newtok;
    };
    CSL.AmbigConfig = function() {
      this.maxvals = [];
      this.minval = 1;
      this.names = [];
      this.givens = [];
      this.year_suffix = false;
      this.disambiguate = 0;
    };
    CSL.Blob = function(str, token, levelname) {
      var len,
          pos,
          key;
      this.levelname = levelname;
      if (token) {
        this.strings = {
          "prefix": "",
          "suffix": ""
        };
        for (key in token.strings) {
          if (token.strings.hasOwnProperty(key)) {
            this.strings[key] = token.strings[key];
          }
        }
        this.decorations = [];
        if (token.decorations === undefined) {
          len = 0;
        } else {
          len = token.decorations.length;
        }
        for (pos = 0; pos < len; pos += 1) {
          this.decorations.push(token.decorations[pos].slice());
        }
      } else {
        this.strings = {};
        this.strings.prefix = "";
        this.strings.suffix = "";
        this.strings.delimiter = "";
        this.decorations = [];
      }
      if ("string" === typeof str) {
        this.blobs = str;
      } else if (str) {
        this.blobs = [str];
      } else {
        this.blobs = [];
      }
      this.alldecor = [this.decorations];
    };
    CSL.Blob.prototype.push = function(blob) {
      if ("string" === typeof this.blobs) {
        throw "Attempt to push blob onto string object";
      } else if (false !== blob) {
        blob.alldecor = blob.alldecor.concat(this.alldecor);
        this.blobs.push(blob);
      }
    };
    CSL.NumericBlob = function(particle, num, mother_token, id) {
      this.id = id;
      this.alldecor = [];
      this.num = num;
      this.particle = particle;
      this.blobs = num.toString();
      this.status = CSL.START;
      this.strings = {};
      if (mother_token) {
        this.gender = mother_token.gender;
        this.decorations = mother_token.decorations;
        this.strings.prefix = mother_token.strings.prefix;
        this.strings.suffix = mother_token.strings.suffix;
        this.strings["text-case"] = mother_token.strings["text-case"];
        this.successor_prefix = mother_token.successor_prefix;
        this.range_prefix = mother_token.range_prefix;
        this.splice_prefix = mother_token.splice_prefix;
        this.formatter = mother_token.formatter;
        if (!this.formatter) {
          this.formatter = new CSL.Output.DefaultFormatter();
        }
        if (this.formatter) {
          this.type = this.formatter.format(1);
        }
      } else {
        this.decorations = [];
        this.strings.prefix = "";
        this.strings.suffix = "";
        this.successor_prefix = "";
        this.range_prefix = "";
        this.splice_prefix = "";
        this.formatter = new CSL.Output.DefaultFormatter();
      }
    };
    CSL.NumericBlob.prototype.setFormatter = function(formatter) {
      this.formatter = formatter;
      this.type = this.formatter.format(1);
    };
    CSL.Output.DefaultFormatter = function() {};
    CSL.Output.DefaultFormatter.prototype.format = function(num) {
      return num.toString();
    };
    CSL.NumericBlob.prototype.checkNext = function(next, start) {
      if (start) {
        this.status = CSL.START;
        if ("object" === typeof next) {
          if (next.num === (this.num + 1)) {
            next.status = CSL.SUCCESSOR;
          } else {
            next.status = CSL.SEEN;
          }
        }
      } else if (!next || !next.num || this.type !== next.type || next.num !== (this.num + 1)) {
        if (this.status === CSL.SUCCESSOR_OF_SUCCESSOR) {
          this.status = CSL.END;
        }
        if ("object" === typeof next) {
          next.status = CSL.SEEN;
        }
      } else {
        if (this.status === CSL.START || this.status === CSL.SEEN) {
          next.status = CSL.SUCCESSOR;
        } else if (this.status === CSL.SUCCESSOR || this.status === CSL.SUCCESSOR_OF_SUCCESSOR) {
          if (this.range_prefix) {
            next.status = CSL.SUCCESSOR_OF_SUCCESSOR;
            this.status = CSL.SUPPRESS;
          } else {
            next.status = CSL.SUCCESSOR;
          }
        }
      }
    };
    CSL.NumericBlob.prototype.checkLast = function(last) {
      if (this.status === CSL.SEEN || (last.num !== (this.num - 1) && this.status === CSL.SUCCESSOR)) {
        this.status = CSL.SUCCESSOR;
        return true;
      }
      return false;
    };
    CSL.Util.fixDateNode = function(parent, pos, node) {
      var form,
          variable,
          datexml,
          subnode,
          partname,
          attr,
          val,
          prefix,
          suffix,
          children,
          key,
          subchildren,
          kkey,
          display,
          cslid;
      this.build.date_key = true;
      form = this.cslXml.getAttributeValue(node, "form");
      var lingo;
      if ("accessed" === this.cslXml.getAttributeValue(node, "variable")) {
        lingo = this.opt["default-locale"][0];
      } else {
        lingo = this.cslXml.getAttributeValue(node, "lingo");
      }
      if (!this.getDate(form)) {
        return parent;
      }
      var dateparts = this.cslXml.getAttributeValue(node, "date-parts");
      variable = this.cslXml.getAttributeValue(node, "variable");
      prefix = this.cslXml.getAttributeValue(node, "prefix");
      suffix = this.cslXml.getAttributeValue(node, "suffix");
      display = this.cslXml.getAttributeValue(node, "display");
      cslid = this.cslXml.getAttributeValue(node, "cslid");
      datexml = this.cslXml.nodeCopy(this.getDate(form, ("accessed" === variable)));
      this.cslXml.setAttribute(datexml, 'lingo', this.opt.lang);
      this.cslXml.setAttribute(datexml, 'form', form);
      this.cslXml.setAttribute(datexml, 'date-parts', dateparts);
      this.cslXml.setAttribute(datexml, "cslid", cslid);
      this.cslXml.setAttribute(datexml, 'variable', variable);
      if (prefix) {
        this.cslXml.setAttribute(datexml, "prefix", prefix);
      }
      if (suffix) {
        this.cslXml.setAttribute(datexml, "suffix", suffix);
      }
      if (display) {
        this.cslXml.setAttribute(datexml, "display", display);
      }
      children = this.cslXml.children(node);
      for (key in children) {
        subnode = children[key];
        if ("date-part" === this.cslXml.nodename(subnode)) {
          partname = this.cslXml.getAttributeValue(subnode, "name");
          subchildren = this.cslXml.attributes(subnode);
          for (attr in subchildren) {
            if (subchildren.hasOwnProperty(attr)) {
              if ("@name" === attr) {
                continue;
              }
              if (lingo && lingo !== this.opt.lang) {
                if (["@suffix", "@prefix", "@form"].indexOf(attr) > -1) {
                  continue;
                }
              }
              val = subchildren[attr];
              this.cslXml.setAttributeOnNodeIdentifiedByNameAttribute(datexml, "date-part", partname, attr, val);
            }
          }
        }
      }
      if ("year" === this.cslXml.getAttributeValue(node, "date-parts")) {
        this.cslXml.deleteNodeByNameAttribute(datexml, 'month');
        this.cslXml.deleteNodeByNameAttribute(datexml, 'day');
      } else if ("year-month" === this.cslXml.getAttributeValue(node, "date-parts")) {
        this.cslXml.deleteNodeByNameAttribute(datexml, 'day');
      }
      return this.cslXml.insertChildNodeAfter(parent, node, pos, datexml);
    };
    CSL.dateMacroAsSortKey = function(state, Item) {
      CSL.dateAsSortKey.call(this, state, Item, true);
    };
    CSL.dateAsSortKey = function(state, Item, isMacro) {
      var dp,
          elem,
          value,
          e,
          yr,
          prefix,
          i,
          ilen,
          num;
      var variable = this.variables[0];
      var macroFlag = "empty";
      if (isMacro && state.tmp.extension) {
        macroFlag = "macro-with-date";
      }
      dp = Item[variable];
      if ("undefined" === typeof dp) {
        dp = {"date-parts": [[0]]};
        if (!dp.year) {
          state.tmp.empty_date = true;
        }
      }
      if ("undefined" === typeof this.dateparts) {
        this.dateparts = ["year", "month", "day"];
      }
      if (dp.raw) {
        dp = state.fun.dateparser.parseDateToArray(dp.raw);
      } else if (dp["date-parts"]) {
        dp = state.dateParseArray(dp);
      }
      if ("undefined" === typeof dp) {
        dp = {};
      }
      for (i = 0, ilen = CSL.DATE_PARTS_INTERNAL.length; i < ilen; i += 1) {
        elem = CSL.DATE_PARTS_INTERNAL[i];
        value = 0;
        e = elem;
        if (e.slice(-4) === "_end") {
          e = e.slice(0, -4);
        }
        if (dp[elem] && this.dateparts.indexOf(e) > -1) {
          value = dp[elem];
        }
        if (elem.slice(0, 4) === "year") {
          yr = CSL.Util.Dates[e].numeric(state, value);
          prefix = "Y";
          if (yr[0] === "-") {
            prefix = "X";
            yr = yr.slice(1);
            yr = 9999 - parseInt(yr, 10);
          }
          state.output.append(CSL.Util.Dates[elem.slice(0, 4)].numeric(state, (prefix + yr)), macroFlag);
        } else {
          value = CSL.Util.Dates[e]["numeric-leading-zeros"](state, value);
          if (!value) {
            value = "00";
          }
          state.output.append(value, macroFlag);
        }
      }
    };
    CSL.Engine.prototype.dateParseArray = function(date_obj) {
      var ret,
          field,
          dpos,
          ppos,
          dp,
          exts,
          llen,
          pos,
          len,
          pppos,
          lllen;
      ret = {};
      for (field in date_obj) {
        if (field === "date-parts") {
          dp = date_obj["date-parts"];
          if (dp.length > 1) {
            if (dp[0].length !== dp[1].length) {
              CSL.error("CSL data error: element mismatch in date range input.");
            }
          }
          exts = ["", "_end"];
          for (var i = 0,
              ilen = dp.length; i < ilen; i += 1) {
            for (var j = 0,
                jlen = CSL.DATE_PARTS.length; j < jlen; j += 1) {
              if ("undefined" === typeof dp[i][j]) {
                ret[(CSL.DATE_PARTS[j] + exts[i])] = dp[i][j];
              } else {
                ret[(CSL.DATE_PARTS[j] + exts[i])] = parseInt(dp[i][j], 10);
              }
            }
          }
        } else if (date_obj.hasOwnProperty(field)) {
          if (field === "literal" && "object" === typeof date_obj.literal && "string" === typeof date_obj.literal.part) {
            CSL.debug("Warning: fixing up weird literal date value");
            ret.literal = date_obj.literal.part;
          } else {
            ret[field] = date_obj[field];
          }
        }
      }
      return ret;
    };
    CSL.Util.Names = {};
    CSL.Util.Names.compareNamesets = CSL.NameOutput.prototype._compareNamesets;
    CSL.Util.Names.unInitialize = function(state, name) {
      var i,
          ilen,
          namelist,
          punctlist,
          ret;
      if (!name) {
        return "";
      }
      namelist = name.split(/(?:\-|\s+)/);
      punctlist = name.match(/(\-|\s+)/g);
      ret = "";
      for (i = 0, ilen = namelist.length; i < ilen; i += 1) {
        if (CSL.ALL_ROMANESQUE_REGEXP.exec(namelist[i].slice(0, -1)) && namelist[i] && namelist[i] !== namelist[i].toUpperCase()) {
          namelist[i] = namelist[i].slice(0, 1) + namelist[i].slice(1, 2).toLowerCase() + namelist[i].slice(2);
        }
        ret += namelist[i];
        if (i < ilen - 1) {
          ret += punctlist[i];
        }
      }
      return ret;
    };
    CSL.Util.Names.initializeWith = function(state, name, terminator, normalizeOnly) {
      var i,
          ilen,
          j,
          jlen,
          n,
          m,
          mm,
          str,
          lst,
          ret;
      if (!name) {
        return "";
      }
      if (!terminator) {
        terminator = "";
      }
      if (["Lord", "Lady"].indexOf(name) > -1 || (!name.match(CSL.STARTSWITH_ROMANESQUE_REGEXP) && !terminator.match("%s"))) {
        return name;
      }
      var namelist = name;
      if (state.opt["initialize-with-hyphen"] === false) {
        namelist = namelist.replace(/\-/g, " ");
      }
      namelist = namelist.replace(/\s*\-\s*/g, "-").replace(/\s+/g, " ");
      namelist = namelist.replace(/-([a-z])/g, "\u2013$1");
      mm = namelist.match(/[\-\s]+/g);
      lst = namelist.split(/[\-\s]+/);
      if (lst.length === 0) {
        namelist = mm;
      } else {
        namelist = [lst[0]];
        for (i = 1, ilen = lst.length; i < ilen; i += 1) {
          namelist.push(mm[i - 1]);
          namelist.push(lst[i]);
        }
      }
      lst = namelist;
      for (i = lst.length - 1; i > -1; i += -1) {
        if (lst[i] && lst[i].slice(0, -1).indexOf(".") > -1) {
          var lstend = lst.slice(i + 1);
          var lstmid = lst[i].slice(0, -1).split(".");
          lst = lst.slice(0, i);
          for (j = 0, jlen = lstmid.length; j < jlen; j += 1) {
            lst.push(lstmid[j] + ".");
            if (j < lstmid.length - 1) {
              lst.push(" ");
            }
          }
          lst = lst.concat(lstend);
        }
      }
      if (normalizeOnly) {
        ret = CSL.Util.Names.doNormalize(state, lst, terminator);
      } else {
        ret = CSL.Util.Names.doInitialize(state, lst, terminator);
      }
      ret = ret.replace(/\u2013([a-z])/g, "-$1");
      return ret;
    };
    CSL.Util.Names.doNormalize = function(state, namelist, terminator, mode) {
      var i,
          ilen;
      terminator = terminator ? terminator : "";
      var isAbbrev = [];
      for (i = 0, ilen = namelist.length; i < ilen; i += 1) {
        if (namelist[i].length > 1 && namelist[i].slice(-1) === ".") {
          namelist[i] = namelist[i].slice(0, -1);
          isAbbrev.push(true);
        } else if (namelist[i].length === 1 && namelist[i].toUpperCase() === namelist[i]) {
          isAbbrev.push(true);
        } else {
          isAbbrev.push(false);
        }
      }
      var ret = [];
      for (i = 0, ilen = namelist.length; i < ilen; i += 2) {
        if (isAbbrev[i]) {
          if (i < namelist.length - 2) {
            namelist[i + 1] = "";
            if ((!terminator || terminator.slice(-1) && terminator.slice(-1) !== " ") && namelist[i].length && namelist[i].match(CSL.ALL_ROMANESQUE_REGEXP) && (namelist[i].length > 1 || namelist[i + 2].length > 1)) {
              namelist[i + 1] = " ";
            }
            if (namelist[i + 2].length > 1) {
              namelist[i] = namelist[i] + terminator.replace(/[\u0009\u000a\u000b\u000c\u000d\u0020\ufeff\u00a0]+$/, "");
            } else {
              namelist[i] = namelist[i] + terminator;
            }
          }
          if (i === namelist.length - 1) {
            namelist[i] = namelist[i] + terminator;
          }
        }
      }
      return namelist.join("").replace(/[\u0009\u000a\u000b\u000c\u000d\u0020\ufeff\u00a0]+$/, "").replace(/\s*\-\s*/g, "-").replace(/[\u0009\u000a\u000b\u000c\u000d\u0020]+/g, " ");
    };
    CSL.Util.Names.doInitialize = function(state, namelist, terminator, mode) {
      var i,
          ilen,
          m,
          j,
          jlen,
          lst,
          n;
      for (i = 0, ilen = namelist.length; i < ilen; i += 2) {
        n = namelist[i];
        if (!n) {
          continue;
        }
        m = n.match(CSL.NAME_INITIAL_REGEXP);
        if (!m && (!n.match(CSL.STARTSWITH_ROMANESQUE_REGEXP) && n.length > 1 && terminator.match("%s"))) {
          m = n.match(/(.)(.*)/);
        }
        if (m && m[1] === m[1].toUpperCase()) {
          var extra = "";
          if (m[2]) {
            var s = "";
            lst = m[2].split("");
            for (j = 0, jlen = lst.length; j < jlen; j += 1) {
              var c = lst[j];
              if (c === c.toUpperCase()) {
                s += c;
              } else {
                break;
              }
            }
            if (s.length < m[2].length) {
              extra = s.toLocaleLowerCase();
            }
          }
          namelist[i] = m[1].toLocaleUpperCase() + extra;
          if (i < (ilen - 1)) {
            if (terminator.match("%s")) {
              namelist[i] = terminator.replace("%s", namelist[i]);
            } else {
              if (namelist[i + 1].indexOf("-") > -1) {
                namelist[i + 1] = terminator + namelist[i + 1];
              } else {
                namelist[i + 1] = terminator;
              }
            }
          } else {
            if (terminator.match("%s")) {
              namelist[i] = terminator.replace("%s", namelist[i]);
            } else {
              namelist.push(terminator);
            }
          }
        } else if (n.match(CSL.ROMANESQUE_REGEXP)) {
          namelist[i] = " " + n;
        }
      }
      var ret = namelist.join("");
      ret = ret.replace(/[\u0009\u000a\u000b\u000c\u000d\u0020\ufeff\u00a0]+$/, "").replace(/\s*\-\s*/g, "-").replace(/[\u0009\u000a\u000b\u000c\u000d\u0020]+/g, " ");
      return ret;
    };
    CSL.Util.Names.getRawName = function(name) {
      var ret = [];
      if (name.given) {
        ret.push(name.given);
      }
      if (name.family) {
        ret.push(name.family);
      }
      return ret.join(" ");
    };
    CSL.Util.Dates = {};
    CSL.Util.Dates.year = {};
    CSL.Util.Dates.year["long"] = function(state, num) {
      if (!num) {
        if ("boolean" === typeof num) {
          num = "";
        } else {
          num = 0;
        }
      }
      return num.toString();
    };
    CSL.Util.Dates.year.imperial = function(state, num, end, makeShort) {
      if (!num) {
        if ("boolean" === typeof num) {
          num = "";
        } else {
          num = 0;
        }
      }
      end = end ? "_end" : "";
      var month = state.tmp.date_object["month" + end];
      month = month ? "" + month : "1";
      while (month.length < 2) {
        month = "0" + month;
      }
      var day = state.tmp.date_object["day" + end];
      day = day ? "" + day : "1";
      while (day.length < 2) {
        day = "0" + day;
      }
      var date = parseInt(num + month + day, 10);
      var label;
      var offset;
      if (date >= 18680908 && date < 19120730) {
        label = '\u660e\u6cbb';
        offset = 1867;
      } else if (date >= 19120730 && date < 19261225) {
        label = '\u5927\u6b63';
        offset = 1911;
      } else if (date >= 19261225 && date < 19890108) {
        label = '\u662d\u548c';
        offset = 1925;
      } else if (date >= 19890108) {
        label = '\u5e73\u6210';
        offset = 1988;
      }
      if (label && offset) {
        if (!state.transform.abbrevs['default']['number'][label]) {
          state.transform.loadAbbreviation('default', "number", label);
        }
        if (state.transform.abbrevs['default']['number'][label]) {
          label = state.transform.abbrevs['default']['number'][label];
        }
        ;
        year = label + (num - offset);
      }
      return year;
    };
    CSL.Util.Dates.year["short"] = function(state, num) {
      num = num.toString();
      if (num && num.length === 4) {
        return num.substr(2);
      }
    };
    CSL.Util.Dates.year.numeric = function(state, num) {
      var m,
          pre;
      num = "" + num;
      m = num.match(/([0-9]*)$/);
      if (m) {
        pre = num.slice(0, m[1].length * -1);
        num = m[1];
      } else {
        pre = num;
        num = "";
      }
      while (num.length < 4) {
        num = "0" + num;
      }
      return (pre + num);
    };
    CSL.Util.Dates.normalizeMonth = function(num, useSeason) {
      var ret;
      if (!num) {
        num = 0;
      }
      num = "" + num;
      if (!num.match(/^[0-9]+$/)) {
        num = 0;
      }
      num = parseInt(num, 10);
      if (useSeason) {
        var res = {
          stub: "month-",
          num: num
        };
        if (res.num < 1 || res.num > 20) {
          res.num = 0;
        } else if (res.num > 16) {
          res.stub = "season-";
          res.num = res.num - 16;
        } else if (res.num > 12) {
          res.stub = "season-";
          res.num = res.num - 12;
        }
        ret = res;
      } else {
        if (num < 1 || num > 12) {
          num = 0;
        }
        ret = num;
      }
      return ret;
    };
    CSL.Util.Dates.month = {};
    CSL.Util.Dates.month.numeric = function(state, num) {
      var num = CSL.Util.Dates.normalizeMonth(num);
      if (!num) {
        num = "";
      }
      return num;
    };
    CSL.Util.Dates.month["numeric-leading-zeros"] = function(state, num) {
      var num = CSL.Util.Dates.normalizeMonth(num);
      if (!num) {
        num = "";
      } else {
        num = "" + num;
        while (num.length < 2) {
          num = "0" + num;
        }
      }
      return num;
    };
    CSL.Util.Dates.month["long"] = function(state, num, gender, forceDefaultLocale) {
      var res = CSL.Util.Dates.normalizeMonth(num, true);
      var num = res.num;
      if (!num) {
        num = "";
      } else {
        num = "" + num;
        while (num.length < 2) {
          num = "0" + num;
        }
        num = state.getTerm(res.stub + num, "long", 0, 0, false, forceDefaultLocale);
      }
      return num;
    };
    CSL.Util.Dates.month["short"] = function(state, num, gender, forceDefaultLocale) {
      var res = CSL.Util.Dates.normalizeMonth(num, true);
      var num = res.num;
      if (!num) {
        num = "";
      } else {
        num = "" + num;
        while (num.length < 2) {
          num = "0" + num;
        }
        num = state.getTerm(res.stub + num, "short", 0, 0, false, forceDefaultLocale);
      }
      return num;
    };
    CSL.Util.Dates.day = {};
    CSL.Util.Dates.day.numeric = function(state, num) {
      return num.toString();
    };
    CSL.Util.Dates.day["long"] = CSL.Util.Dates.day.numeric;
    CSL.Util.Dates.day["numeric-leading-zeros"] = function(state, num) {
      if (!num) {
        num = 0;
      }
      num = num.toString();
      while (num.length < 2) {
        num = "0" + num;
      }
      return num.toString();
    };
    CSL.Util.Dates.day.ordinal = function(state, num, gender) {
      return state.fun.ordinalizer.format(num, gender);
    };
    CSL.Util.Sort = {};
    CSL.Util.Sort.strip_prepositions = function(str) {
      var m;
      if ("string" === typeof str) {
        m = str.toLocaleLowerCase();
        m = str.match(/^((a|an|the)\s+)/);
      }
      if (m) {
        str = str.substr(m[1].length);
      }
      return str;
    };
    CSL.Util.substituteStart = function(state, target) {
      var element_trace,
          display,
          bib_first,
          func,
          choose_start,
          if_start,
          nodetypes;
      func = function(state, Item) {
        for (var i = 0,
            ilen = this.decorations.length; i < ilen; i += 1) {
          if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
            state.tmp.strip_periods += 1;
            break;
          }
        }
      };
      this.execs.push(func);
      if (this.decorations && (state.opt.development_extensions.csl_reverse_lookup_support || state.sys.csl_reverse_lookup_support)) {
        this.decorations.reverse();
        this.decorations.push(["@showid", "true", this.cslid]);
        this.decorations.reverse();
      }
      nodetypes = ["number", "date", "names"];
      if (("text" === this.name && !this.postponed_macro) || nodetypes.indexOf(this.name) > -1) {
        element_trace = function(state, Item, item) {
          if (state.tmp.element_trace.value() === "author" || "names" === this.name) {
            if (item && item["author-only"]) {
              state.tmp.element_trace.push("do-not-suppress-me");
            } else if (item && item["suppress-author"]) {}
          } else {
            if (item && item["author-only"]) {
              state.tmp.element_trace.push("suppress-me");
            } else if (item && item["suppress-author"]) {
              state.tmp.element_trace.push("do-not-suppress-me");
            }
          }
        };
        this.execs.push(element_trace);
      }
      display = this.strings.cls;
      this.strings.cls = false;
      if (state.build.render_nesting_level === 0) {
        if (state.build.area === "bibliography" && state.bibliography.opt["second-field-align"]) {
          bib_first = new CSL.Token("group", CSL.START);
          bib_first.decorations = [["@display", "left-margin"]];
          func = function(state, Item) {
            if (!state.tmp.render_seen) {
              bib_first.strings.first_blob = Item.id;
              state.output.startTag("bib_first", bib_first);
            }
          };
          bib_first.execs.push(func);
          target.push(bib_first);
        } else if (CSL.DISPLAY_CLASSES.indexOf(display) > -1) {
          bib_first = new CSL.Token("group", CSL.START);
          bib_first.decorations = [["@display", display]];
          func = function(state, Item) {
            bib_first.strings.first_blob = Item.id;
            state.output.startTag("bib_first", bib_first);
          };
          bib_first.execs.push(func);
          target.push(bib_first);
        }
        state.build.cls = display;
      }
      state.build.render_nesting_level += 1;
      if (state.build.substitute_level.value() === 1) {
        choose_start = new CSL.Token("choose", CSL.START);
        CSL.Node.choose.build.call(choose_start, state, target);
        if_start = new CSL.Token("if", CSL.START);
        func = function(Item, item) {
          if (state.tmp.can_substitute.value()) {
            return true;
          }
          return false;
        };
        if_start.tests.push(func);
        if_start.test = state.fun.match.any(this, state, if_start.tests);
        target.push(if_start);
      }
      if (state.sys.variableWrapper && this.variables_real && this.variables_real.length) {
        func = function(state, Item, item) {
          if (!state.tmp.just_looking && !state.tmp.suppress_decorations) {
            variable_entry = new CSL.Token("text", CSL.START);
            variable_entry.decorations = [["@showid", "true"]];
            state.output.startTag("variable_entry", variable_entry);
            var position = null;
            if (item) {
              position = item.position;
            }
            if (!position)
              position = 0;
            var positionMap = ["first", "subsequent", "ibid", "ibid-with-locator"];
            var noteNumber = 0;
            if (item && item.noteIndex) {
              noteNumber = item.noteIndex;
            }
            var firstReferenceNoteNumber = 0;
            if (item && item['first-reference-note-number']) {
              firstReferenceNoteNumber = item['first-reference-note-number'];
            }
            var citationNumber = 0;
            if (item && item['citation-number']) {
              citationNumber = item['citation-number'];
            }
            var index = 0;
            if (item && item.index) {
              index = item.index;
            }
            var params = {
              itemData: Item,
              variableNames: this.variables,
              context: state.tmp.area,
              xclass: state.opt.xclass,
              position: positionMap[position],
              "note-number": noteNumber,
              "first-reference-note-number": firstReferenceNoteNumber,
              "citation-number": citationNumber,
              "index": index,
              "mode": state.opt.mode
            };
            state.output.current.value().params = params;
          }
        };
        this.execs.push(func);
      }
    };
    CSL.Util.substituteEnd = function(state, target) {
      var func,
          bib_first_end,
          bib_other,
          if_end,
          choose_end,
          toplevel,
          hasval,
          author_substitute,
          str;
      if (state.sys.variableWrapper && (this.hasVariable || (this.variables_real && this.variables_real.length))) {
        func = function(state, Item) {
          if (!state.tmp.just_looking && !state.tmp.suppress_decorations) {
            state.output.endTag("variable_entry");
          }
        };
        this.execs.push(func);
      }
      func = function(state, Item) {
        for (var i = 0,
            ilen = this.decorations.length; i < ilen; i += 1) {
          if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
            state.tmp.strip_periods += -1;
            break;
          }
        }
      };
      this.execs.push(func);
      state.build.render_nesting_level += -1;
      if (state.build.render_nesting_level === 0) {
        if (state.build.cls) {
          func = function(state, Item) {
            state.output.endTag("bib_first");
          };
          this.execs.push(func);
          state.build.cls = false;
        } else if (state.build.area === "bibliography" && state.bibliography.opt["second-field-align"]) {
          bib_first_end = new CSL.Token("group", CSL.END);
          func = function(state, Item) {
            if (!state.tmp.render_seen) {
              state.output.endTag("bib_first");
            }
          };
          bib_first_end.execs.push(func);
          target.push(bib_first_end);
          bib_other = new CSL.Token("group", CSL.START);
          bib_other.decorations = [["@display", "right-inline"]];
          func = function(state, Item) {
            if (!state.tmp.render_seen) {
              state.tmp.render_seen = true;
              state.output.startTag("bib_other", bib_other);
            }
          };
          bib_other.execs.push(func);
          target.push(bib_other);
        }
      }
      if (state.build.substitute_level.value() === 1) {
        if_end = new CSL.Token("if", CSL.END);
        target.push(if_end);
        choose_end = new CSL.Token("choose", CSL.END);
        CSL.Node.choose.build.call(choose_end, state, target);
      }
      toplevel = "names" === this.name && state.build.substitute_level.value() === 0;
      hasval = "string" === typeof state[state.build.area].opt["subsequent-author-substitute"];
      var subrule = state[state.build.area].opt["subsequent-author-substitute-rule"];
      if (toplevel && hasval) {
        author_substitute = new CSL.Token("text", CSL.SINGLETON);
        func = function(state, Item) {
          var i,
              ilen;
          var printing = !state.tmp.suppress_decorations;
          if (printing && state.tmp.area === "bibliography" && state.tmp.subsequent_author_substitute_ok) {
            if (state.tmp.rendered_name) {
              if ("partial-each" === subrule || "partial-first" === subrule) {
                var dosub = true;
                var rendered_name = [];
                for (i = 0, ilen = state.tmp.name_node.children.length; i < ilen; i += 1) {
                  var name = state.tmp.rendered_name[i];
                  if (dosub && state.tmp.last_rendered_name && state.tmp.last_rendered_name.length > (i - 1) && name && !name.localeCompare(state.tmp.last_rendered_name[i])) {
                    str = new CSL.Blob(state[state.tmp.area].opt["subsequent-author-substitute"]);
                    state.tmp.name_node.children[i].blobs = [str];
                    if ("partial-first" === subrule) {
                      dosub = false;
                    }
                  } else {
                    dosub = false;
                  }
                  rendered_name.push(name);
                }
                state.tmp.last_rendered_name = rendered_name;
              } else if ("complete-each" === subrule) {
                var rendered_name = state.tmp.rendered_name.join(",");
                if (rendered_name) {
                  if (!rendered_name.localeCompare(state.tmp.last_rendered_name)) {
                    for (i = 0, ilen = state.tmp.name_node.children.length; i < ilen; i += 1) {
                      str = new CSL.Blob(state[state.tmp.area].opt["subsequent-author-substitute"]);
                      state.tmp.name_node.children[i].blobs = [str];
                    }
                  }
                  state.tmp.last_rendered_name = rendered_name;
                }
              } else {
                var rendered_name = state.tmp.rendered_name.join(",");
                if (rendered_name) {
                  if (!rendered_name.localeCompare(state.tmp.last_rendered_name)) {
                    str = new CSL.Blob(state[state.tmp.area].opt["subsequent-author-substitute"]);
                    if (state.tmp.label_blob) {
                      state.tmp.name_node.top.blobs = [str, state.tmp.label_blob];
                    } else {
                      state.tmp.name_node.top.blobs = [str];
                    }
                  }
                  state.tmp.last_rendered_name = rendered_name;
                }
              }
            }
          }
        };
        author_substitute.execs.push(func);
        target.push(author_substitute);
      }
      if (("text" === this.name && !this.postponed_macro) || ["number", "date", "names"].indexOf(this.name) > -1) {
        func = function(state, Item) {
          state.tmp.element_trace.pop();
        };
        this.execs.push(func);
      }
    };
    CSL.Util.padding = function(num) {
      var m = num.match(/\s*(-{0,1}[0-9]+)/);
      if (m) {
        num = parseInt(m[1], 10);
        if (num < 0) {
          num = 99999999999999999999 + num;
        }
        num = "" + num;
        while (num.length < 20) {
          num = "0" + num;
        }
      }
      return num;
    };
    CSL.Util.LongOrdinalizer = function() {};
    CSL.Util.LongOrdinalizer.prototype.init = function(state) {
      this.state = state;
    };
    CSL.Util.LongOrdinalizer.prototype.format = function(num, gender) {
      if (num < 10) {
        num = "0" + num;
      }
      var ret = CSL.Engine.getField(CSL.LOOSE, this.state.locale[this.state.opt.lang].terms, "long-ordinal-" + num, "long", 0, gender);
      if (!ret) {
        ret = this.state.fun.ordinalizer.format(num, gender);
      }
      this.state.tmp.cite_renders_content = true;
      return ret;
    };
    CSL.Util.Ordinalizer = function(state) {
      this.state = state;
      this.suffixes = {};
    };
    CSL.Util.Ordinalizer.prototype.init = function() {
      if (!this.suffixes[this.state.opt.lang]) {
        this.suffixes[this.state.opt.lang] = {};
        for (var i = 0,
            ilen = 3; i < ilen; i += 1) {
          var gender = [undefined, "masculine", "feminine"][i];
          this.suffixes[this.state.opt.lang][gender] = [];
          for (var j = 1; j < 5; j += 1) {
            var ordinal = this.state.getTerm("ordinal-0" + j, "long", false, gender);
            if ("undefined" === typeof ordinal) {
              delete this.suffixes[this.state.opt.lang][gender];
              break;
            }
            this.suffixes[this.state.opt.lang][gender].push(ordinal);
          }
        }
      }
    };
    CSL.Util.Ordinalizer.prototype.format = function(num, gender) {
      var str;
      num = parseInt(num, 10);
      str = "" + num;
      var suffix = "";
      var trygenders = [];
      if (gender) {
        trygenders.push(gender);
      }
      trygenders.push("neuter");
      if (this.state.locale[this.state.opt.lang].ord["1.0.1"]) {
        suffix = this.state.getTerm("ordinal", false, 0, gender);
        var trygender;
        for (var i = 0,
            ilen = trygenders.length; i < ilen; i += 1) {
          trygender = trygenders[i];
          var ordinfo = this.state.locale[this.state.opt.lang].ord["1.0.1"];
          if (ordinfo["whole-number"][str] && ordinfo["whole-number"][str][trygender]) {
            suffix = this.state.getTerm(this.state.locale[this.state.opt.lang].ord["1.0.1"]["whole-number"][str][trygender], false, 0, gender);
          } else if (ordinfo["last-two-digits"][str.slice(str.length - 2)] && ordinfo["last-two-digits"][str.slice(str.length - 2)][trygender]) {
            suffix = this.state.getTerm(this.state.locale[this.state.opt.lang].ord["1.0.1"]["last-two-digits"][str.slice(str.length - 2)][trygender], false, 0, gender);
          } else if (ordinfo["last-digit"][str.slice(str.length - 1)] && ordinfo["last-digit"][str.slice(str.length - 1)][trygender]) {
            suffix = this.state.getTerm(this.state.locale[this.state.opt.lang].ord["1.0.1"]["last-digit"][str.slice(str.length - 1)][trygender], false, 0, gender);
          }
          if (suffix) {
            break;
          }
        }
      } else {
        if (!gender) {
          gender = undefined;
        }
        this.state.fun.ordinalizer.init();
        if ((num / 10) % 10 === 1 || (num > 10 && num < 20)) {
          suffix = this.suffixes[this.state.opt.lang][gender][3];
        } else if (num % 10 === 1 && num % 100 !== 11) {
          suffix = this.suffixes[this.state.opt.lang][gender][0];
        } else if (num % 10 === 2 && num % 100 !== 12) {
          suffix = this.suffixes[this.state.opt.lang][gender][1];
        } else if (num % 10 === 3 && num % 100 !== 13) {
          suffix = this.suffixes[this.state.opt.lang][gender][2];
        } else {
          suffix = this.suffixes[this.state.opt.lang][gender][3];
        }
      }
      str = str += suffix;
      return str;
    };
    CSL.Util.Romanizer = function() {};
    CSL.Util.Romanizer.prototype.format = function(num) {
      var ret,
          pos,
          n,
          numstr,
          len;
      ret = "";
      if (num < 6000) {
        numstr = num.toString().split("");
        numstr.reverse();
        pos = 0;
        n = 0;
        len = numstr.length;
        for (pos = 0; pos < len; pos += 1) {
          n = parseInt(numstr[pos], 10);
          ret = CSL.ROMAN_NUMERALS[pos][n] + ret;
        }
      }
      return ret;
    };
    CSL.Util.Suffixator = function(slist) {
      if (!slist) {
        slist = CSL.SUFFIX_CHARS;
      }
      this.slist = slist.split(",");
    };
    CSL.Util.Suffixator.prototype.format = function(N) {
      var X;
      N += 1;
      var key = "";
      do {
        X = ((N % 26) === 0) ? 26 : (N % 26);
        key = this.slist[X - 1] + key;
        N = (N - X) / 26;
      } while (N !== 0);
      return key;
    };
    CSL.Engine.prototype.processNumber = function(node, ItemObject, variable, type) {
      var val,
          m,
          i,
          ilen,
          j,
          jlen;
      var debug = false;
      var me = this;
      function normalizeFieldValue(str, defaultLabel) {
        str = str.trim();
        var m = str.match(/^([^ ]+)/);
        if (m && !CSL.STATUTE_SUBDIV_STRINGS[m[1]]) {
          var embeddedLabel = null;
          if (variable === "locator") {
            if (ItemObject.label) {
              embeddedLabel = CSL.STATUTE_SUBDIV_STRINGS_REVERSE[ItemObject.label];
            } else {
              embeddedLabel = "p.";
            }
          } else {
            embeddedLabel = CSL.STATUTE_SUBDIV_STRINGS_REVERSE[variable];
          }
          if (embeddedLabel) {
            str = embeddedLabel + " " + str;
          }
        }
        return str;
      }
      function composeNumberInfo(origLabel, label, val, joiningSuffix) {
        joiningSuffix = joiningSuffix ? joiningSuffix : "";
        var info = {};
        if (!label && !CSL.STATUTE_SUBDIV_STRINGS_REVERSE[variable]) {
          label = "var:" + variable;
        }
        if (label) {
          var m = label.match(/(\s*)([^\s]*)(\s*)/);
          info.label = m[2];
          info.origLabel = origLabel;
          info.labelSuffix = m[3] ? m[3] : "";
          info.plural = 0;
          info.labelVisibility = false;
        }
        var m = val.match(/^([a-zA-Z]0*)([0-9]+(?:[a-zA-Z]*|[-,a-zA-Z]+))$/);
        if (m) {
          info.particle = m[1];
          info.value = m[2];
        } else {
          info.particle = "";
          info.value = val;
        }
        info.joiningSuffix = joiningSuffix.replace(/\s*-\s*/, "-");
        return info;
      }
      ;
      function fixupSubsections(elems) {
        for (var i = elems.length - 2; i > -1; i -= 2) {
          if (elems[i] === "-" && elems[i - 1].match(/^(?:(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z])\.  *)*[0-9]+[,a-zA-Z]+$/) && elems[i + 1].match(/^[,a-zA-Z]+$/)) {
            elems[i - 1] = elems.slice(i - 1, i + 2).join("");
            elems = elems.slice(0, i).concat(elems.slice(i + 2));
          }
        }
        return elems;
      }
      function parseString(str, defaultLabel) {
        defaultLabel = defaultLabel ? defaultLabel : "";
        str = normalizeFieldValue(str, defaultLabel);
        var elems = [];
        var m = str.match(/(,\s+|\s*\\*[\-\u2013]+\s*|\s*&\s*)/g);
        if (m) {
          var lst = str.split(/(?:,\s+|\s*\\*[\-\u2013]+\s*|\s*&\s*)/);
          for (var i = 0,
              ilen = lst.length - 1; i < ilen; i++) {
            elems.push(lst[i]);
            elems.push(m[i]);
          }
          elems.push(lst[lst.length - 1]);
          elems = fixupSubsections(elems);
        } else {
          var elems = [str];
        }
        var values = [];
        var label = defaultLabel;
        var origLabel = "";
        for (var i = 0,
            ilen = elems.length; i < ilen; i += 2) {
          var m = elems[i].match(/((?:^| )(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z])\. *)/g);
          if (m) {
            var lst = elems[i].split(/(?:(?:^| )(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z])\. *)/);
            if (i === 0) {
              var slug = m[0].trim();
              if (!CSL.STATUTE_SUBDIV_STRINGS[slug] || !me.getTerm(CSL.STATUTE_SUBDIV_STRINGS[slug]) || (["locator", "number"].indexOf(variable) === -1 && CSL.STATUTE_SUBDIV_STRINGS[slug] !== variable)) {
                m = m.slice(1);
                lst[0] = lst[0] + " " + slug + " " + lst[1];
                lst = lst.slice(0, 1).concat(lst.slice(2));
              }
            }
            for (var j = 0,
                jlen = lst.length; j < jlen; j++) {
              if (lst[j] || j === (lst.length - 1)) {
                label = m[j - 1] ? m[j - 1] : label;
                var origLabel = j > 1 ? m[j - 1] : "";
                var str = lst[j] ? lst[j].trim() : "";
                if (j === (lst.length - 1)) {
                  values.push(composeNumberInfo(origLabel, label, str, elems[i + 1]));
                } else {
                  values.push(composeNumberInfo(origLabel, label, str));
                }
              }
            }
          } else {
            values.push(composeNumberInfo(origLabel, label, elems[i], elems[i + 1]));
          }
        }
        return values;
      }
      function setSpaces(values) {
        for (var i = 0,
            ilen = values.length - 1; i < ilen; i++) {
          if (!values[i].joiningSuffix && values[i + 1].label) {
            values[i].joiningSuffix = " ";
          }
        }
      }
      function fixNumericAndCount(values, i, currentLabelInfo) {
        var master = values[currentLabelInfo.pos];
        var val = values[i].value;
        var isEscapedHyphen = master.joiningSuffix === "\\-";
        if (val.particle && val.particle !== master.particle) {
          currentLabelInfo.collapsible = false;
        }
        var mVal = val.match(/^[0-9]+([-,:a-zA-Z]*)$/);
        var mCurrentLabel = master.value.match(/^[0-9]+([-,:a-zA-Z]*)$/);
        if (!val || !mVal || !mCurrentLabel || isEscapedHyphen) {
          currentLabelInfo.collapsible = false;
          if (!val || !mCurrentLabel) {
            currentLabelInfo.numeric = false;
          }
          if (isEscapedHyphen) {
            currentLabelInfo.count--;
          }
        }
        if ((mVal && mVal[1]) || (mCurrentLabel && mCurrentLabel[1])) {
          currentLabelInfo.collapsible = false;
        }
        var isCollapsible = currentLabelInfo.collapsible;
        if (!isCollapsible && i > 0 && val.match(/^[ivxlcmIVXLCM]+$/) && values[i - 1].value.match(/^[ivxlcmIVXLCM]+$/)) {
          isCollapsible = true;
        }
        for (var j = currentLabelInfo.pos,
            jlen = values.length; j < jlen; j++) {
          if (currentLabelInfo.label === values[j].label && currentLabelInfo.count > 1 && isCollapsible) {
            values[j].plural = 1;
          }
          values[j].numeric = currentLabelInfo.numeric;
          values[j].collapsible = currentLabelInfo.collapsible;
        }
        currentLabelInfo.label = values[i].label;
        currentLabelInfo.count = 1;
        currentLabelInfo.pos = i;
        currentLabelInfo.numeric = true;
        currentLabelInfo.collapsible = true;
      }
      function setPluralsAndNumerics(values) {
        var currentLabelInfo = {
          label: null,
          count: 1,
          numeric: true,
          collapsible: true,
          pos: 0
        };
        var masterLabel = values.length ? values[0].label : null;
        for (var i = 0,
            ilen = values.length; i < ilen; i++) {
          if (values[i].label) {
            if (values[i].label === currentLabelInfo.label) {
              currentLabelInfo.count++;
            } else {
              fixNumericAndCount(values, i, currentLabelInfo);
              if (currentLabelInfo.pos === 0) {
                if (variable === "locator" || variable === "number") {
                  if (!me.getTerm(CSL.STATUTE_SUBDIV_STRINGS[currentLabelInfo.label]) && currentLabelInfo.label.slice(0, 4) !== "var:") {
                    values[currentLabelInfo.pos].labelVisibility = true;
                  }
                }
                if (["locator", "number"].indexOf(variable) === -1) {
                  if (CSL.STATUTE_SUBDIV_STRINGS[currentLabelInfo.label] !== variable && currentLabelInfo.label.slice(0, 4) !== "var:") {
                    values[0].labelVisibility = true;
                  }
                }
              } else {
                if (values[i - 1].label !== values[i].label && currentLabelInfo.label.slice(0, 4) !== "var:") {
                  values[currentLabelInfo.pos].labelVisibility = true;
                }
              }
            }
          }
        }
        fixNumericAndCount(values, values.length - 1, currentLabelInfo);
        if (values.length && values[0].numeric && variable.slice(0, 10) === "number-of-") {
          if (parseInt(ItemObject[variable], 10) > 1) {
            values[0].plural = 1;
          }
        }
        for (var i = 0,
            ilen = values.length; i < ilen; i++) {
          if (!values[i].numeric) {
            var origLabel = values[i].origLabel ? values[i].origLabel : "";
            values[i].value = (origLabel + values[i].value).trim();
            if (values[i].label !== values[0].label) {
              values[i].label = "";
            }
          }
        }
      }
      function setStyling(values) {
        var masterNode = CSL.Util.cloneToken(node);
        var masterStyling = new CSL.Token();
        masterStyling.range_prefix = node.range_prefix;
        masterStyling.successor_prefix = node.successor_prefix;
        if (!me.tmp.just_looking) {
          for (var j = masterNode.decorations.length - 1; j > -1; j--) {
            if (masterNode.decorations[j][0] === "@quotes") {
              masterStyling.decorations = masterStyling.decorations.concat(masterNode.decorations.slice(j, j + 1));
              masterNode.decorations = masterNode.decorations.slice(0, j).concat(masterNode.decorations.slice(j + 1));
            }
          }
          masterStyling.strings.prefix = masterNode.strings.prefix;
          masterNode.strings.prefix = "";
          masterStyling.strings.suffix = masterNode.strings.suffix;
          masterNode.strings.suffix = "";
        }
        var masterLabel = values.length ? values[0].label : null;
        if (values.length) {
          for (var i = 0,
              ilen = values.length; i < ilen; i++) {
            var val = values[i];
            var newnode = CSL.Util.cloneToken(masterNode);
            newnode.gender = node.gender;
            if (masterLabel === val.label) {
              newnode.formatter = node.formatter;
            }
            if (val.numeric) {
              newnode.successor_prefix = val.successor_prefix;
            }
            newnode.strings.suffix = newnode.strings.suffix + stripHyphenBackslash(val.joiningSuffix);
            val.styling = newnode;
          }
          if (!me.tmp.just_looking) {
            if (values[0].value.slice(0, 1) === "\"" && values[values.length - 1].value.slice(-1) === "\"") {
              values[0].value = values[0].value.slice(1);
              values[values.length - 1].value = values[values.length - 1].value.slice(0, -1);
              masterStyling.decorations.push(["@quotes", true]);
            }
          }
        }
        return masterStyling;
      }
      function stripHyphenBackslash(joiningSuffix) {
        return joiningSuffix.replace("\\-", "-");
      }
      function fixupRangeDelimiter(variable, val, rangeDelimiter, isNumeric) {
        var isPage = checkPage(variable, val);
        if (rangeDelimiter === "-") {
          if (isNumeric) {
            if (isPage || (variable === "locator" && val.label === "art.") || ["issue", "volume", "edition", "number"].indexOf(variable) > -1) {
              rangeDelimiter = me.getTerm("page-range-delimiter");
              if (!rangeDelimiter) {
                rangeDelimiter = "\u2013";
              }
            }
            if (variable === "collection-number") {
              rangeDelimiter = me.getTerm("year-range-delimiter");
              if (!rangeDelimiter) {
                rangeDelimiter = "\u2013";
              }
            }
          }
        }
        return rangeDelimiter;
      }
      function checkPage(variable, val) {
        return variable === "page" || (variable === "locator" && (["p.", "para.", "ch."].indexOf(val.label) > -1));
      }
      function manglePageNumbers(values, i, currentInfo) {
        if (i < 1)
          return;
        if (currentInfo.count !== 2) {
          return;
        }
        if (values[i - 1].particle !== values[i].particle) {
          return;
        }
        if (values[i - 1].joiningSuffix !== "-") {
          currentInfo.count = 1;
          return;
        }
        if (!me.opt["page-range-format"] && parseInt(values[i - 1].value, 10) > parseInt(values[i].value, 10)) {
          values[i - 1].joiningSuffix = fixupRangeDelimiter(variable, values[i], values[i - 1].joiningSuffix, true);
          return;
        }
        var val = values[i];
        var isPage = checkPage(variable, val);
        if (isPage) {
          var str = values[i - 1].particle + values[i - 1].value + " - " + values[i].particle + values[i].value;
          str = me.fun.page_mangler(str);
        } else {
          str = values[i - 1].value + stripHyphenBackslash(values[i - 1].joiningSuffix) + values[i].value;
        }
        var m = str.match(/^([a-zA-Z]?0*)([0-9]+)(\s*[^0-9]+\s*)([-,a-zA-Z]?0*)([0-9]+)$/);
        if (m) {
          var rangeDelimiter = m[3];
          rangeDelimiter = fixupRangeDelimiter(variable, val, rangeDelimiter, values[i].numeric);
          values[i - 1].particle = m[1];
          values[i - 1].value = m[2];
          values[i - 1].joiningSuffix = rangeDelimiter;
          values[i].particle = m[4];
          values[i].value = m[5];
        }
        currentInfo.count = 0;
      }
      function fixRanges(values) {
        if (!node)
          return;
        if (["page", "page-first", "chapter-number", "collection-number", "edition", "issue", "number", "number-of-pages", "number-of-volumes", "volume", "locator"].indexOf(variable) === -1)
          return;
        var currentInfo = {
          count: 0,
          label: null,
          lastHadRangeDelimiter: false
        };
        for (var i = 0,
            ilen = values.length; i < ilen; i++) {
          var val = values[i];
          if (!val.collapsible) {
            currentInfo.count = 0;
            currentInfo.label = null;
            var isNumeric = val.numeric;
            if (i < (values.length - 1) && !isNumeric && val.value.match(/^[ivxlcmIVXLCM]+$/) && values[i + 1].value.match(/^[ivxlcmIVXLCM]+$/)) {
              isNumeric = true;
            }
            val.joiningSuffix = fixupRangeDelimiter(variable, val, val.joiningSuffix, isNumeric);
          } else if (currentInfo.label === val.label && val.joiningSuffix === "-") {
            currentInfo.count = 1;
          } else if (currentInfo.label === val.label && val.joiningSuffix !== "-") {
            currentInfo.count++;
            if (currentInfo.count === 2) {
              manglePageNumbers(values, i, currentInfo);
            }
          } else if (currentInfo.label !== val.label) {
            currentInfo.label = val.label;
            currentInfo.count = 1;
          } else {
            currentInfo.count = 1;
            currentInfo.label = val.label;
          }
        }
        if (currentInfo.count === 2) {
          manglePageNumbers(values, values.length - 1, currentInfo);
        }
      }
      function setVariableParams(obj, values) {
        if (values.length) {
          obj.numeric = values[0].numeric;
          obj.collapsible = values[0].collapsible;
          obj.plural = values[0].plural;
          obj.label = CSL.STATUTE_SUBDIV_STRINGS[values[0].label];
        }
      }
      if (node && this.tmp.shadow_numbers[variable] && this.tmp.shadow_numbers[variable].values.length) {
        var values = this.tmp.shadow_numbers[variable].values;
        fixRanges(values);
        this.tmp.shadow_numbers[variable].masterStyling = setStyling(values);
        return;
      }
      if (!this.tmp.shadow_numbers[variable]) {
        this.tmp.shadow_numbers[variable] = {values: []};
      }
      if (!ItemObject) {
        return;
      }
      var languageRole = CSL.LangPrefsMap[variable];
      if (languageRole) {
        var localeType = this.opt["cite-lang-prefs"][languageRole][0];
        val = this.transform.getTextSubField(ItemObject, variable, "locale-" + localeType, true);
        val = val.name;
      } else if (variable === "year-suffix" && this.registry.registry[ItemObject.id]) {
        this.opt.has_year_suffix = true;
        val = parseInt(this.registry.registry[ItemObject.id].disambig.year_suffix, 10);
        if (!val && val !== 0) {
          val = "";
        }
      } else {
        val = ItemObject[variable];
      }
      if (val && this.sys.getAbbreviation) {
        var jurisdiction = this.transform.loadAbbreviation(ItemObject.jurisdiction, "number", val);
        if (this.transform.abbrevs[jurisdiction].number[val]) {
          val = this.transform.abbrevs[jurisdiction].number[val];
        } else {
          if ("undefined" !== typeof this.transform.abbrevs[jurisdiction].number[val]) {
            delete this.transform.abbrevs[jurisdiction].number[val];
          }
        }
      }
      if ("undefined" !== typeof val && ("string" === typeof val || "number" === typeof val)) {
        if ("number" === typeof val) {
          val = "" + val;
        }
        var defaultLabel = CSL.STATUTE_SUBDIV_STRINGS_REVERSE[variable];
        if (!this.tmp.shadow_numbers.values) {
          var values = parseString(val, defaultLabel);
          setSpaces(values);
          setPluralsAndNumerics(values);
          this.tmp.shadow_numbers[variable].values = values;
        }
        if (node) {
          fixRanges(values);
          this.tmp.shadow_numbers[variable].masterStyling = setStyling(values);
        }
        setVariableParams(this.tmp.shadow_numbers[variable], values);
      }
    };
    CSL.Util.outputNumericField = function(state, varname, itemID) {
      state.output.openLevel(state.tmp.shadow_numbers[varname].masterStyling);
      var nums = state.tmp.shadow_numbers[varname].values;
      var masterLabel = nums.length ? nums[0].label : null;
      var masterStyling = state.tmp.shadow_numbers[varname].masterStyling;
      var labelForm = state.tmp.shadow_numbers[varname].labelForm;
      var embeddedLabelForm;
      if (labelForm) {
        embeddedLabelForm = labelForm;
      } else {
        embeddedLabelForm = "short";
      }
      var labelDecorations = state.tmp.shadow_numbers[varname].labelDecorations;
      var lastLabelName = null;
      for (var i = 0,
          ilen = nums.length; i < ilen; i++) {
        var num = nums[i];
        var labelName = CSL.STATUTE_SUBDIV_STRINGS[num.label];
        if (num.label === masterLabel) {
          label = state.getTerm(labelName, labelForm, num.plural);
        } else {
          label = state.getTerm(labelName, embeddedLabelForm, num.plural);
        }
        var labelPlaceholderPos = -1;
        if (label) {
          labelPlaceholderPos = label.indexOf("%s");
        }
        var numStyling = CSL.Util.cloneToken(num.styling);
        numStyling.formatter = num.styling.formatter;
        numStyling.type = num.styling.type;
        numStyling.num = num.styling.num;
        numStyling.gender = num.styling.gender;
        if (labelPlaceholderPos > 0 && labelPlaceholderPos < (label.length - 2)) {
          numStyling.strings.prefix += label.slice(0, labelPlaceholderPos);
          numStyling.strings.suffix = label.slice(labelPlaceholderPos + 2) + numStyling.strings.suffix;
        } else if (num.labelVisibility) {
          if (!label) {
            label = num.label;
            labelName = num.label;
          }
          if (labelPlaceholderPos > 0) {
            var prefixLabelStyling = new CSL.Token();
            prefixLabelStyling.decorations = labelDecorations;
            state.output.append(label.slice(0, labelPlaceholderPos), prefixLabelStyling);
          } else if (labelPlaceholderPos === (label.length - 2) || labelPlaceholderPos === -1) {
            state.output.append(label + num.labelSuffix, "empty");
          }
        }
        if (num.collapsible) {
          if (varname === "year-suffix") {
            numStyling.range_prefix = masterStyling.range_prefix;
            numStyling.successor_prefix = masterStyling.successor_prefix;
          }
          var blob = new CSL.NumericBlob(num.particle, parseInt(num.value, 10), numStyling, itemID);
          if (varname === "year-suffix") {
            state.tmp.has_done_year_suffix = true;
            var formatter = new CSL.Util.Suffixator(CSL.SUFFIX_CHARS);
            blob.setFormatter(formatter);
            if (state[state.tmp.area].opt.cite_group_delimiter) {
              blob.successor_prefix = state[state.tmp.area].opt.cite_group_delimiter;
            } else if (state[state.tmp.area].opt["year-suffix-delimiter"]) {
              blob.successor_prefix = state[state.tmp.area].opt["year-suffix-delimiter"];
            } else {
              blob.successor_prefix = state[state.tmp.area].opt.layout_delimiter;
            }
          }
          if ("undefined" === typeof blob.gender) {
            blob.gender = state.locale[state.opt.lang]["noun-genders"][varname];
          }
          state.output.append(blob, "literal");
        } else {
          state.output.append(num.particle + num.value, numStyling);
        }
        if (labelPlaceholderPos === 0 && labelPlaceholderPos < (label.length - 2)) {
          if (lastLabelName === null) {
            lastLabelName = labelName;
          }
          if (labelName !== lastLabelName || i === (nums.length - 1)) {
            var suffixLabelStyling = new CSL.Token();
            suffixLabelStyling.decorations = labelDecorations;
            state.output.append(label.slice(labelPlaceholderPos + 2), suffixLabelStyling);
          }
        }
        lastLabelName === labelName;
      }
      state.output.closeLevel();
    };
    CSL.Util.PageRangeMangler = {};
    CSL.Util.PageRangeMangler.getFunction = function(state, rangeType) {
      var rangerex,
          pos,
          len,
          stringify,
          listify,
          expand,
          minimize,
          minimize_internal,
          chicago,
          lst,
          m,
          b,
          e,
          ret,
          begin,
          end,
          ret_func,
          ppos,
          llen;
      var range_delimiter = state.getTerm(rangeType + "-range-delimiter");
      rangerex = /([a-zA-Z]*)([0-9]+)\s*(?:\u2013|-)\s*([a-zA-Z]*)([0-9]+)/;
      stringify = function(lst) {
        len = lst.length;
        for (pos = 1; pos < len; pos += 2) {
          if ("object" === typeof lst[pos]) {
            lst[pos] = lst[pos].join("");
          }
        }
        var ret = lst.join("");
        ret = ret.replace(/([^\\])\-/g, "$1" + state.getTerm(rangeType + "-range-delimiter"));
        return ret;
      };
      listify = function(str) {
        var m,
            lst,
            ret;
        var hyphens = "\\s+\\-\\s+";
        var this_range_delimiter = range_delimiter === "-" ? "" : range_delimiter;
        var delimRex = new RegExp("([^\\\\])[-" + this_range_delimiter + "\\u2013]", "g");
        str = str.replace(delimRex, "$1 - ").replace(/\s+-\s+/g, " - ");
        var rexm = new RegExp("([a-zA-Z]*[0-9]+" + hyphens + "[a-zA-Z]*[0-9]+)", "g");
        var rexlst = new RegExp("[a-zA-Z]*[0-9]+" + hyphens + "[a-zA-Z]*[0-9]+");
        m = str.match(rexm);
        lst = str.split(rexlst);
        if (lst.length === 0) {
          ret = m;
        } else {
          ret = [lst[0]];
          for (pos = 1, len = lst.length; pos < len; pos += 1) {
            ret.push(m[pos - 1].replace(/\s*\-\s*/g, "-"));
            ret.push(lst[pos]);
          }
        }
        return ret;
      };
      expand = function(str) {
        str = "" + str;
        lst = listify(str);
        len = lst.length;
        for (pos = 1; pos < len; pos += 2) {
          m = lst[pos].match(rangerex);
          if (m) {
            if (!m[3] || m[1] === m[3]) {
              if (m[4].length < m[2].length) {
                m[4] = m[2].slice(0, (m[2].length - m[4].length)) + m[4];
              }
              if (parseInt(m[2], 10) < parseInt(m[4], 10)) {
                m[3] = range_delimiter + m[1];
                lst[pos] = m.slice(1);
              }
            }
          }
          if ("string" === typeof lst[pos]) {
            lst[pos] = lst[pos].replace(/\-/g, range_delimiter);
          }
        }
        return lst;
      };
      minimize = function(lst, minchars, isyear) {
        len = lst.length;
        for (var i = 1,
            ilen = lst.length; i < ilen; i += 2) {
          lst[i][3] = minimize_internal(lst[i][1], lst[i][3], minchars, isyear);
          if (lst[i][2].slice(1) === lst[i][0]) {
            lst[i][2] = range_delimiter;
          }
        }
        return stringify(lst);
      };
      minimize_internal = function(begin, end, minchars, isyear) {
        if (!minchars) {
          minchars = 0;
        }
        b = ("" + begin).split("");
        e = ("" + end).split("");
        ret = e.slice();
        ret.reverse();
        if (b.length === e.length) {
          for (var i = 0,
              ilen = b.length; i < ilen; i += 1) {
            if (b[i] === e[i] && ret.length > minchars) {
              ret.pop();
            } else {
              if (minchars && isyear && ret.length === 3) {
                var front = b.slice(0, i);
                front.reverse();
                ret = ret.concat(front);
              }
              break;
            }
          }
        }
        ret.reverse();
        return ret.join("");
      };
      chicago = function(lst) {
        len = lst.length;
        for (pos = 1; pos < len; pos += 2) {
          if ("object" === typeof lst[pos]) {
            m = lst[pos];
            begin = parseInt(m[1], 10);
            end = parseInt(m[3], 10);
            if (begin > 100 && begin % 100 && parseInt((begin / 100), 10) === parseInt((end / 100), 10)) {
              m[3] = "" + (end % 100);
            } else if (begin >= 10000) {
              m[3] = "" + (end % 1000);
            }
          }
          if (m[2].slice(1) === m[0]) {
            m[2] = range_delimiter;
          }
        }
        return stringify(lst);
      };
      var sniff = function(str, func, minchars, isyear) {
        var ret;
        str = "" + str;
        var lst = expand(str);
        var ret = func(lst, minchars, isyear);
        return ret;
      };
      if (!state.opt[rangeType + "-range-format"]) {
        ret_func = function(str) {
          return sniff(str, stringify);
        };
      } else if (state.opt[rangeType + "-range-format"] === "expanded") {
        ret_func = function(str) {
          return sniff(str, stringify);
        };
      } else if (state.opt[rangeType + "-range-format"] === "minimal") {
        ret_func = function(str) {
          return sniff(str, minimize);
        };
      } else if (state.opt[rangeType + "-range-format"] === "minimal-two") {
        ret_func = function(str, isyear) {
          return sniff(str, minimize, 2, isyear);
        };
      } else if (state.opt[rangeType + "-range-format"] === "chicago") {
        ret_func = function(str) {
          return sniff(str, chicago);
        };
      }
      return ret_func;
    };
    CSL.Util.FlipFlopper = function(state) {
      var tagdefs,
          pos,
          len,
          p,
          entry,
          allTags,
          ret,
          def,
          esc,
          makeHashes,
          closeTags,
          flipTags,
          openToClose,
          openToDecorations,
          okReverse,
          hashes,
          allTagsLst,
          lst;
      this.state = state;
      this.blob = false;
      this.quotechars = ['"', "'"];
      tagdefs = [["<i>", "</i>", "italics", "@font-style", ["italic", "normal", "normal"], true], ["<b>", "</b>", "bold", "@font-weight", ["bold", "normal", "normal"], true], ["<sup>", "</sup>", "superscript", "@vertical-align", ["sup", "sup", "baseline"], true], ["<sub>", "</sub>", "subscript", "@vertical-align", ["sub", "sub", "baseline"], true], ["<sc>", "</sc>", "smallcaps", "@font-variant", ["small-caps", "small-caps", "normal"], true], ["<span style=\"font-variant:small-caps;\">", "</span>", "smallcaps", "@font-variant", ["small-caps", "normal", "normal"], true], ["<span class=\"nocase\">", "</span>", "passthrough", "@passthrough", ["true", "true", "true"], true], ["<span class=\"nodecor\">", "</span>", "passthrough", "@passthrough", ["true", "true", "true"], true], ['"', '"', "quotes", "@quotes", ["true", "inner", "true"], "'"], [" '", "'", "quotes", "@quotes", ["inner", "true", "true"], '"']];
      for (pos = 0; pos < 2; pos += 1) {
        p = ["-", "-inner-"][pos];
        entry = [];
        var openq = state.getTerm(("open" + p + "quote"));
        entry.push(openq);
        this.quotechars.push(openq);
        var closeq = state.getTerm(("close" + p + "quote"));
        entry.push(closeq);
        this.quotechars.push(closeq);
        entry.push(("quote" + "s"));
        entry.push(("@" + "quote" + "s"));
        if ("-" === p) {
          entry.push(["true", "inner"]);
        } else {
          entry.push(["inner", "true"]);
        }
        entry.push(true);
        if ("-" === p) {
          entry.push(state.getTerm(("close-inner-quote")));
        } else {
          entry.push(state.getTerm(("close-quote")));
        }
        tagdefs.push(entry);
      }
      allTags = function(tagdefs) {
        ret = [];
        len = tagdefs.length;
        for (pos = 0; pos < len; pos += 1) {
          def = tagdefs[pos];
          if (ret.indexOf(def[0]) === -1) {
            esc = "";
            if (["(", ")", "[", "]"].indexOf(def[0]) > -1) {
              esc = "\\";
            }
            ret.push(esc + def[0]);
          }
          if (ret.indexOf(def[1]) === -1) {
            esc = "";
            if (["(", ")", "[", "]"].indexOf(def[1]) > -1) {
              esc = "\\";
            }
            ret.push(esc + def[1]);
          }
        }
        return ret;
      };
      allTagsLst = allTags(tagdefs);
      lst = [];
      for (pos = 0, len = allTagsLst.length; pos < len; pos += 1) {
        if (allTagsLst[pos]) {
          lst.push(allTagsLst[pos]);
        }
      }
      allTagsLst = lst.slice();
      this.allTagsRexMatch = new RegExp("(" + allTagsLst.join("|") + ")", "g");
      this.allTagsRexSplit = new RegExp("(?:" + allTagsLst.join("|") + ")");
      makeHashes = function(tagdefs) {
        closeTags = {};
        flipTags = {};
        openToClose = {};
        openToDecorations = {};
        okReverse = {};
        len = tagdefs.length;
        for (pos = 0; pos < len; pos += 1) {
          closeTags[tagdefs[pos][1]] = true;
          flipTags[tagdefs[pos][1]] = tagdefs[pos][5];
          openToClose[tagdefs[pos][0]] = tagdefs[pos][1];
          openToDecorations[tagdefs[pos][0]] = [tagdefs[pos][3], tagdefs[pos][4]];
          okReverse[tagdefs[pos][3]] = [tagdefs[pos][3], [tagdefs[pos][4][2], tagdefs[pos][1]]];
        }
        return [closeTags, flipTags, openToClose, openToDecorations, okReverse];
      };
      hashes = makeHashes(tagdefs);
      this.closeTagsHash = hashes[0];
      this.flipTagsHash = hashes[1];
      this.openToCloseHash = hashes[2];
      this.openToDecorations = hashes[3];
      this.okReverseHash = hashes[4];
    };
    CSL.Util.FlipFlopper.prototype.init = function(str, blob) {
      this.txt_esc = CSL.getSafeEscape(this.state);
      if (!blob) {
        this.strs = this.getSplitStrings(str);
        this.blob = new CSL.Blob();
      } else {
        this.blob = blob;
        this.strs = this.getSplitStrings(this.blob.blobs);
        this.blob.blobs = [];
      }
      this.blobstack = new CSL.Stack(this.blob);
    };
    CSL.Util.FlipFlopper.prototype._normalizeString = function(str) {
      var i,
          ilen;
      str = str.replace(/\s+'\s+/g, "  ");
      if (str.indexOf(this.quotechars[0]) > -1) {
        var oldStr = null;
        while (str !== oldStr) {
          oldStr = str;
          for (i = 0, ilen = 2; i < ilen; i += 1) {
            if (this.quotechars[i + 2]) {
              str = str.split(this.quotechars[i + 2]).join(this.quotechars[0]);
            }
          }
        }
      }
      if (str.indexOf(this.quotechars[1]) > -1) {
        for (i = 0, ilen = 2; i < ilen; i += 1) {
          if (this.quotechars[i + 4]) {
            if (i === 0 && this.quotechars[i + 4] !== this.quotechars[1]) {
              str = str.split(this.quotechars[i + 4]).join(" " + this.quotechars[1]);
            } else {
              str = str.split(this.quotechars[i + 4]).join(this.quotechars[1]);
            }
          }
        }
      }
      return str;
    };
    CSL.Util.FlipFlopper.prototype.getSplitStrings = function(str) {
      var strs,
          pos,
          len,
          newstr,
          head,
          tail,
          expected_closers,
          expected_openers,
          expected_flips,
          tagstack,
          badTagStack,
          posA,
          sameAsOpen,
          openRev,
          flipRev,
          tag,
          ibeenrunned,
          posB,
          wanted_closer,
          posC,
          sep,
          resplice,
          params,
          lenA,
          lenB,
          lenC,
          badTagPos,
          mx,
          myret;
      str = this._normalizeString(str);
      mx = str.match(this.allTagsRexMatch);
      strs = str.split(this.allTagsRexSplit);
      myret = [strs[0]];
      for (pos = 1, len = strs.length; pos < len; pos += 1) {
        myret.push(mx[pos - 1]);
        myret.push(strs[pos]);
      }
      strs = myret.slice();
      len = strs.length - 2;
      for (pos = len; pos > 0; pos += -2) {
        if (strs[(pos - 1)].slice((strs[(pos - 1)].length - 1)) === "\\") {
          newstr = strs[(pos - 1)].slice(0, (strs[(pos - 1)].length - 1)) + strs[pos] + strs[(pos + 1)];
          head = strs.slice(0, (pos - 1));
          tail = strs.slice((pos + 2));
          head.push(newstr);
          strs = head.concat(tail);
        }
      }
      expected_closers = [];
      expected_openers = [];
      expected_flips = [];
      tagstack = [];
      badTagStack = [];
      lenA = strs.length - 1;
      for (posA = 1; posA < lenA; posA += 2) {
        tag = strs[posA];
        if (this.closeTagsHash[tag]) {
          expected_closers.reverse();
          sameAsOpen = this.openToCloseHash[tag];
          openRev = expected_closers.indexOf(tag);
          flipRev = expected_flips.indexOf(tag);
          expected_closers.reverse();
          if (!sameAsOpen || (openRev > -1 && (openRev < flipRev || flipRev === -1))) {
            ibeenrunned = false;
            lenB = expected_closers.length - 1;
            for (posB = lenB; posB > -1; posB += -1) {
              ibeenrunned = true;
              wanted_closer = expected_closers[posB];
              if (tag === wanted_closer) {
                expected_closers.pop();
                expected_openers.pop();
                expected_flips.pop();
                tagstack.pop();
                break;
              }
              badTagStack.push(posA);
            }
            if (!ibeenrunned) {
              badTagStack.push(posA);
            }
            continue;
          }
        }
        if (this.openToCloseHash[tag]) {
          expected_closers.push(this.openToCloseHash[tag]);
          expected_openers.push(tag);
          expected_flips.push(this.flipTagsHash[tag]);
          tagstack.push(posA);
        }
      }
      lenC = expected_closers.length - 1;
      for (posC = lenC; posC > -1; posC += -1) {
        expected_closers.pop();
        expected_flips.pop();
        expected_openers.pop();
        badTagStack.push(tagstack.pop());
      }
      badTagStack.sort(function(a, b) {
        if (a < b) {
          return 1;
        } else if (a > b) {
          return -1;
        }
        return 0;
      });
      len = badTagStack.length;
      for (pos = 0; pos < len; pos += 1) {
        badTagPos = badTagStack[pos];
        head = strs.slice(0, (badTagPos - 1));
        tail = strs.slice((badTagPos + 2));
        sep = strs[badTagPos];
        if (sep.length && sep[0] !== "<" && this.openToDecorations[sep] && this.quotechars.indexOf(sep.replace(/\s+/g, "")) === -1) {
          params = this.openToDecorations[sep];
          sep = this.state.fun.decorate[params[0]][params[1][0]](this.state);
        }
        resplice = strs[(badTagPos - 1)] + sep + strs[(badTagPos + 1)];
        head.push(resplice);
        strs = head.concat(tail);
      }
      len = strs.length;
      for (pos = 0; pos < len; pos += 2) {
        strs[pos] = strs[pos].split("'").join("\u2019");
        strs[pos] = strs[pos].split("  \u2019").join(" \u2019");
      }
      return strs;
    };
    CSL.Util.FlipFlopper.prototype.processTags = function() {
      var expected_closers,
          expected_openers,
          expected_flips,
          expected_rendering,
          str,
          posA,
          tag,
          prestr,
          newblob,
          blob,
          sameAsOpen,
          openRev,
          flipRev,
          posB,
          wanted_closer,
          newblobnest,
          param,
          fulldecor,
          level,
          decor,
          lenA,
          lenB,
          posC,
          lenC;
      expected_closers = [];
      expected_openers = [];
      expected_flips = [];
      expected_rendering = [];
      str = "";
      if (this.strs.length === 1) {
        this.blob.blobs = this.strs[0];
      } else if (this.strs.length > 2) {
        lenA = (this.strs.length - 1);
        for (posA = 1; posA < lenA; posA += 2) {
          tag = this.strs[posA];
          prestr = this.strs[(posA - 1)];
          if (prestr) {
            newblob = new CSL.Blob(prestr);
            blob = this.blobstack.value();
            blob.push(newblob);
          }
          if (this.closeTagsHash[tag]) {
            expected_closers.reverse();
            sameAsOpen = this.openToCloseHash[tag];
            openRev = expected_closers.indexOf(tag);
            flipRev = expected_flips.indexOf(tag);
            expected_closers.reverse();
            if (!sameAsOpen || (openRev > -1 && (openRev < flipRev || flipRev === -1))) {
              lenB = expected_closers.length;
              for (posB = lenB; posB > -1; posB += -1) {
                wanted_closer = expected_closers[posB];
                if (tag === wanted_closer) {
                  expected_closers.pop();
                  expected_openers.pop();
                  expected_flips.pop();
                  expected_rendering.pop();
                  this.blobstack.pop();
                  break;
                }
              }
              continue;
            }
          }
          if (this.openToCloseHash[tag]) {
            expected_closers.push(this.openToCloseHash[tag]);
            expected_openers.push(tag);
            expected_flips.push(this.flipTagsHash[tag]);
            blob = this.blobstack.value();
            newblobnest = new CSL.Blob();
            blob.push(newblobnest);
            param = this.addFlipFlop(newblobnest, this.openToDecorations[tag]);
            if (tag === "<span class=\"nodecor\">") {
              fulldecor = this.state[this.state.tmp.area].opt.topdecor.concat(this.blob.alldecor).concat([[["@quotes", "inner"]]]);
              lenB = fulldecor.length;
              for (posB = 0; posB < lenB; posB += 1) {
                level = fulldecor[posB];
                lenC = level.length;
                for (posC = 0; posC < lenC; posC += 1) {
                  decor = level[posC];
                  if (["@font-style", "@font-weight", "@font-variant"].indexOf(decor[0]) > -1) {
                    param = this.addFlipFlop(newblobnest, this.okReverseHash[decor[0]]);
                  }
                }
              }
            }
            expected_rendering.push(this.state.fun.decorate[param[0]][param[1]](this.state));
            this.blobstack.push(newblobnest);
          }
        }
        if (this.strs.length > 2) {
          str = this.strs[(this.strs.length - 1)];
          if (str) {
            blob = this.blobstack.value();
            newblob = new CSL.Blob(str);
            blob.push(newblob);
          }
        }
      }
      return this.blob;
    };
    CSL.Util.FlipFlopper.prototype.addFlipFlop = function(blob, fun) {
      var posA,
          posB,
          fulldecor,
          lenA,
          decorations,
          breakme,
          decor,
          posC,
          newdecor,
          lenC;
      posB = 0;
      fulldecor = this.state[this.state.tmp.area].opt.topdecor.concat(blob.alldecor).concat([[["@quotes", "inner"]]]);
      lenA = fulldecor.length;
      for (posA = 0; posA < lenA; posA += 1) {
        decorations = fulldecor[posA];
        breakme = false;
        lenC = decorations.length - 1;
        for (posC = lenC; posC > -1; posC += -1) {
          decor = decorations[posC];
          if (decor[0] === fun[0]) {
            if (decor[1] === fun[1][0]) {
              posB = 1;
            }
            breakme = true;
            break;
          }
        }
        if (breakme) {
          break;
        }
      }
      newdecor = [fun[0], fun[1][posB]];
      blob.decorations.reverse();
      blob.decorations.push(newdecor);
      blob.decorations.reverse();
      return newdecor;
    };
    CSL.Output.Formatters = {};
    CSL.getSafeEscape = function(state) {
      if (["bibliography", "citation"].indexOf(state.tmp.area) > -1) {
        var callbacks = [];
        if (state.opt.development_extensions.thin_non_breaking_space_html_hack && state.opt.mode === "html") {
          callbacks.push(function(txt) {
            return txt.replace(/\u202f/g, '<span style="white-space:nowrap">&thinsp;</span>');
          });
        }
        if (callbacks.length) {
          return function(txt) {
            for (var i = 0,
                ilen = callbacks.length; i < ilen; i += 1) {
              txt = callbacks[i](txt);
            }
            return CSL.Output.Formats[state.opt.mode].text_escape(txt);
          };
        } else {
          return CSL.Output.Formats[state.opt.mode].text_escape;
        }
      } else {
        return function(txt) {
          return txt;
        };
      }
    };
    CSL.Output.Formatters.passthrough = function(state, string) {
      return string;
    };
    CSL.Output.Formatters.lowercase = function(state, string) {
      var str = CSL.Output.Formatters.doppelString(string, CSL.TAG_USEALL);
      str.string = str.string.toLowerCase();
      return CSL.Output.Formatters.undoppelString(str);
    };
    CSL.Output.Formatters.uppercase = function(state, string) {
      var str = CSL.Output.Formatters.doppelString(string, CSL.TAG_USEALL);
      str.string = str.string.toUpperCase();
      return CSL.Output.Formatters.undoppelString(str);
    };
    CSL.Output.Formatters["capitalize-first"] = function(state, string) {
      var str = CSL.Output.Formatters.doppelString(string, CSL.TAG_ESCAPE);
      if (str.string.length) {
        str.string = str.string.slice(0, 1).toUpperCase() + str.string.substr(1);
        return CSL.Output.Formatters.undoppelString(str);
      } else {
        return "";
      }
    };
    CSL.Output.Formatters.sentence = function(state, string) {
      var str = CSL.Output.Formatters.doppelString(string, CSL.TAG_ESCAPE);
      str.string = str.string.slice(0, 1).toUpperCase() + str.string.substr(1).toLowerCase();
      return CSL.Output.Formatters.undoppelString(str);
    };
    CSL.Output.Formatters["capitalize-all"] = function(state, string) {
      var str = CSL.Output.Formatters.doppelString(string, CSL.TAG_ESCAPE);
      var strings = str.string.split(" ");
      for (var i = 0,
          ilen = strings.length; i < ilen; i += 1) {
        if (strings[i].length > 1) {
          if (state.opt.development_extensions.allow_force_lowercase) {
            strings[i] = strings[i].slice(0, 1).toUpperCase() + strings[i].substr(1).toLowerCase();
          } else {
            strings[i] = strings[i].slice(0, 1).toUpperCase() + strings[i].substr(1);
          }
        } else if (strings[i].length === 1) {
          strings[i] = strings[i].toUpperCase();
        }
      }
      str.string = strings.join(" ");
      return CSL.Output.Formatters.undoppelString(str);
    };
    CSL.Output.Formatters.title = function(state, string) {
      var str,
          words,
          isAllUpperCase,
          newString,
          lastWordIndex,
          previousWordIndex,
          upperCaseVariant,
          lowerCaseVariant,
          pos,
          skip,
          notfirst,
          notlast,
          aftercolon,
          len,
          idx,
          tmp,
          skipword,
          ppos,
          mx,
          lst,
          myret;
      var SKIP_WORDS = state.locale[state.opt.lang].opts["skip-words"];
      if (!string) {
        return "";
      }
      var doppel = CSL.Output.Formatters.doppelString(string, CSL.TAG_ESCAPE, SKIP_WORDS);
      function capitalise(word, force) {
        var m = word.match(/([:?!]+\s+|-|^)((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]))(.*)/);
        if (m && !(m[2].match(/^[\u0370-\u03FF]$/) && !m[3])) {
          return m[1] + m[2].toUpperCase() + m[3];
        }
        return word;
      }
      function splitme(str, rex) {
        var res,
            seps = str.match(rex);
        if (seps) {
          var splits = str.split(rex);
          res = [splits[0]];
          for (var i = 0; i < seps.length; i++) {
            res.push(seps[i]);
            res.push(splits[i + 1]);
          }
        } else {
          res = [str];
        }
        return res;
      }
      var str = doppel.string;
      var lst = splitme(str, state.locale[state.opt.lang].opts["skip-words-regexp"]);
      for (i = 1, ilen = lst.length; i < ilen; i += 2) {
        if (lst[i].match(/^[:?!]/)) {
          lst[i] = capitalise(lst[i]);
        }
      }
      if (!lst[0] && lst[1]) {
        lst[1] = capitalise(lst[1]);
      }
      if (lst.length > 2 && !lst[lst.length - 1]) {
        lst[lst.length - 2] = capitalise(lst[lst.length - 2]);
      }
      for (var i = 0,
          ilen = lst.length; i < ilen; i += 2) {
        var words = lst[i].split(/([:?!]*\s+|-)/);
        for (var k = 0,
            klen = words.length; k < klen; k += 2) {
          if (words[k].length !== 0) {
            upperCaseVariant = words[k].toUpperCase();
            lowerCaseVariant = words[k].toLowerCase();
            if (words[k].match(/[0-9]/)) {
              continue;
            }
            if (words[k] === lowerCaseVariant) {
              words[k] = capitalise(words[k]);
            }
          }
        }
        lst[i] = words.join("");
      }
      doppel.string = lst.join("");
      var ret = CSL.Output.Formatters.undoppelString(doppel);
      return ret;
    };
    CSL.Output.Formatters.doppelString = function(string, rex, stopWords) {
      var ret,
          pos,
          len;
      ret = {};
      ret.array = rex(string, stopWords);
      ret.string = "";
      for (var i = 0,
          ilen = ret.array.length; i < ilen; i += 2) {
        if (ret.array[i - 1] === "-" && false) {
          ret.string += " " + ret.array[i];
        } else {
          ret.string += ret.array[i];
        }
      }
      return ret;
    };
    CSL.Output.Formatters.undoppelString = function(str) {
      var ret,
          len,
          pos;
      ret = "";
      for (var i = 0,
          ilen = str.array.length; i < ilen; i += 1) {
        if ((i % 2)) {
          ret += str.array[i];
        } else {
          if (str.array[i - 1] === "-" && false) {
            ret += str.string.slice(0, str.array[i].length + 1).slice(1);
            str.string = str.string.slice(str.array[i].length + 1);
          } else {
            ret += str.string.slice(0, str.array[i].length);
            str.string = str.string.slice(str.array[i].length);
          }
        }
      }
      return ret;
    };
    CSL.Output.Formatters.serializeItemAsRdf = function(Item) {
      return "";
    };
    CSL.Output.Formatters.serializeItemAsRdfA = function(Item) {
      return "";
    };
    CSL.demoteNoiseWords = function(state, fld, drop_or_demote) {
      var SKIP_WORDS = state.locale[state.opt.lang].opts["leading-noise-words"];
      if (fld && drop_or_demote) {
        fld = fld.split(/\s+/);
        fld.reverse();
        var toEnd = [];
        for (var j = fld.length - 1; j > -1; j += -1) {
          if (SKIP_WORDS.indexOf(fld[j].toLowerCase()) > -1) {
            toEnd.push(fld.pop());
          } else {
            break;
          }
        }
        fld.reverse();
        var start = fld.join(" ");
        var end = toEnd.join(" ");
        if ("drop" === drop_or_demote || !end) {
          fld = start;
        } else if ("demote" === drop_or_demote) {
          fld = [start, end].join(", ");
        }
      }
      return fld;
    };
    CSL.Output.Formats = function() {};
    CSL.Output.Formats.prototype.html = {
      "text_escape": function(text) {
        if (!text) {
          text = "";
        }
        return text.replace(/&/g, "&#38;").replace(/</g, "&#60;").replace(/>/g, "&#62;").replace(/\s\s/g, "\u00A0 ").replace(CSL.SUPERSCRIPTS_REGEXP, function(aChar) {
          return "<sup>" + CSL.SUPERSCRIPTS[aChar] + "</sup>";
        });
      },
      "bibstart": "<div class=\"csl-bib-body\">\n",
      "bibend": "</div>",
      "@font-style/italic": "<i>%%STRING%%</i>",
      "@font-style/oblique": "<em>%%STRING%%</em>",
      "@font-style/normal": "<span style=\"font-style:normal;\">%%STRING%%</span>",
      "@font-variant/small-caps": "<span style=\"font-variant:small-caps;\">%%STRING%%</span>",
      "@passthrough/true": CSL.Output.Formatters.passthrough,
      "@font-variant/normal": "<span style=\"font-variant:normal;\">%%STRING%%</span>",
      "@font-weight/bold": "<b>%%STRING%%</b>",
      "@font-weight/normal": "<span style=\"font-weight:normal;\">%%STRING%%</span>",
      "@font-weight/light": false,
      "@text-decoration/none": "<span style=\"text-decoration:none;\">%%STRING%%</span>",
      "@text-decoration/underline": "<span style=\"text-decoration:underline;\">%%STRING%%</span>",
      "@vertical-align/sup": "<sup>%%STRING%%</sup>",
      "@vertical-align/sub": "<sub>%%STRING%%</sub>",
      "@vertical-align/baseline": "<span style=\"baseline\">%%STRING%%</span>",
      "@strip-periods/true": CSL.Output.Formatters.passthrough,
      "@strip-periods/false": CSL.Output.Formatters.passthrough,
      "@quotes/true": function(state, str) {
        if ("undefined" === typeof str) {
          return state.getTerm("open-quote");
        }
        return state.getTerm("open-quote") + str + state.getTerm("close-quote");
      },
      "@quotes/inner": function(state, str) {
        if ("undefined" === typeof str) {
          return "\u2019";
        }
        return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
      },
      "@quotes/false": false,
      "@cite/entry": function(state, str) {
        return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
      },
      "@bibliography/entry": function(state, str) {
        var insert = "";
        if (state.sys.embedBibliographyEntry) {
          insert = state.sys.embedBibliographyEntry(this.item_id) + "\n";
        }
        return "  <div class=\"csl-entry\">" + str + "</div>\n" + insert;
      },
      "@display/block": function(state, str) {
        return "\n\n    <div class=\"csl-block\">" + str + "</div>\n";
      },
      "@display/left-margin": function(state, str) {
        return "\n    <div class=\"csl-left-margin\">" + str + "</div>";
      },
      "@display/right-inline": function(state, str) {
        return "<div class=\"csl-right-inline\">" + str + "</div>\n  ";
      },
      "@display/indent": function(state, str) {
        return "<div class=\"csl-indent\">" + str + "</div>\n  ";
      },
      "@showid/true": function(state, str, cslid) {
        if (!state.tmp.just_looking && !state.tmp.suppress_decorations) {
          if (cslid) {
            return "<span class=\"" + state.opt.nodenames[cslid] + "\" cslid=\"" + cslid + "\">" + str + "</span>";
          } else if (this.params && "string" === typeof str) {
            var prePunct = "";
            if (str) {
              var m = str.match(CSL.VARIABLE_WRAPPER_PREPUNCT_REX);
              prePunct = m[1];
              str = m[2];
            }
            var postPunct = "";
            if (str && CSL.SWAPPING_PUNCTUATION.indexOf(str.slice(-1)) > -1) {
              postPunct = str.slice(-1);
              str = str.slice(0, -1);
            }
            return state.sys.variableWrapper(this.params, prePunct, str, postPunct);
          } else {
            return str;
          }
        } else {
          return str;
        }
      },
      "@URL/true": function(state, str) {
        return "<a href=\"" + str + "\">" + str + "</a>";
      },
      "@DOI/true": function(state, str) {
        return "<a href=\"http://dx.doi.org/" + str + "\">" + str + "</a>";
      }
    };
    CSL.Output.Formats.prototype.text = {
      "text_escape": function(text) {
        if (!text) {
          text = "";
        }
        return text;
      },
      "bibstart": "",
      "bibend": "",
      "@font-style/italic": false,
      "@font-style/oblique": false,
      "@font-style/normal": false,
      "@font-variant/small-caps": false,
      "@passthrough/true": CSL.Output.Formatters.passthrough,
      "@font-variant/normal": false,
      "@font-weight/bold": false,
      "@font-weight/normal": false,
      "@font-weight/light": false,
      "@text-decoration/none": false,
      "@text-decoration/underline": false,
      "@vertical-align/baseline": false,
      "@vertical-align/sup": false,
      "@vertical-align/sub": false,
      "@strip-periods/true": CSL.Output.Formatters.passthrough,
      "@strip-periods/false": CSL.Output.Formatters.passthrough,
      "@quotes/true": function(state, str) {
        if ("undefined" === typeof str) {
          return state.getTerm("open-quote");
        }
        return state.getTerm("open-quote") + str + state.getTerm("close-quote");
      },
      "@quotes/inner": function(state, str) {
        if ("undefined" === typeof str) {
          return "\u2019";
        }
        return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
      },
      "@quotes/false": false,
      "@cite/entry": function(state, str) {
        return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
      },
      "@bibliography/entry": function(state, str) {
        return str + "\n";
      },
      "@display/block": function(state, str) {
        return "\n" + str;
      },
      "@display/left-margin": function(state, str) {
        return str;
      },
      "@display/right-inline": function(state, str) {
        return str;
      },
      "@display/indent": function(state, str) {
        return "\n    " + str;
      },
      "@showid/true": function(state, str, cslid) {
        return str;
      },
      "@URL/true": function(state, str) {
        return str;
      },
      "@DOI/true": function(state, str) {
        return str;
      }
    };
    CSL.Output.Formats.prototype.rtf = {
      "text_escape": function(text) {
        if (!text) {
          text = "";
        }
        return text.replace(/([\\{}])/g, "\\$1").replace(CSL.SUPERSCRIPTS_REGEXP, function(aChar) {
          return "\\super " + CSL.SUPERSCRIPTS[aChar] + "\\nosupersub{}";
        }).replace(/[\u007F-\uFFFF]/g, function(aChar) {
          return "\\uc0\\u" + aChar.charCodeAt(0).toString() + "{}";
        }).split("\t").join("\\tab{}");
      },
      "@passthrough/true": CSL.Output.Formatters.passthrough,
      "@font-style/italic": "{\\i{}%%STRING%%}",
      "@font-style/normal": "{\\i0{}%%STRING%%}",
      "@font-style/oblique": "{\\i{}%%STRING%%}",
      "@font-variant/small-caps": "{\\scaps %%STRING%%}",
      "@font-variant/normal": "{\\scaps0{}%%STRING%%}",
      "@font-weight/bold": "{\\b{}%%STRING%%}",
      "@font-weight/normal": "{\\b0{}%%STRING%%}",
      "@font-weight/light": false,
      "@text-decoration/none": false,
      "@text-decoration/underline": "{\\ul{}%%STRING%%}",
      "@vertical-align/baseline": false,
      "@vertical-align/sup": "\\super %%STRING%%\\nosupersub{}",
      "@vertical-align/sub": "\\sub %%STRING%%\\nosupersub{}",
      "@strip-periods/true": CSL.Output.Formatters.passthrough,
      "@strip-periods/false": CSL.Output.Formatters.passthrough,
      "@quotes/true": function(state, str) {
        if ("undefined" === typeof str) {
          return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-quote"));
        }
        return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-quote")) + str + CSL.Output.Formats.rtf.text_escape(state.getTerm("close-quote"));
      },
      "@quotes/inner": function(state, str) {
        if ("undefined" === typeof str) {
          return CSL.Output.Formats.rtf.text_escape("\u2019");
        }
        return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-inner-quote")) + str + CSL.Output.Formats.rtf.text_escape(state.getTerm("close-inner-quote"));
      },
      "@quotes/false": false,
      "bibstart": "{\\rtf ",
      "bibend": "}",
      "@display/block": "\\line{}%%STRING%%\\line\r\n",
      "@cite/entry": function(state, str) {
        return str;
      },
      "@cite/entry": function(state, str) {
        return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
      },
      "@bibliography/entry": function(state, str) {
        return str;
      },
      "@display/left-margin": function(state, str) {
        return str + "\\tab ";
      },
      "@display/right-inline": function(state, str) {
        return str + "\r\n";
      },
      "@display/indent": function(state, str) {
        return "\n\\tab " + str + "\\line\r\n";
      },
      "@showid/true": function(state, str, cslid) {
        if (!state.tmp.just_looking && !state.tmp.suppress_decorations) {
          var prePunct = "";
          if (str) {
            var m = str.match(CSL.VARIABLE_WRAPPER_PREPUNCT_REX);
            prePunct = m[1];
            str = m[2];
          }
          var postPunct = "";
          if (str && CSL.SWAPPING_PUNCTUATION.indexOf(str.slice(-1)) > -1) {
            postPunct = str.slice(-1);
            str = str.slice(0, -1);
          }
          return state.sys.variableWrapper(this.params, prePunct, str, postPunct);
        } else {
          return str;
        }
      },
      "@URL/true": function(state, str) {
        return str;
      },
      "@DOI/true": function(state, str) {
        return str;
      }
    };
    CSL.Output.Formats = new CSL.Output.Formats();
    CSL.Registry = function(state) {
      var pos,
          len,
          ret,
          i,
          ilen;
      this.debug = false;
      this.state = state;
      this.registry = {};
      this.reflist = [];
      this.namereg = new CSL.Registry.NameReg(state);
      this.citationreg = new CSL.Registry.CitationReg(state);
      this.authorstrings = {};
      this.mylist = [];
      this.myhash = {};
      this.deletes = [];
      this.inserts = [];
      this.uncited = {};
      this.refreshes = {};
      this.akeys = {};
      this.oldseq = {};
      this.return_data = {};
      this.ambigcites = {};
      this.ambigresets = {};
      this.sorter = new CSL.Registry.Comparifier(state, "bibliography_sort");
      this.getSortedIds = function() {
        ret = [];
        for (i = 0, ilen = this.reflist.length; i < ilen; i += 1) {
          ret.push("" + this.reflist[i].id);
        }
        return ret;
      };
      this.getSortedRegistryItems = function() {
        ret = [];
        for (i = 0, ilen = this.reflist.length; i < ilen; i += 1) {
          ret.push(this.reflist[i]);
        }
        return ret;
      };
    };
    CSL.Registry.prototype.init = function(itemIDs, uncited_flag) {
      var i,
          ilen;
      this.oldseq = {};
      if (uncited_flag) {
        this.uncited = {};
        for (var i = 0,
            ilen = itemIDs.length; i < ilen; i += 1) {
          if (!this.myhash[itemIDs[i]]) {
            this.mylist.push("" + itemIDs[i]);
          }
          this.uncited[itemIDs[i]] = true;
          this.myhash[itemIDs[i]] = true;
        }
      } else {
        for (var key in this.uncited) {
          itemIDs.push(key);
        }
        var myhash = {};
        for (i = itemIDs.length - 1; i > -1; i += -1) {
          if (myhash[itemIDs[i]]) {
            itemIDs = itemIDs.slice(0, i).concat(itemIDs.slice(i + 1));
          } else {
            myhash[itemIDs[i]] = true;
          }
        }
        this.mylist = [];
        for (var i = 0,
            ilen = itemIDs.length; i < ilen; i += 1) {
          this.mylist.push("" + itemIDs[i]);
        }
        this.myhash = myhash;
      }
      this.refreshes = {};
      this.touched = {};
      this.ambigsTouched = {};
      this.ambigresets = {};
    };
    CSL.Registry.prototype.dopurge = function(myhash) {
      for (var i = this.mylist.length - 1; i > -1; i += -1) {
        if (this.citationreg.citationsByItemId) {
          if (!this.citationreg.citationsByItemId[this.mylist[i]] && !myhash[this.mylist[i]]) {
            delete this.myhash[this.mylist[i]];
            this.mylist = this.mylist.slice(0, i).concat(this.mylist.slice(i + 1));
          }
        }
      }
      this.dodeletes(this.myhash);
    };
    CSL.Registry.prototype.dodeletes = function(myhash) {
      var otheritems,
          key,
          ambig,
          pos,
          len,
          items,
          kkey,
          mypos,
          id;
      if ("string" === typeof myhash) {
        myhash = {};
        myhash[myhash] = true;
      }
      for (key in this.registry) {
        if (!myhash[key]) {
          if (this.uncited[key]) {
            continue;
          }
          otheritems = this.namereg.delitems(key);
          for (kkey in otheritems) {
            this.refreshes[kkey] = true;
          }
          ambig = this.registry[key].ambig;
          mypos = this.ambigcites[ambig].indexOf(key);
          if (mypos > -1) {
            items = this.ambigcites[ambig].slice();
            this.ambigcites[ambig] = items.slice(0, mypos).concat(items.slice(mypos + 1, items.length));
            this.ambigresets[ambig] = this.ambigcites[ambig].length;
          }
          len = this.ambigcites[ambig].length;
          for (pos = 0; pos < len; pos += 1) {
            id = "" + this.ambigcites[ambig][pos];
            this.refreshes[id] = true;
          }
          if (this.registry[key].siblings) {
            if (this.registry[key].siblings.length == 1) {
              var loneSiblingID = this.registry[key].siblings[0];
              this.registry[loneSiblingID].master = true;
              this.registry[loneSiblingID].siblings.pop();
              this.registry[loneSiblingID].parallel = false;
            } else if (this.registry[key].siblings.length > 1) {
              var removeIDs = [key];
              if (this.registry[key].master) {
                var newmasterID = this.registry[key].siblings[0];
                var newmaster = this.registry[newmasterID];
                newmaster.master = true;
                newmaster.parallel = false;
                removeIDs.push(newmasterID);
                for (var k = 0,
                    klen = this.registry[key].siblings.length; k < klen; k += 1) {
                  this.registry[this.registry[key].siblings[k]].parallel = newmasterID;
                }
              }
              var buffer = [];
              for (var k = this.registry[key].siblings.length - 1; k > -1; k += -1) {
                var siblingID = this.registry[key].siblings.pop();
                if (removeIDs.indexOf(siblingID) === -1) {
                  buffer.push(siblingID);
                }
              }
              for (var k = buffer.length - 1; k > -1; k += -1) {
                this.registry[key].siblings.push(buffer[k]);
              }
            }
          }
          delete this.registry[key];
          this.return_data.bibchange = true;
        }
      }
    };
    CSL.Registry.prototype.doinserts = function(mylist) {
      var len,
          pos,
          item,
          Item,
          akey,
          newitem,
          abase,
          j,
          jlen,
          k,
          klen,
          i,
          ilen;
      if ("string" === typeof mylist) {
        mylist = [mylist];
      }
      for (i = 0, ilen = mylist.length; i < ilen; i += 1) {
        item = mylist[i];
        if (!this.registry[item]) {
          Item = this.state.retrieveItem(item);
          akey = CSL.getAmbiguousCite.call(this.state, Item);
          this.ambigsTouched[akey] = true;
          if (!Item.legislation_id) {
            this.akeys[akey] = true;
          }
          newitem = {
            "id": "" + item,
            "seq": 0,
            "offset": 0,
            "sortkeys": false,
            "ambig": false,
            "rendered": false,
            "disambig": false,
            "ref": Item
          };
          this.registry[item] = newitem;
          if (this.citationreg.citationsByItemId && this.citationreg.citationsByItemId[item]) {
            this.registry[item]["first-reference-note-number"] = this.citationreg.citationsByItemId[item][0].properties.noteIndex;
          }
          abase = CSL.getAmbigConfig.call(this.state);
          this.registerAmbigToken(akey, item, abase);
          this.touched[item] = true;
          this.return_data.bibchange = true;
        }
      }
    };
    CSL.Registry.prototype.rebuildlist = function() {
      var count,
          len,
          pos,
          item;
      this.reflist = [];
      if (this.state.opt.citation_number_sort_direction === CSL.DESCENDING && this.state.opt.citation_number_sort_used) {}
      len = this.mylist.length;
      for (pos = 0; pos < len; pos += 1) {
        item = this.mylist[pos];
        this.reflist.push(this.registry[item]);
        this.oldseq[item] = this.registry[item].seq;
        this.registry[item].seq = (pos + 1);
      }
      if (this.state.opt.citation_number_sort_direction === CSL.DESCENDING && this.state.opt.citation_number_sort_used) {}
    };
    CSL.Registry.prototype.dorefreshes = function() {
      var key,
          regtoken,
          Item,
          old_akey,
          akey,
          abase;
      for (key in this.refreshes) {
        regtoken = this.registry[key];
        if (!regtoken) {
          continue;
        }
        regtoken.sortkeys = undefined;
        Item = this.state.retrieveItem(key);
        var akey = regtoken.ambig;
        if ("undefined" === typeof akey) {
          this.state.tmp.disambig_settings = false;
          akey = CSL.getAmbiguousCite.call(this.state, Item);
          abase = CSL.getAmbigConfig.call(this.state);
          this.registerAmbigToken(akey, key, abase);
        }
        for (var akkey in this.ambigresets) {
          if (this.ambigresets[akkey] === 1) {
            var loneKey = this.ambigcites[akey][0];
            var Item = this.state.retrieveItem(loneKey);
            this.registry[loneKey].disambig = new CSL.AmbigConfig;
            this.state.tmp.disambig_settings = false;
            var akey = CSL.getAmbiguousCite.call(this.state, Item);
            var abase = CSL.getAmbigConfig.call(this.state);
            this.registerAmbigToken(akey, loneKey, abase);
          }
        }
        this.state.tmp.taintedItemIDs[key] = true;
        this.ambigsTouched[akey] = true;
        if (!Item.legislation_id) {
          this.akeys[akey] = true;
        }
        this.touched[key] = true;
      }
    };
    CSL.Registry.prototype.setdisambigs = function() {
      var akey,
          leftovers,
          key,
          pos,
          len,
          id;
      this.leftovers = [];
      for (akey in this.ambigsTouched) {
        this.state.disambiguate.run(akey);
      }
      this.ambigsTouched = {};
      this.akeys = {};
    };
    CSL.Registry.prototype.renumber = function() {
      var len,
          pos,
          item;
      if (this.state.opt.citation_number_sort_direction === CSL.DESCENDING && this.state.opt.citation_number_sort_used) {}
      len = this.reflist.length;
      for (pos = 0; pos < len; pos += 1) {
        item = this.reflist[pos];
        item.seq = (pos + 1);
        if (this.state.opt.update_mode === CSL.NUMERIC && item.seq != this.oldseq[item.id]) {
          this.state.tmp.taintedItemIDs[item.id] = true;
        }
        if (this.state.opt.bib_mode === CSL.NUMERIC && item.seq != this.oldseq[item.id]) {
          this.return_data.bibchange = true;
        }
      }
      if (this.state.opt.citation_number_sort_direction === CSL.DESCENDING && this.state.opt.citation_number_sort_used) {
        this.reflist.reverse();
      }
    };
    CSL.Registry.prototype.setsortkeys = function() {
      var key;
      for (var i = 0,
          ilen = this.mylist.length; i < ilen; i += 1) {
        var key = this.mylist[i];
        if (this.touched[key] || this.state.tmp.taintedItemIDs[key] || !this.registry[key].sortkeys) {
          this.registry[key].sortkeys = CSL.getSortKeys.call(this.state, this.state.retrieveItem(key), "bibliography_sort");
        }
      }
    };
    CSL.Registry.prototype.sorttokens = function() {
      this.reflist.sort(this.sorter.compareKeys);
    };
    CSL.Registry.Comparifier = function(state, keyset) {
      var sort_directions,
          len,
          pos,
          compareKeys;
      var sortCompare = CSL.getSortCompare(state.opt["default-locale-sort"]);
      sort_directions = state[keyset].opt.sort_directions;
      this.compareKeys = function(a, b) {
        len = a.sortkeys ? a.sortkeys.length : 0;
        for (pos = 0; pos < len; pos += 1) {
          var cmp = 0;
          if (a.sortkeys[pos] === b.sortkeys[pos]) {
            cmp = 0;
          } else if ("undefined" === typeof a.sortkeys[pos]) {
            cmp = sort_directions[pos][1];
          } else if ("undefined" === typeof b.sortkeys[pos]) {
            cmp = sort_directions[pos][0];
          } else {
            cmp = sortCompare(a.sortkeys[pos], b.sortkeys[pos]);
          }
          if (0 < cmp) {
            return sort_directions[pos][1];
          } else if (0 > cmp) {
            return sort_directions[pos][0];
          }
        }
        if (a.seq > b.seq) {
          return 1;
        } else if (a.seq < b.seq) {
          return -1;
        }
        return 0;
      };
      compareKeys = this.compareKeys;
      this.compareCompositeKeys = function(a, b) {
        return compareKeys(a[1], b[1]);
      };
    };
    CSL.Registry.prototype.compareRegistryTokens = function(a, b) {
      if (a.seq > b.seq) {
        return 1;
      } else if (a.seq < b.seq) {
        return -1;
      }
      return 0;
    };
    CSL.Registry.prototype.registerAmbigToken = function(akey, id, ambig_config) {
      if (this.registry[id] && this.registry[id].disambig && this.registry[id].disambig.names) {
        for (var i = 0,
            ilen = ambig_config.names.length; i < ilen; i += 1) {
          var new_names_params = ambig_config.names[i];
          var old_names_params = this.registry[id].disambig.names[i];
          if (new_names_params !== old_names_params) {
            this.state.tmp.taintedItemIDs[id] = true;
          } else if (ambig_config.givens[i]) {
            for (var j = 0,
                jlen = ambig_config.givens[i].length; j < jlen; j += 1) {
              var new_gnames_params = ambig_config.givens[i][j];
              var old_gnames_params = this.registry[id].disambig.givens[i][j];
              if (new_gnames_params !== old_gnames_params) {
                this.state.tmp.taintedItemIDs[id] = true;
              }
            }
          }
        }
      }
      if (!this.ambigcites[akey]) {
        this.ambigcites[akey] = [];
      }
      if (this.ambigcites[akey].indexOf("" + id) === -1) {
        this.ambigcites[akey].push("" + id);
      }
      this.registry[id].ambig = akey;
      var dome = false;
      this.registry[id].disambig = CSL.cloneAmbigConfig(ambig_config);
    };
    CSL.getSortKeys = function(Item, key_type) {
      var area,
          extension,
          strip_prepositions,
          use_parallels,
          len,
          pos;
      area = this.tmp.area;
      extension = this.tmp.extension;
      strip_prepositions = CSL.Util.Sort.strip_prepositions;
      this.tmp.area = key_type;
      this.tmp.extension = "_sort";
      this.tmp.disambig_override = true;
      this.tmp.disambig_request = false;
      this.parallel.use_parallels = (this.parallel.use_parallels === true || this.parallel.use_parallels === null) ? null : false;
      this.tmp.suppress_decorations = true;
      CSL.getCite.call(this, Item);
      this.tmp.suppress_decorations = false;
      this.parallel.use_parallels = this.parallel.use_parallels === null ? true : false;
      this.tmp.disambig_override = false;
      len = this[key_type].keys.length;
      for (pos = 0; pos < len; pos += 1) {
        this[key_type].keys[pos] = strip_prepositions(this[key_type].keys[pos]);
      }
      this.tmp.area = area;
      this.tmp.extension = extension;
      return this[key_type].keys;
    };
    CSL.Registry.NameReg = function(state) {
      var pkey,
          ikey,
          skey,
          floor,
          ceiling,
          dagopt,
          gdropt,
          ret,
          pos,
          items,
          strip_periods,
          set_keys,
          evalname,
          delitems,
          addname,
          key,
          myitems,
          i,
          ilen;
      this.state = state;
      this.namereg = {};
      this.nameind = {};
      this.nameindpkeys = {};
      this.itemkeyreg = {};
      strip_periods = function(str) {
        if (!str) {
          str = "";
        }
        return str.replace(/\./g, " ").replace(/\s+/g, " ").replace(/\s+$/, "");
      };
      set_keys = function(state, itemid, nameobj) {
        pkey = strip_periods(nameobj.family);
        skey = strip_periods(nameobj.given);
        var m = skey.match(/[,\!]* ([^,]+)$/);
        if (m && m[1] === m[1].toLowerCase()) {
          skey = skey.replace(/[,\!]* [^,]+$/, "");
        }
        ikey = CSL.Util.Names.initializeWith(state, skey, "%s");
        if (state.citation.opt["givenname-disambiguation-rule"] === "by-cite") {
          pkey = "" + itemid + pkey;
        }
      };
      evalname = function(item_id, nameobj, namenum, request_base, form, initials) {
        var pos,
            len,
            items,
            param;
        if (state.tmp.area.slice(0, 12) === "bibliography" && !form) {
          if ("string" === typeof initials) {
            return 1;
          } else {
            return 2;
          }
        }
        var res = state.nameOutput.getName(nameobj, "locale-translit", true);
        nameobj = res.name;
        set_keys(this.state, "" + item_id, nameobj);
        param = 2;
        dagopt = state.opt["disambiguate-add-givenname"];
        gdropt = state.citation.opt["givenname-disambiguation-rule"];
        var gdropt_orig = gdropt;
        if (gdropt === "by-cite") {
          gdropt = "all-names";
        }
        if ("short" === form) {
          param = 0;
        } else if ("string" === typeof initials) {
          param = 1;
        }
        if ("undefined" === typeof this.namereg[pkey] || "undefined" === typeof this.namereg[pkey].ikey[ikey]) {
          return param;
        }
        if (gdropt_orig === "by-cite" && param <= request_base) {
          return request_base;
        }
        if (!dagopt) {
          return param;
        }
        if ("string" === typeof gdropt && gdropt.slice(0, 12) === "primary-name" && namenum > 0) {
          return param;
        }
        if (!gdropt || gdropt === "all-names" || gdropt === "primary-name") {
          if (this.namereg[pkey].count > 1) {
            param = 1;
          }
          if ((this.namereg[pkey].ikey && this.namereg[pkey].ikey[ikey].count > 1) || (this.namereg[pkey].count > 1 && "string" !== typeof initials)) {
            param = 2;
          }
        } else if (gdropt === "all-names-with-initials" || gdropt === "primary-name-with-initials") {
          if (this.namereg[pkey].count > 1) {
            param = 1;
          } else {
            param = 0;
          }
        }
        if (!state.registry.registry[item_id]) {
          if (form == "short") {
            return 0;
          } else if ("string" == typeof initials) {
            return 1;
          }
        } else {
          return param;
        }
      };
      delitems = function(ids) {
        var item,
            pos,
            len,
            posA,
            posB,
            id,
            fullkey,
            llen,
            ppos,
            otherid;
        if ("string" === typeof ids || "number" === typeof ids) {
          ids = ["" + ids];
        }
        ret = {};
        len = ids.length;
        for (pos = 0; pos < len; pos += 1) {
          id = "" + ids[pos];
          if (!this.nameind[id]) {
            continue;
          }
          for (fullkey in this.nameind[id]) {
            if (this.nameind[id].hasOwnProperty(fullkey)) {
              key = fullkey.split("::");
              pkey = key[0];
              ikey = key[1];
              skey = key[2];
              if ("undefined" === typeof this.namereg[pkey]) {
                continue;
              }
              items = this.namereg[pkey].items;
              if (skey && this.namereg[pkey].ikey[ikey] && this.namereg[pkey].ikey[ikey].skey[skey]) {
                myitems = this.namereg[pkey].ikey[ikey].skey[skey].items;
                posB = myitems.indexOf("" + id);
                if (posB > -1) {
                  this.namereg[pkey].ikey[ikey].skey[skey].items = myitems.slice(0, posB).concat(myitems.slice([(posB + 1)]));
                }
                if (this.namereg[pkey].ikey[ikey].skey[skey].items.length === 0) {
                  delete this.namereg[pkey].ikey[ikey].skey[skey];
                  this.namereg[pkey].ikey[ikey].count += -1;
                  if (this.namereg[pkey].ikey[ikey].count < 2) {
                    for (i = 0, ilen = this.namereg[pkey].ikey[ikey].items.length; i < ilen; i += 1) {
                      state.tmp.taintedItemIDs[this.namereg[pkey].ikey[ikey].items[i]] = true;
                    }
                  }
                }
              }
              if (ikey && this.namereg[pkey].ikey[ikey]) {
                posB = this.namereg[pkey].ikey[ikey].items.indexOf("" + id);
                if (posB > -1) {
                  items = this.namereg[pkey].ikey[ikey].items.slice();
                  this.namereg[pkey].ikey[ikey].items = items.slice(0, posB).concat(items.slice([posB + 1]));
                }
                if (this.namereg[pkey].ikey[ikey].items.length === 0) {
                  delete this.namereg[pkey].ikey[ikey];
                  this.namereg[pkey].count += -1;
                  if (this.namereg[pkey].count < 2) {
                    for (i = 0, ilen = this.namereg[pkey].items.length; i < ilen; i += 1) {
                      state.tmp.taintedItemIDs[this.namereg[pkey].items[i]] = true;
                    }
                  }
                }
              }
              if (pkey) {
                posB = this.namereg[pkey].items.indexOf("" + id);
                if (posB > -1) {
                  items = this.namereg[pkey].items.slice();
                  this.namereg[pkey].items = items.slice(0, posB).concat(items.slice([posB + 1], items.length));
                }
                if (this.namereg[pkey].items.length < 2) {
                  delete this.namereg[pkey];
                }
              }
              delete this.nameind[id][fullkey];
            }
          }
          delete this.nameind[id];
          delete this.nameindpkeys[id];
        }
        return ret;
      };
      addname = function(item_id, nameobj, pos) {
        var i,
            ilen;
        var res = state.nameOutput.getName(nameobj, "locale-translit", true);
        nameobj = res.name;
        if (state.citation.opt["givenname-disambiguation-rule"] && state.citation.opt["givenname-disambiguation-rule"].slice(0, 8) === "primary-" && pos !== 0) {
          return;
        }
        set_keys(this.state, "" + item_id, nameobj);
        if (pkey) {
          if ("undefined" === typeof this.namereg[pkey]) {
            this.namereg[pkey] = {};
            this.namereg[pkey].count = 0;
            this.namereg[pkey].ikey = {};
            this.namereg[pkey].items = [item_id];
          } else if (this.namereg[pkey].items.indexOf(item_id) === -1) {
            this.namereg[pkey].items.push(item_id);
          }
        }
        if (pkey && ikey) {
          if ("undefined" === typeof this.namereg[pkey].ikey[ikey]) {
            this.namereg[pkey].ikey[ikey] = {};
            this.namereg[pkey].ikey[ikey].count = 0;
            this.namereg[pkey].ikey[ikey].skey = {};
            this.namereg[pkey].ikey[ikey].items = [item_id];
            this.namereg[pkey].count += 1;
            if (this.namereg[pkey].count === 2) {
              for (i = 0, ilen = this.namereg[pkey].items.length; i < ilen; i += 1) {
                state.tmp.taintedItemIDs[this.namereg[pkey].items[i]] = true;
              }
            }
          } else if (this.namereg[pkey].ikey[ikey].items.indexOf(item_id) === -1) {
            this.namereg[pkey].ikey[ikey].items.push(item_id);
          }
        }
        if (pkey && ikey && skey) {
          if ("undefined" === typeof this.namereg[pkey].ikey[ikey].skey[skey]) {
            this.namereg[pkey].ikey[ikey].skey[skey] = {};
            this.namereg[pkey].ikey[ikey].skey[skey].items = [item_id];
            this.namereg[pkey].ikey[ikey].count += 1;
            if (this.namereg[pkey].ikey[ikey].count === 2) {
              for (i = 0, ilen = this.namereg[pkey].ikey[ikey].items.length; i < ilen; i += 1) {
                state.tmp.taintedItemIDs[this.namereg[pkey].ikey[ikey].items[i]] = true;
              }
            }
          } else if (this.namereg[pkey].ikey[ikey].skey[skey].items.indexOf(item_id) === -1) {
            this.namereg[pkey].ikey[ikey].skey[skey].items.push(item_id);
          }
        }
        if ("undefined" === typeof this.nameind[item_id]) {
          this.nameind[item_id] = {};
          this.nameindpkeys[item_id] = {};
        }
        if (pkey) {
          this.nameind[item_id][pkey + "::" + ikey + "::" + skey] = true;
          this.nameindpkeys[item_id][pkey] = this.namereg[pkey];
        }
      };
      this.addname = addname;
      this.delitems = delitems;
      this.evalname = evalname;
    };
    CSL.Registry.CitationReg = function(state) {
      this.citationById = {};
      this.citationByIndex = [];
    };
    CSL.Disambiguation = function(state) {
      this.state = state;
      this.sys = this.state.sys;
      this.registry = state.registry.registry;
      this.ambigcites = state.registry.ambigcites;
      this.configModes();
      this.debug = false;
    };
    CSL.Disambiguation.prototype.run = function(akey) {
      if (!this.modes.length) {
        return;
      }
      this.akey = akey;
      if (this.initVars(akey)) {
        this.runDisambig();
      }
    };
    CSL.Disambiguation.prototype.runDisambig = function() {
      var pos,
          len,
          ppos,
          llen,
          pppos,
          lllen,
          ismax;
      this.initGivens = true;
      while (this.lists.length) {
        this.gnameset = 0;
        this.gname = 0;
        this.clashes = [1, 0];
        while (this.lists[0][1].length) {
          this.listpos = 0;
          if (!this.base) {
            this.base = this.lists[0][0];
          }
          var names_used = [];
          ismax = this.incrementDisambig();
          this.scanItems(this.lists[0]);
          this.evalScan(ismax);
        }
        this.lists = this.lists.slice(1);
      }
    };
    CSL.Disambiguation.prototype.scanItems = function(list) {
      var pos,
          len,
          Item,
          otherItem,
          ItemCite,
          ignore,
          base;
      this.Item = list[1][0];
      this.ItemCite = CSL.getAmbiguousCite.call(this.state, this.Item, this.base, true);
      this.scanlist = list[1];
      this.partners = [];
      this.partners.push(this.Item);
      this.nonpartners = [];
      var clashes = 0;
      for (var pos = 1,
          len = list[1].length; pos < len; pos += 1) {
        otherItem = list[1][pos];
        var otherItemCite = CSL.getAmbiguousCite.call(this.state, otherItem, this.base, true);
        if (this.ItemCite === otherItemCite) {
          clashes += 1;
          this.partners.push(otherItem);
        } else {
          this.nonpartners.push(otherItem);
        }
      }
      this.clashes[0] = this.clashes[1];
      this.clashes[1] = clashes;
    };
    CSL.Disambiguation.prototype.evalScan = function(maxed) {
      this[this.modes[this.modeindex]](maxed);
      if (maxed) {
        if (this.modeindex < this.modes.length - 1) {
          this.modeindex += 1;
        } else {
          this.lists[this.listpos + 1] = [this.base, []];
        }
      }
    };
    CSL.Disambiguation.prototype.disNames = function(ismax) {
      var pos,
          len,
          mybase,
          i,
          ilen;
      if (this.clashes[1] === 0 && this.nonpartners.length === 1) {
        this.captureStepToBase();
        this.state.registry.registerAmbigToken(this.akey, "" + this.nonpartners[0].id, this.betterbase);
        this.state.registry.registerAmbigToken(this.akey, "" + this.partners[0].id, this.betterbase);
        this.lists[this.listpos] = [this.betterbase, []];
      } else if (this.clashes[1] === 0) {
        this.captureStepToBase();
        this.state.registry.registerAmbigToken(this.akey, "" + this.partners[0].id, this.betterbase);
        this.lists[this.listpos] = [this.betterbase, this.nonpartners];
        if (this.nonpartners.length) {
          this.initGivens = true;
        }
      } else if (this.nonpartners.length === 1) {
        this.captureStepToBase();
        this.state.registry.registerAmbigToken(this.akey, "" + this.nonpartners[0].id, this.betterbase);
        this.lists[this.listpos] = [this.betterbase, this.partners];
      } else if (this.clashes[1] < this.clashes[0]) {
        this.captureStepToBase();
        this.lists[this.listpos] = [this.betterbase, this.partners];
        this.lists.push([this.betterbase, this.nonpartners]);
      } else {
        if (ismax) {
          this.lists[this.listpos] = [this.betterbase, this.nonpartners];
          this.lists.push([this.betterbase, this.partners]);
          if (this.modeindex === this.modes.length - 1) {
            for (var i = 0,
                ilen = this.partners.length; i < ilen; i += 1) {
              this.state.registry.registerAmbigToken(this.akey, "" + this.partners[i].id, this.betterbase);
            }
            this.lists[this.listpos] = [this.betterbase, []];
          }
        }
      }
    };
    CSL.Disambiguation.prototype.disExtraText = function() {
      var pos,
          len,
          mybase;
      var done = false;
      if (this.clashes[1] === 0 && this.nonpartners.length < 2) {
        done = true;
      }
      if (!done && (!this.base.disambiguate || this.state.tmp.disambiguate_count !== this.state.tmp.disambiguate_maxMax)) {
        this.modeindex = 0;
        this.base.disambiguate = this.state.tmp.disambiguate_count;
        this.betterbase.disambiguate = this.state.tmp.disambiguate_count;
        if (!this.base.disambiguate) {
          this.initGivens = true;
          this.base.disambiguate = 1;
          for (var i = 0,
              ilen = this.lists[this.listpos][1].length; i < ilen; i += 1) {
            this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][i].id] = true;
          }
        } else {
          this.disNames();
        }
      } else if (done || this.state.tmp.disambiguate_count === this.state.tmp.disambiguate_maxMax) {
        if (done || this.modeindex === this.modes.length - 1) {
          var base = this.lists[this.listpos][0];
          for (var i = 0,
              ilen = this.lists[this.listpos][1].length; i < ilen; i += 1) {
            this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][i].id] = true;
            this.state.registry.registerAmbigToken(this.akey, "" + this.lists[this.listpos][1][i].id, base);
          }
          this.lists[this.listpos] = [this.betterbase, []];
        } else {
          this.modeindex = this.modes.length - 1;
          var base = this.lists[this.listpos][0];
          base.disambiguate = true;
          for (var i = 0,
              ilen = this.lists[this.listpos][1].length; i < ilen; i += 1) {
            this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][i].id] = true;
            this.state.registry.registerAmbigToken(this.akey, "" + this.lists[this.listpos][1][i].id, base);
          }
        }
      }
    };
    CSL.Disambiguation.prototype.disYears = function() {
      var pos,
          len,
          tokens,
          token,
          item;
      tokens = [];
      var base = this.lists[this.listpos][0];
      if (this.clashes[1]) {
        for (var i = 0,
            ilen = this.state.registry.mylist.length; i < ilen; i += 1) {
          var origid = this.state.registry.mylist[i];
          for (var j = 0,
              jlen = this.lists[this.listpos][1].length; j < jlen; j += 1) {
            var token = this.lists[this.listpos][1][j];
            if (token.id == origid) {
              tokens.push(this.registry[token.id]);
              break;
            }
          }
        }
      }
      tokens.sort(this.state.registry.sorter.compareKeys);
      for (var pos = 0,
          len = tokens.length; pos < len; pos += 1) {
        base.year_suffix = "" + pos;
        var oldBase = this.state.registry.registry[tokens[pos].id].disambig;
        this.state.registry.registerAmbigToken(this.akey, "" + tokens[pos].id, base);
        if (CSL.ambigConfigDiff(oldBase, base)) {
          this.state.tmp.taintedItemIDs[tokens[pos].id] = true;
        }
      }
      this.lists[this.listpos] = [this.betterbase, []];
    };
    CSL.Disambiguation.prototype.incrementDisambig = function() {
      var val;
      if (this.initGivens) {
        this.initGivens = false;
        return false;
      }
      var maxed = false;
      var increment_names = true;
      var increment_givens = true;
      if ("disNames" === this.modes[this.modeindex]) {
        increment_names = false;
        if ("number" !== typeof this.givensMax) {
          increment_names = true;
        }
        var increment_namesets = false;
        if ("number" !== typeof this.namesMax) {
          increment_namesets = true;
        }
        if ("number" === typeof this.givensMax) {
          if (this.base.givens.length && this.base.givens[this.gnameset][this.gname] < this.givensMax) {
            this.base.givens[this.gnameset][this.gname] += 1;
          } else {
            increment_names = true;
          }
        }
        if ("number" === typeof this.namesMax && increment_names) {
          if (this.state.opt["disambiguate-add-names"]) {
            increment_namesets = false;
            if (this.gname < this.namesMax) {
              this.base.names[this.gnameset] += 1;
              this.gname += 1;
            } else {
              increment_namesets = true;
            }
          } else {
            increment_namesets = true;
          }
        }
        if ("number" === typeof this.namesetsMax && increment_namesets) {
          if (this.gnameset < this.namesetsMax) {
            this.gnameset += 1;
            this.base.names[this.gnameset] = 1;
            this.gname = 0;
          } else {
            var increment_mode = true;
          }
        }
        if (("number" !== typeof this.namesetsMax || this.namesetsMax === -1 || this.gnameset === this.namesetsMax) && (!this.state.opt["disambiguate-add-names"] || "number" !== typeof this.namesMax || this.gname === this.namesMax) && ("number" != typeof this.givensMax || "undefined" === typeof this.base.givens[this.gnameset] || "undefined" === typeof this.base.givens[this.gnameset][this.gname] || this.base.givens[this.gnameset][this.gname] === this.givensMax)) {
          maxed = true;
        }
      } else if ("disExtraText" === this.modes[this.modeindex]) {
        this.base.disambiguate += 1;
        this.betterbase.disambiguate += 1;
      }
      return maxed;
    };
    CSL.Disambiguation.prototype.initVars = function(akey) {
      var i,
          ilen,
          myIds,
          myItemBundles,
          myItems;
      this.lists = [];
      this.base = false;
      this.betterbase = false;
      this.akey = akey;
      this.maxNamesByItemId = {};
      myItemBundles = [];
      myIds = this.ambigcites[akey];
      if (!myIds || !myIds.length) {
        return false;
      }
      var Item = false;
      var myItem = this.state.retrieveItem("" + myIds[0]);
      this.getCiteData(myItem);
      this.base = CSL.getAmbigConfig.call(this.state);
      if (myIds && myIds.length > 1) {
        myItemBundles.push([this.maxNamesByItemId[myItem.id], myItem]);
        for (var i = 1,
            ilen = myIds.length; i < ilen; i += 1) {
          myItem = this.state.retrieveItem("" + myIds[i]);
          this.getCiteData(myItem, this.base);
          myItemBundles.push([this.maxNamesByItemId[myItem.id], myItem]);
        }
        myItemBundles.sort(function(a, b) {
          if (a[0] > b[0]) {
            return 1;
          } else if (a[0] < b[0]) {
            return -1;
          } else {
            if (a[1].id > b[1].id) {
              return 1;
            } else if (a[1].id < b[1].id) {
              return -1;
            } else {
              return 0;
            }
          }
        });
        myItems = [];
        for (var i = 0,
            ilen = myItemBundles.length; i < ilen; i += 1) {
          myItems.push(myItemBundles[i][1]);
        }
        this.lists.push([this.base, myItems]);
        this.Item = this.lists[0][1][0];
      } else {
        this.Item = this.state.retrieveItem("" + myIds[0]);
      }
      this.modeindex = 0;
      if (this.state.citation.opt["disambiguate-add-names"] || true) {
        this.namesMax = this.maxNamesByItemId[this.Item.id][0];
      } else {
        var namesMax = this.base.names[0];
        for (var i = 1,
            ilen = this.base.names.length; i < ilen; i += 1) {
          namesMax = Math.max(namesMax, this.base.names.names[i]);
        }
      }
      this.padBase(this.base);
      this.padBase(this.betterbase);
      this.base.year_suffix = false;
      this.base.disambiguate = false;
      this.betterbase.year_suffix = false;
      this.betterbase.disambiguate = false;
      if (this.state.citation.opt["givenname-disambiguation-rule"] === "by-cite" && this.state.opt["disambiguate-add-givenname"]) {
        this.givensMax = 2;
      }
      return true;
    };
    CSL.Disambiguation.prototype.padBase = function(base) {
      for (var i = 0,
          ilen = base.names.length; i < ilen; i += 1) {
        if (!base.givens[i]) {
          base.givens[i] = [];
        }
        for (var j = 0,
            jlen = base.names[i]; j < jlen; j += 1) {
          if (!base.givens[i][j]) {
            base.givens[i][j] = 0;
          }
        }
      }
    };
    CSL.Disambiguation.prototype.configModes = function() {
      var dagopt,
          gdropt;
      this.modes = [];
      dagopt = this.state.opt["disambiguate-add-givenname"];
      gdropt = this.state.citation.opt["givenname-disambiguation-rule"];
      if (this.state.opt['disambiguate-add-names'] || (dagopt && gdropt === "by-cite")) {
        this.modes.push("disNames");
      }
      if (this.state.opt.has_disambiguate) {
        this.modes.push("disExtraText");
      }
      if (this.state.opt["disambiguate-add-year-suffix"]) {
        this.modes.push("disYears");
      }
    };
    CSL.Disambiguation.prototype.getCiteData = function(Item, base) {
      if (!this.maxNamesByItemId[Item.id]) {
        CSL.getAmbiguousCite.call(this.state, Item, base);
        base = CSL.getAmbigConfig.call(this.state);
        this.maxNamesByItemId[Item.id] = CSL.getMaxVals.call(this.state);
        this.state.registry.registry[Item.id].disambig.givens = this.state.tmp.disambig_settings.givens.slice();
        for (var i = 0,
            ilen = this.state.registry.registry[Item.id].disambig.givens.length; i < ilen; i += 1) {
          this.state.registry.registry[Item.id].disambig.givens[i] = this.state.tmp.disambig_settings.givens[i].slice();
        }
        this.namesetsMax = this.state.registry.registry[Item.id].disambig.names.length - 1;
        if (!this.base) {
          this.base = base;
          this.betterbase = CSL.cloneAmbigConfig(base);
        }
        if (base.names.length < this.base.names.length) {
          this.base = base;
        }
        var update = false;
        for (var i = 0,
            ilen = base.names.length; i < ilen; i += 1) {
          if (base.names[i] > this.base.names[i]) {
            this.base.givens[i] = base.givens[i].slice();
            this.base.names[i] = base.names[i];
            this.betterbase.names = this.base.names.slice();
            this.betterbase.givens = this.base.givens.slice();
            this.padBase(this.base);
            this.padBase(this.betterbase);
          }
        }
        this.betterbase.givens = this.base.givens.slice();
        for (var j = 0,
            jlen = this.base.givens.length; j < jlen; j += 1) {
          this.betterbase.givens[j] = this.base.givens[j].slice();
        }
      }
    };
    CSL.Disambiguation.prototype.captureStepToBase = function() {
      if (this.state.citation.opt["givenname-disambiguation-rule"] === "by-cite" && this.base.givens && this.base.givens.length) {
        if ("undefined" !== typeof this.base.givens[this.gnameset][this.gname]) {
          this.betterbase.givens[this.gnameset][this.gname] = this.base.givens[this.gnameset][this.gname];
        }
      }
      this.betterbase.names[this.gnameset] = this.base.names[this.gnameset];
    };
    CSL.Engine.prototype.getJurisdictionList = function(jurisdiction) {
      var jurisdictionList = [];
      var jurisdictionElems = jurisdiction.split(":");
      for (var j = jurisdictionElems.length; j > 0; j--) {
        jurisdictionList.push(jurisdictionElems.slice(0, j).join(":"));
      }
      if (jurisdictionList.indexOf("us") === -1) {
        jurisdictionList.push("us");
      }
      return jurisdictionList;
    };
    CSL.Engine.prototype.retrieveAllStyleModules = function(jurisdictionList) {
      var ret = {};
      var preferences = this.locale[this.opt.lang].opts["jurisdiction-preference"];
      preferences = preferences ? preferences : [];
      preferences = [null].concat(preferences);
      for (var i = preferences.length - 1; i > -1; i--) {
        var preference = preferences[i];
        for (var j = 0,
            jlen = jurisdictionList.length; j < jlen; j++) {
          var jurisdiction = jurisdictionList[j];
          if (this.opt.jurisdictions_seen[jurisdiction])
            continue;
          var res = this.sys.retrieveStyleModule(jurisdiction, preference);
          this.opt.jurisdictions_seen[jurisdiction] = true;
          if (!res)
            continue;
          ret[jurisdiction] = res;
        }
      }
      return ret;
    };
    CSL.ParticleList = function() {
      var always_dropping_1 = [[[0, 1], null]];
      var always_dropping_2 = [[[0, 2], null]];
      var always_dropping_3 = [[[0, 3], null]];
      var always_non_dropping_1 = [[null, [0, 1]]];
      var always_non_dropping_2 = [[null, [0, 2]]];
      var always_non_dropping_3 = [[null, [0, 3]]];
      var either_1 = [[null, [0, 1]], [[0, 1], null]];
      var either_2 = [[null, [0, 2]], [[0, 2], null]];
      var either_1_dropping_best = [[[0, 1], null], [null, [0, 1]]];
      var either_2_dropping_best = [[[0, 2], null], [null, [0, 2]]];
      var either_3_dropping_best = [[[0, 3], null], [null, [0, 3]]];
      var non_dropping_2_alt_dropping_1_non_dropping_1 = [[null, [0, 2]], [[0, 1], [1, 2]]];
      return PARTICLES = [["'s", always_non_dropping_1], ["'s-", always_non_dropping_1], ["'t", always_non_dropping_1], ["a", always_non_dropping_1], ["aan 't", always_non_dropping_2], ["aan de", always_non_dropping_2], ["aan den", always_non_dropping_2], ["aan der", always_non_dropping_2], ["aan het", always_non_dropping_2], ["aan t", always_non_dropping_2], ["aan", always_non_dropping_1], ["ad-", either_1], ["adh-", either_1], ["af", either_1], ["al", either_1], ["al-", either_1], ["am de", always_non_dropping_2], ["am", always_non_dropping_1], ["an-", either_1], ["ar-", either_1], ["as-", either_1], ["ash-", either_1], ["at-", either_1], ["ath-", either_1], ["auf dem", either_2_dropping_best], ["auf den", either_2_dropping_best], ["auf der", either_2_dropping_best], ["auf ter", always_non_dropping_2], ["auf", either_1_dropping_best], ["aus 'm", either_2_dropping_best], ["aus dem", either_2_dropping_best], ["aus den", either_2_dropping_best], ["aus der", either_2_dropping_best], ["aus m", either_2_dropping_best], ["aus", either_1_dropping_best], ["aus'm", either_2_dropping_best], ["az-", either_1], ["a-", either_1], ["a-", either_1], ["a-", either_1], ["a-", either_1], ["a-", either_1], ["a-", either_1], ["a-", either_1], ["ben", always_non_dropping_1], ["bij 't", always_non_dropping_2], ["bij de", always_non_dropping_2], ["bij den", always_non_dropping_2], ["bij het", always_non_dropping_2], ["bij t", always_non_dropping_2], ["bij", always_non_dropping_1], ["bin", always_non_dropping_1], ["boven d", always_non_dropping_2], ["boven d'", always_non_dropping_2], ["d", always_non_dropping_1], ["d'", either_1], ["da", either_1], ["dal", always_non_dropping_1], ["dal'", always_non_dropping_1], ["dall'", always_non_dropping_1], ["dalla", always_non_dropping_1], ["das", either_1], ["de die le", always_non_dropping_3], ["de die", always_non_dropping_2], ["de l", always_non_dropping_2], ["de l'", always_non_dropping_2], ["de la", non_dropping_2_alt_dropping_1_non_dropping_1], ["de las", non_dropping_2_alt_dropping_1_non_dropping_1], ["de le", always_non_dropping_2], ["de li", either_2], ["de van der", always_non_dropping_3], ["de", either_1], ["de'", either_1], ["deca", always_non_dropping_1], ["degli", either_1], ["dei", either_1], ["del", either_1], ["dela", always_dropping_1], ["dell'", either_1], ["della", either_1], ["delle", either_1], ["dello", either_1], ["den", either_1], ["der", either_1], ["des", either_1], ["di", either_1], ["die le", always_non_dropping_2], ["do", always_non_dropping_1], ["don", always_non_dropping_1], ["dos", either_1], ["du", either_1], ["ed-", either_1], ["edh-", either_1], ["el", either_1], ["el-", either_1], ["en-", either_1], ["er-", either_1], ["es-", either_1], ["esh-", either_1], ["et-", either_1], ["eth-", either_1], ["ez-", either_1], ["e-", either_1], ["e-", either_1], ["e-", either_1], ["e-", either_1], ["e-", either_1], ["e-", either_1], ["e-", either_1], ["het", always_non_dropping_1], ["i", always_non_dropping_1], ["il", always_dropping_1], ["im", always_non_dropping_1], ["in 't", always_non_dropping_2], ["in de", always_non_dropping_2], ["in den", always_non_dropping_2], ["in der", either_2], ["in het", always_non_dropping_2], ["in t", always_non_dropping_2], ["in", always_non_dropping_1], ["l", always_non_dropping_1], ["l'", always_non_dropping_1], ["la", always_non_dropping_1], ["las", always_non_dropping_1], ["le", always_non_dropping_1], ["les", either_1], ["lo", either_1], ["los", always_non_dropping_1], ["lou", always_non_dropping_1], ["of", always_non_dropping_1], ["onder 't", always_non_dropping_2], ["onder de", always_non_dropping_2], ["onder den", always_non_dropping_2], ["onder het", always_non_dropping_2], ["onder t", always_non_dropping_2], ["onder", always_non_dropping_1], ["op 't", always_non_dropping_2], ["op de", either_2], ["op den", always_non_dropping_2], ["op der", always_non_dropping_2], ["op gen", always_non_dropping_2], ["op het", always_non_dropping_2], ["op t", always_non_dropping_2], ["op ten", always_non_dropping_2], ["op", always_non_dropping_1], ["over 't", always_non_dropping_2], ["over de", always_non_dropping_2], ["over den", always_non_dropping_2], ["over het", always_non_dropping_2], ["over t", always_non_dropping_2], ["over", always_non_dropping_1], ["s", always_non_dropping_1], ["s'", always_non_dropping_1], ["sen", always_dropping_1], ["t", always_non_dropping_1], ["te", always_non_dropping_1], ["ten", always_non_dropping_1], ["ter", always_non_dropping_1], ["tho", always_non_dropping_1], ["thoe", always_non_dropping_1], ["thor", always_non_dropping_1], ["to", always_non_dropping_1], ["toe", always_non_dropping_1], ["tot", always_non_dropping_1], ["uijt 't", always_non_dropping_2], ["uijt de", always_non_dropping_2], ["uijt den", always_non_dropping_2], ["uijt te de", always_non_dropping_3], ["uijt ten", always_non_dropping_2], ["uijt", always_non_dropping_1], ["uit 't", always_non_dropping_2], ["uit de", always_non_dropping_2], ["uit den", always_non_dropping_2], ["uit het", always_non_dropping_2], ["uit t", always_non_dropping_2], ["uit te de", always_non_dropping_3], ["uit ten", always_non_dropping_2], ["uit", always_non_dropping_1], ["unter", always_non_dropping_1], ["v", always_non_dropping_1], ["v.", always_non_dropping_1], ["v.d.", always_non_dropping_1], ["van 't", always_non_dropping_2], ["van de l", always_non_dropping_3], ["van de l'", always_non_dropping_3], ["van de", always_non_dropping_2], ["van de", always_non_dropping_2], ["van den", always_non_dropping_2], ["van der", always_non_dropping_2], ["van gen", always_non_dropping_2], ["van het", always_non_dropping_2], ["van la", always_non_dropping_2], ["van t", always_non_dropping_2], ["van ter", always_non_dropping_2], ["van van de", always_non_dropping_3], ["van", either_1], ["vander", always_non_dropping_1], ["vd", always_non_dropping_1], ["ver", always_non_dropping_1], ["vom und zum", always_dropping_3], ["vom", either_1], ["von 't", always_non_dropping_2], ["von dem", either_2_dropping_best], ["von den", either_2_dropping_best], ["von der", either_2_dropping_best], ["von t", always_non_dropping_2], ["von und zu", either_3_dropping_best], ["von zu", either_2_dropping_best], ["von", either_1_dropping_best], ["voor 't", always_non_dropping_2], ["voor de", always_non_dropping_2], ["voor den", always_non_dropping_2], ["voor in 't", always_non_dropping_3], ["voor in t", always_non_dropping_3], ["voor", always_non_dropping_1], ["vor der", either_2_dropping_best], ["vor", either_1_dropping_best], ["z", always_dropping_1], ["ze", always_dropping_1], ["zu", either_1_dropping_best], ["zum", either_1], ["zur", either_1]];
    }();
    CSL.parseParticles = function() {
      function splitParticles(nameValue, firstNameFlag, caseOverride) {
        var origNameValue = nameValue;
        nameValue = caseOverride ? nameValue.toLowerCase() : nameValue;
        var particleList = [];
        var apostrophe;
        if (firstNameFlag) {
          apostrophe = "\u02bb";
          nameValue = nameValue.split("").reverse().join("");
        } else {
          apostrophe = "-\u2019";
        }
        var rex = new RegExp("^([^ ]+[" + apostrophe + " \'] *)(.+)$");
        var m = nameValue.match(rex);
        while (m) {
          var m1 = firstNameFlag ? m[1].split("").reverse().join("") : m[1];
          var firstChar = m ? m1 : false;
          var firstChar = firstChar ? m1.replace(/^[-\'\u02bb\u2019\s]*(.).*$/, "$1") : false;
          var hasParticle = firstChar ? firstChar.toUpperCase() !== firstChar : false;
          if (!hasParticle)
            break;
          if (firstNameFlag) {
            particleList.push(origNameValue.slice(m1.length * -1));
            origNameValue = origNameValue.slice(0, m1.length * -1);
          } else {
            particleList.push(origNameValue.slice(0, m1.length));
            origNameValue = origNameValue.slice(m1.length);
          }
          nameValue = m[2];
          m = nameValue.match(rex);
        }
        if (firstNameFlag) {
          nameValue = nameValue.split("").reverse().join("");
          particleList.reverse();
          for (var i = 1,
              ilen = particleList.length; i < ilen; i++) {
            if (particleList[i].slice(0, 1) == " ") {
              particleList[i - 1] += " ";
            }
          }
          for (var i = 0,
              ilen = particleList.length; i < ilen; i++) {
            if (particleList[i].slice(0, 1) == " ") {
              particleList[i] = particleList[i].slice(1);
            }
          }
          nameValue = origNameValue.slice(0, nameValue.length);
        } else {
          nameValue = origNameValue.slice(nameValue.length * -1);
        }
        return [hasParticle, nameValue, particleList];
      }
      function trimLast(str) {
        var lastChar = str.slice(-1);
        str = str.trim();
        if (lastChar === " " && ["\'", "\u2019"].indexOf(str.slice(-1)) > -1) {
          str += " ";
        }
        return str;
      }
      function parseSuffix(nameObj) {
        if (!nameObj.suffix && nameObj.given) {
          m = nameObj.given.match(/(\s*,!*\s*)/);
          if (m) {
            idx = nameObj.given.indexOf(m[1]);
            var possible_suffix = nameObj.given.slice(idx + m[1].length);
            var possible_comma = nameObj.given.slice(idx, idx + m[1].length).replace(/\s*/g, "");
            if (possible_suffix.replace(/\./g, "") === 'et al' && !nameObj["dropping-particle"]) {
              nameObj["dropping-particle"] = possible_suffix;
              nameObj["comma-dropping-particle"] = ",";
            } else {
              if (possible_comma.length === 2) {
                nameObj["comma-suffix"] = true;
              }
              nameObj.suffix = possible_suffix;
            }
            nameObj.given = nameObj.given.slice(0, idx);
          }
        }
      }
      return function(nameObj) {
        var res = splitParticles(nameObj.family);
        var hasLastParticle = res[0];
        var lastNameValue = res[1];
        var lastParticleList = res[2];
        nameObj.family = lastNameValue;
        var nonDroppingParticle = trimLast(lastParticleList.join(""));
        if (nonDroppingParticle) {
          nameObj['non-dropping-particle'] = nonDroppingParticle;
        }
        parseSuffix(nameObj);
        var res = splitParticles(nameObj.given, true);
        var hasFirstParticle = res[0];
        var firstNameValue = res[1];
        var firstParticleList = res[2];
        nameObj.given = firstNameValue;
        var droppingParticle = firstParticleList.join("").trim();
        if (droppingParticle) {
          nameObj['dropping-particle'] = droppingParticle;
        }
      };
    }();
    this["CSL"] = CSL;
    this["CSL_IS_NODEJS"] = CSL_IS_NODEJS;
    this["CSL_NODEJS"] = CSL_NODEJS;
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:juris-m/citeproc-js@1.1.101.js", ["github:juris-m/citeproc-js@1.1.101/citeproc.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('github:juris-m/citeproc-js@1.1.101/citeproc.js');
  return module.exports;
});

System.registerDynamic("npm:urijs@1.17.1/src/punycode.js", ["github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(process) {
    ;
    (function(root) {
      var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
      var freeModule = typeof module == 'object' && module && !module.nodeType && module;
      var freeGlobal = typeof global == 'object' && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode,
          maxInt = 2147483647,
          base = 36,
          tMin = 1,
          tMax = 26,
          skew = 38,
          damp = 700,
          initialBias = 72,
          initialN = 128,
          delimiter = '-',
          regexPunycode = /^xn--/,
          regexNonASCII = /[^\x20-\x7E]/,
          regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
          errors = {
            'overflow': 'Overflow: input needs wider integers to process',
            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
            'invalid-input': 'Invalid input'
          },
          baseMinusTMin = base - tMin,
          floor = Math.floor,
          stringFromCharCode = String.fromCharCode,
          key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
          result = parts[0] + '@';
          string = parts[1];
        }
        string = string.replace(regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = map(labels, fn).join('.');
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [],
            counter = 0,
            length = string.length,
            value,
            extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
              output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = '';
          if (value > 0xFFFF) {
            value -= 0x10000;
            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
            value = 0xDC00 | value & 0x3FF;
          }
          output += stringFromCharCode(value);
          return output;
        }).join('');
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [],
            inputLength = input.length,
            out,
            i = 0,
            n = initialN,
            bias = initialBias,
            basic,
            j,
            index,
            oldi,
            w,
            k,
            digit,
            t,
            baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 0x80) {
            error('not-basic');
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error('invalid-input');
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error('overflow');
            }
            i += digit * w;
            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error('overflow');
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error('overflow');
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n,
            delta,
            handledCPCount,
            basicLength,
            bias,
            j,
            m,
            q,
            k,
            t,
            currentValue,
            output = [],
            inputLength,
            handledCPCountPlusOne,
            baseMinusT,
            qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 0x80) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error('overflow');
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error('overflow');
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join('');
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
        });
      }
      punycode = {
        'version': '1.3.2',
        'ucs2': {
          'decode': ucs2decode,
          'encode': ucs2encode
        },
        'decode': decode,
        'encode': encode,
        'toASCII': toASCII,
        'toUnicode': toUnicode
      };
      if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define('punycode', function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    }(this));
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  return module.exports;
});

System.registerDynamic("npm:urijs@1.17.1/src/IPv6.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(root, factory) {
    'use strict';
    if (typeof exports === 'object') {
      module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
      define(factory);
    } else {
      root.IPv6 = factory(root);
    }
  }(this, function(root) {
    'use strict';
    var _IPv6 = root && root.IPv6;
    function bestPresentation(address) {
      var _address = address.toLowerCase();
      var segments = _address.split(':');
      var length = segments.length;
      var total = 8;
      if (segments[0] === '' && segments[1] === '' && segments[2] === '') {
        segments.shift();
        segments.shift();
      } else if (segments[0] === '' && segments[1] === '') {
        segments.shift();
      } else if (segments[length - 1] === '' && segments[length - 2] === '') {
        segments.pop();
      }
      length = segments.length;
      if (segments[length - 1].indexOf('.') !== -1) {
        total = 7;
      }
      var pos;
      for (pos = 0; pos < length; pos++) {
        if (segments[pos] === '') {
          break;
        }
      }
      if (pos < total) {
        segments.splice(pos, 1, '0000');
        while (segments.length < total) {
          segments.splice(pos, 0, '0000');
        }
        length = segments.length;
      }
      var _segments;
      for (var i = 0; i < total; i++) {
        _segments = segments[i].split('');
        for (var j = 0; j < 3; j++) {
          if (_segments[0] === '0' && _segments.length > 1) {
            _segments.splice(0, 1);
          } else {
            break;
          }
        }
        segments[i] = _segments.join('');
      }
      var best = -1;
      var _best = 0;
      var _current = 0;
      var current = -1;
      var inzeroes = false;
      for (i = 0; i < total; i++) {
        if (inzeroes) {
          if (segments[i] === '0') {
            _current += 1;
          } else {
            inzeroes = false;
            if (_current > _best) {
              best = current;
              _best = _current;
            }
          }
        } else {
          if (segments[i] === '0') {
            inzeroes = true;
            current = i;
            _current = 1;
          }
        }
      }
      if (_current > _best) {
        best = current;
        _best = _current;
      }
      if (_best > 1) {
        segments.splice(best, _best, '');
      }
      length = segments.length;
      var result = '';
      if (segments[0] === '') {
        result = ':';
      }
      for (i = 0; i < length; i++) {
        result += segments[i];
        if (i === length - 1) {
          break;
        }
        result += ':';
      }
      if (segments[length - 1] === '') {
        result += ':';
      }
      return result;
    }
    function noConflict() {
      if (root.IPv6 === this) {
        root.IPv6 = _IPv6;
      }
      return this;
    }
    return {
      best: bestPresentation,
      noConflict: noConflict
    };
  }));
  return module.exports;
});

System.registerDynamic("npm:urijs@1.17.1/src/SecondLevelDomains.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(root, factory) {
    'use strict';
    if (typeof exports === 'object') {
      module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
      define(factory);
    } else {
      root.SecondLevelDomains = factory(root);
    }
  }(this, function(root) {
    'use strict';
    var _SecondLevelDomains = root && root.SecondLevelDomains;
    var SLD = {
      list: {
        'ac': ' com gov mil net org ',
        'ae': ' ac co gov mil name net org pro sch ',
        'af': ' com edu gov net org ',
        'al': ' com edu gov mil net org ',
        'ao': ' co ed gv it og pb ',
        'ar': ' com edu gob gov int mil net org tur ',
        'at': ' ac co gv or ',
        'au': ' asn com csiro edu gov id net org ',
        'ba': ' co com edu gov mil net org rs unbi unmo unsa untz unze ',
        'bb': ' biz co com edu gov info net org store tv ',
        'bh': ' biz cc com edu gov info net org ',
        'bn': ' com edu gov net org ',
        'bo': ' com edu gob gov int mil net org tv ',
        'br': ' adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ',
        'bs': ' com edu gov net org ',
        'bz': ' du et om ov rg ',
        'ca': ' ab bc mb nb nf nl ns nt nu on pe qc sk yk ',
        'ck': ' biz co edu gen gov info net org ',
        'cn': ' ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ',
        'co': ' com edu gov mil net nom org ',
        'cr': ' ac c co ed fi go or sa ',
        'cy': ' ac biz com ekloges gov ltd name net org parliament press pro tm ',
        'do': ' art com edu gob gov mil net org sld web ',
        'dz': ' art asso com edu gov net org pol ',
        'ec': ' com edu fin gov info med mil net org pro ',
        'eg': ' com edu eun gov mil name net org sci ',
        'er': ' com edu gov ind mil net org rochest w ',
        'es': ' com edu gob nom org ',
        'et': ' biz com edu gov info name net org ',
        'fj': ' ac biz com info mil name net org pro ',
        'fk': ' ac co gov net nom org ',
        'fr': ' asso com f gouv nom prd presse tm ',
        'gg': ' co net org ',
        'gh': ' com edu gov mil org ',
        'gn': ' ac com gov net org ',
        'gr': ' com edu gov mil net org ',
        'gt': ' com edu gob ind mil net org ',
        'gu': ' com edu gov net org ',
        'hk': ' com edu gov idv net org ',
        'hu': ' 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ',
        'id': ' ac co go mil net or sch web ',
        'il': ' ac co gov idf k12 muni net org ',
        'in': ' ac co edu ernet firm gen gov i ind mil net nic org res ',
        'iq': ' com edu gov i mil net org ',
        'ir': ' ac co dnssec gov i id net org sch ',
        'it': ' edu gov ',
        'je': ' co net org ',
        'jo': ' com edu gov mil name net org sch ',
        'jp': ' ac ad co ed go gr lg ne or ',
        'ke': ' ac co go info me mobi ne or sc ',
        'kh': ' com edu gov mil net org per ',
        'ki': ' biz com de edu gov info mob net org tel ',
        'km': ' asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ',
        'kn': ' edu gov net org ',
        'kr': ' ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ',
        'kw': ' com edu gov net org ',
        'ky': ' com edu gov net org ',
        'kz': ' com edu gov mil net org ',
        'lb': ' com edu gov net org ',
        'lk': ' assn com edu gov grp hotel int ltd net ngo org sch soc web ',
        'lr': ' com edu gov net org ',
        'lv': ' asn com conf edu gov id mil net org ',
        'ly': ' com edu gov id med net org plc sch ',
        'ma': ' ac co gov m net org press ',
        'mc': ' asso tm ',
        'me': ' ac co edu gov its net org priv ',
        'mg': ' com edu gov mil nom org prd tm ',
        'mk': ' com edu gov inf name net org pro ',
        'ml': ' com edu gov net org presse ',
        'mn': ' edu gov org ',
        'mo': ' com edu gov net org ',
        'mt': ' com edu gov net org ',
        'mv': ' aero biz com coop edu gov info int mil museum name net org pro ',
        'mw': ' ac co com coop edu gov int museum net org ',
        'mx': ' com edu gob net org ',
        'my': ' com edu gov mil name net org sch ',
        'nf': ' arts com firm info net other per rec store web ',
        'ng': ' biz com edu gov mil mobi name net org sch ',
        'ni': ' ac co com edu gob mil net nom org ',
        'np': ' com edu gov mil net org ',
        'nr': ' biz com edu gov info net org ',
        'om': ' ac biz co com edu gov med mil museum net org pro sch ',
        'pe': ' com edu gob mil net nom org sld ',
        'ph': ' com edu gov i mil net ngo org ',
        'pk': ' biz com edu fam gob gok gon gop gos gov net org web ',
        'pl': ' art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ',
        'pr': ' ac biz com edu est gov info isla name net org pro prof ',
        'ps': ' com edu gov net org plo sec ',
        'pw': ' belau co ed go ne or ',
        'ro': ' arts com firm info nom nt org rec store tm www ',
        'rs': ' ac co edu gov in org ',
        'sb': ' com edu gov net org ',
        'sc': ' com edu gov net org ',
        'sh': ' co com edu gov net nom org ',
        'sl': ' com edu gov net org ',
        'st': ' co com consulado edu embaixada gov mil net org principe saotome store ',
        'sv': ' com edu gob org red ',
        'sz': ' ac co org ',
        'tr': ' av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ',
        'tt': ' aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ',
        'tw': ' club com ebiz edu game gov idv mil net org ',
        'mu': ' ac co com gov net or org ',
        'mz': ' ac co edu gov org ',
        'na': ' co com ',
        'nz': ' ac co cri geek gen govt health iwi maori mil net org parliament school ',
        'pa': ' abo ac com edu gob ing med net nom org sld ',
        'pt': ' com edu gov int net nome org publ ',
        'py': ' com edu gov mil net org ',
        'qa': ' com edu gov mil net org ',
        're': ' asso com nom ',
        'ru': ' ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ',
        'rw': ' ac co com edu gouv gov int mil net ',
        'sa': ' com edu gov med net org pub sch ',
        'sd': ' com edu gov info med net org tv ',
        'se': ' a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ',
        'sg': ' com edu gov idn net org per ',
        'sn': ' art com edu gouv org perso univ ',
        'sy': ' com edu gov mil net news org ',
        'th': ' ac co go in mi net or ',
        'tj': ' ac biz co com edu go gov info int mil name net nic org test web ',
        'tn': ' agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ',
        'tz': ' ac co go ne or ',
        'ua': ' biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ',
        'ug': ' ac co go ne or org sc ',
        'uk': ' ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ',
        'us': ' dni fed isa kids nsn ',
        'uy': ' com edu gub mil net org ',
        've': ' co com edu gob info mil net org web ',
        'vi': ' co com k12 net org ',
        'vn': ' ac biz com edu gov health info int name net org pro ',
        'ye': ' co com gov ltd me net org plc ',
        'yu': ' ac co edu gov org ',
        'za': ' ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ',
        'zm': ' ac co com edu gov net org sch '
      },
      has: function(domain) {
        var tldOffset = domain.lastIndexOf('.');
        if (tldOffset <= 0 || tldOffset >= (domain.length - 1)) {
          return false;
        }
        var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
        if (sldOffset <= 0 || sldOffset >= (tldOffset - 1)) {
          return false;
        }
        var sldList = SLD.list[domain.slice(tldOffset + 1)];
        if (!sldList) {
          return false;
        }
        return sldList.indexOf(' ' + domain.slice(sldOffset + 1, tldOffset) + ' ') >= 0;
      },
      is: function(domain) {
        var tldOffset = domain.lastIndexOf('.');
        if (tldOffset <= 0 || tldOffset >= (domain.length - 1)) {
          return false;
        }
        var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
        if (sldOffset >= 0) {
          return false;
        }
        var sldList = SLD.list[domain.slice(tldOffset + 1)];
        if (!sldList) {
          return false;
        }
        return sldList.indexOf(' ' + domain.slice(0, tldOffset) + ' ') >= 0;
      },
      get: function(domain) {
        var tldOffset = domain.lastIndexOf('.');
        if (tldOffset <= 0 || tldOffset >= (domain.length - 1)) {
          return null;
        }
        var sldOffset = domain.lastIndexOf('.', tldOffset - 1);
        if (sldOffset <= 0 || sldOffset >= (tldOffset - 1)) {
          return null;
        }
        var sldList = SLD.list[domain.slice(tldOffset + 1)];
        if (!sldList) {
          return null;
        }
        if (sldList.indexOf(' ' + domain.slice(sldOffset + 1, tldOffset) + ' ') < 0) {
          return null;
        }
        return domain.slice(sldOffset + 1);
      },
      noConflict: function() {
        if (root.SecondLevelDomains === this) {
          root.SecondLevelDomains = _SecondLevelDomains;
        }
        return this;
      }
    };
    return SLD;
  }));
  return module.exports;
});

System.registerDynamic("npm:urijs@1.17.1/src/URI.js", ["npm:urijs@1.17.1/src/punycode.js", "npm:urijs@1.17.1/src/IPv6.js", "npm:urijs@1.17.1/src/SecondLevelDomains.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(root, factory) {
    'use strict';
    if (typeof exports === 'object') {
      module.exports = factory($__require('npm:urijs@1.17.1/src/punycode.js'), $__require('npm:urijs@1.17.1/src/IPv6.js'), $__require('npm:urijs@1.17.1/src/SecondLevelDomains.js'));
    } else if (typeof define === 'function' && define.amd) {
      define(['./punycode', './IPv6', './SecondLevelDomains'], factory);
    } else {
      root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
    }
  }(this, function(punycode, IPv6, SLD, root) {
    'use strict';
    var _URI = root && root.URI;
    function URI(url, base) {
      var _urlSupplied = arguments.length >= 1;
      var _baseSupplied = arguments.length >= 2;
      if (!(this instanceof URI)) {
        if (_urlSupplied) {
          if (_baseSupplied) {
            return new URI(url, base);
          }
          return new URI(url);
        }
        return new URI();
      }
      if (url === undefined) {
        if (_urlSupplied) {
          throw new TypeError('undefined is not a valid argument for URI');
        }
        if (typeof location !== 'undefined') {
          url = location.href + '';
        } else {
          url = '';
        }
      }
      this.href(url);
      if (base !== undefined) {
        return this.absoluteTo(base);
      }
      return this;
    }
    URI.version = '1.17.1';
    var p = URI.prototype;
    var hasOwn = Object.prototype.hasOwnProperty;
    function escapeRegEx(string) {
      return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
    }
    function getType(value) {
      if (value === undefined) {
        return 'Undefined';
      }
      return String(Object.prototype.toString.call(value)).slice(8, -1);
    }
    function isArray(obj) {
      return getType(obj) === 'Array';
    }
    function filterArrayValues(data, value) {
      var lookup = {};
      var i,
          length;
      if (getType(value) === 'RegExp') {
        lookup = null;
      } else if (isArray(value)) {
        for (i = 0, length = value.length; i < length; i++) {
          lookup[value[i]] = true;
        }
      } else {
        lookup[value] = true;
      }
      for (i = 0, length = data.length; i < length; i++) {
        var _match = lookup && lookup[data[i]] !== undefined || !lookup && value.test(data[i]);
        if (_match) {
          data.splice(i, 1);
          length--;
          i--;
        }
      }
      return data;
    }
    function arrayContains(list, value) {
      var i,
          length;
      if (isArray(value)) {
        for (i = 0, length = value.length; i < length; i++) {
          if (!arrayContains(list, value[i])) {
            return false;
          }
        }
        return true;
      }
      var _type = getType(value);
      for (i = 0, length = list.length; i < length; i++) {
        if (_type === 'RegExp') {
          if (typeof list[i] === 'string' && list[i].match(value)) {
            return true;
          }
        } else if (list[i] === value) {
          return true;
        }
      }
      return false;
    }
    function arraysEqual(one, two) {
      if (!isArray(one) || !isArray(two)) {
        return false;
      }
      if (one.length !== two.length) {
        return false;
      }
      one.sort();
      two.sort();
      for (var i = 0,
          l = one.length; i < l; i++) {
        if (one[i] !== two[i]) {
          return false;
        }
      }
      return true;
    }
    function trimSlashes(text) {
      var trim_expression = /^\/+|\/+$/g;
      return text.replace(trim_expression, '');
    }
    URI._parts = function() {
      return {
        protocol: null,
        username: null,
        password: null,
        hostname: null,
        urn: null,
        port: null,
        path: null,
        query: null,
        fragment: null,
        duplicateQueryParameters: URI.duplicateQueryParameters,
        escapeQuerySpace: URI.escapeQuerySpace
      };
    };
    URI.duplicateQueryParameters = false;
    URI.escapeQuerySpace = true;
    URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
    URI.idn_expression = /[^a-z0-9\.-]/i;
    URI.punycode_expression = /(xn--)/i;
    URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
    URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
    URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/ig;
    URI.findUri = {
      start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
      end: /[\s\r\n]|$/,
      trim: /[`!()\[\]{};:'".,<>?]+$/
    };
    URI.defaultPorts = {
      http: '80',
      https: '443',
      ftp: '21',
      gopher: '70',
      ws: '80',
      wss: '443'
    };
    URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/;
    URI.domAttributes = {
      'a': 'href',
      'blockquote': 'cite',
      'link': 'href',
      'base': 'href',
      'script': 'src',
      'form': 'action',
      'img': 'src',
      'area': 'href',
      'iframe': 'src',
      'embed': 'src',
      'source': 'src',
      'track': 'src',
      'input': 'src',
      'audio': 'src',
      'video': 'src'
    };
    URI.getDomAttribute = function(node) {
      if (!node || !node.nodeName) {
        return undefined;
      }
      var nodeName = node.nodeName.toLowerCase();
      if (nodeName === 'input' && node.type !== 'image') {
        return undefined;
      }
      return URI.domAttributes[nodeName];
    };
    function escapeForDumbFirefox36(value) {
      return escape(value);
    }
    function strictEncodeURIComponent(string) {
      return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, '%2A');
    }
    URI.encode = strictEncodeURIComponent;
    URI.decode = decodeURIComponent;
    URI.iso8859 = function() {
      URI.encode = escape;
      URI.decode = unescape;
    };
    URI.unicode = function() {
      URI.encode = strictEncodeURIComponent;
      URI.decode = decodeURIComponent;
    };
    URI.characters = {
      pathname: {
        encode: {
          expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
          map: {
            '%24': '$',
            '%26': '&',
            '%2B': '+',
            '%2C': ',',
            '%3B': ';',
            '%3D': '=',
            '%3A': ':',
            '%40': '@'
          }
        },
        decode: {
          expression: /[\/\?#]/g,
          map: {
            '/': '%2F',
            '?': '%3F',
            '#': '%23'
          }
        }
      },
      reserved: {encode: {
          expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
          map: {
            '%3A': ':',
            '%2F': '/',
            '%3F': '?',
            '%23': '#',
            '%5B': '[',
            '%5D': ']',
            '%40': '@',
            '%21': '!',
            '%24': '$',
            '%26': '&',
            '%27': '\'',
            '%28': '(',
            '%29': ')',
            '%2A': '*',
            '%2B': '+',
            '%2C': ',',
            '%3B': ';',
            '%3D': '='
          }
        }},
      urnpath: {
        encode: {
          expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
          map: {
            '%21': '!',
            '%24': '$',
            '%27': '\'',
            '%28': '(',
            '%29': ')',
            '%2A': '*',
            '%2B': '+',
            '%2C': ',',
            '%3B': ';',
            '%3D': '=',
            '%40': '@'
          }
        },
        decode: {
          expression: /[\/\?#:]/g,
          map: {
            '/': '%2F',
            '?': '%3F',
            '#': '%23',
            ':': '%3A'
          }
        }
      }
    };
    URI.encodeQuery = function(string, escapeQuerySpace) {
      var escaped = URI.encode(string + '');
      if (escapeQuerySpace === undefined) {
        escapeQuerySpace = URI.escapeQuerySpace;
      }
      return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
    };
    URI.decodeQuery = function(string, escapeQuerySpace) {
      string += '';
      if (escapeQuerySpace === undefined) {
        escapeQuerySpace = URI.escapeQuerySpace;
      }
      try {
        return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
      } catch (e) {
        return string;
      }
    };
    var _parts = {
      'encode': 'encode',
      'decode': 'decode'
    };
    var _part;
    var generateAccessor = function(_group, _part) {
      return function(string) {
        try {
          return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
            return URI.characters[_group][_part].map[c];
          });
        } catch (e) {
          return string;
        }
      };
    };
    for (_part in _parts) {
      URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
      URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);
    }
    var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
      return function(string) {
        var actualCodingFunc;
        if (!_innerCodingFuncName) {
          actualCodingFunc = URI[_codingFuncName];
        } else {
          actualCodingFunc = function(string) {
            return URI[_codingFuncName](URI[_innerCodingFuncName](string));
          };
        }
        var segments = (string + '').split(_sep);
        for (var i = 0,
            length = segments.length; i < length; i++) {
          segments[i] = actualCodingFunc(segments[i]);
        }
        return segments.join(_sep);
      };
    };
    URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');
    URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');
    URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');
    URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');
    URI.encodeReserved = generateAccessor('reserved', 'encode');
    URI.parse = function(string, parts) {
      var pos;
      if (!parts) {
        parts = {};
      }
      pos = string.indexOf('#');
      if (pos > -1) {
        parts.fragment = string.substring(pos + 1) || null;
        string = string.substring(0, pos);
      }
      pos = string.indexOf('?');
      if (pos > -1) {
        parts.query = string.substring(pos + 1) || null;
        string = string.substring(0, pos);
      }
      if (string.substring(0, 2) === '//') {
        parts.protocol = null;
        string = string.substring(2);
        string = URI.parseAuthority(string, parts);
      } else {
        pos = string.indexOf(':');
        if (pos > -1) {
          parts.protocol = string.substring(0, pos) || null;
          if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
            parts.protocol = undefined;
          } else if (string.substring(pos + 1, pos + 3) === '//') {
            string = string.substring(pos + 3);
            string = URI.parseAuthority(string, parts);
          } else {
            string = string.substring(pos + 1);
            parts.urn = true;
          }
        }
      }
      parts.path = string;
      return parts;
    };
    URI.parseHost = function(string, parts) {
      string = string.replace(/\\/g, '/');
      var pos = string.indexOf('/');
      var bracketPos;
      var t;
      if (pos === -1) {
        pos = string.length;
      }
      if (string.charAt(0) === '[') {
        bracketPos = string.indexOf(']');
        parts.hostname = string.substring(1, bracketPos) || null;
        parts.port = string.substring(bracketPos + 2, pos) || null;
        if (parts.port === '/') {
          parts.port = null;
        }
      } else {
        var firstColon = string.indexOf(':');
        var firstSlash = string.indexOf('/');
        var nextColon = string.indexOf(':', firstColon + 1);
        if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
          parts.hostname = string.substring(0, pos) || null;
          parts.port = null;
        } else {
          t = string.substring(0, pos).split(':');
          parts.hostname = t[0] || null;
          parts.port = t[1] || null;
        }
      }
      if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
        pos++;
        string = '/' + string;
      }
      return string.substring(pos) || '/';
    };
    URI.parseAuthority = function(string, parts) {
      string = URI.parseUserinfo(string, parts);
      return URI.parseHost(string, parts);
    };
    URI.parseUserinfo = function(string, parts) {
      var firstSlash = string.indexOf('/');
      var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
      var t;
      if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
        t = string.substring(0, pos).split(':');
        parts.username = t[0] ? URI.decode(t[0]) : null;
        t.shift();
        parts.password = t[0] ? URI.decode(t.join(':')) : null;
        string = string.substring(pos + 1);
      } else {
        parts.username = null;
        parts.password = null;
      }
      return string;
    };
    URI.parseQuery = function(string, escapeQuerySpace) {
      if (!string) {
        return {};
      }
      string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');
      if (!string) {
        return {};
      }
      var items = {};
      var splits = string.split('&');
      var length = splits.length;
      var v,
          name,
          value;
      for (var i = 0; i < length; i++) {
        v = splits[i].split('=');
        name = URI.decodeQuery(v.shift(), escapeQuerySpace);
        value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;
        if (hasOwn.call(items, name)) {
          if (typeof items[name] === 'string' || items[name] === null) {
            items[name] = [items[name]];
          }
          items[name].push(value);
        } else {
          items[name] = value;
        }
      }
      return items;
    };
    URI.build = function(parts) {
      var t = '';
      if (parts.protocol) {
        t += parts.protocol + ':';
      }
      if (!parts.urn && (t || parts.hostname)) {
        t += '//';
      }
      t += (URI.buildAuthority(parts) || '');
      if (typeof parts.path === 'string') {
        if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {
          t += '/';
        }
        t += parts.path;
      }
      if (typeof parts.query === 'string' && parts.query) {
        t += '?' + parts.query;
      }
      if (typeof parts.fragment === 'string' && parts.fragment) {
        t += '#' + parts.fragment;
      }
      return t;
    };
    URI.buildHost = function(parts) {
      var t = '';
      if (!parts.hostname) {
        return '';
      } else if (URI.ip6_expression.test(parts.hostname)) {
        t += '[' + parts.hostname + ']';
      } else {
        t += parts.hostname;
      }
      if (parts.port) {
        t += ':' + parts.port;
      }
      return t;
    };
    URI.buildAuthority = function(parts) {
      return URI.buildUserinfo(parts) + URI.buildHost(parts);
    };
    URI.buildUserinfo = function(parts) {
      var t = '';
      if (parts.username) {
        t += URI.encode(parts.username);
        if (parts.password) {
          t += ':' + URI.encode(parts.password);
        }
        t += '@';
      }
      return t;
    };
    URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
      var t = '';
      var unique,
          key,
          i,
          length;
      for (key in data) {
        if (hasOwn.call(data, key) && key) {
          if (isArray(data[key])) {
            unique = {};
            for (i = 0, length = data[key].length; i < length; i++) {
              if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
                t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
                if (duplicateQueryParameters !== true) {
                  unique[data[key][i] + ''] = true;
                }
              }
            }
          } else if (data[key] !== undefined) {
            t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
          }
        }
      }
      return t.substring(1);
    };
    URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
      return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
    };
    URI.addQuery = function(data, name, value) {
      if (typeof name === 'object') {
        for (var key in name) {
          if (hasOwn.call(name, key)) {
            URI.addQuery(data, key, name[key]);
          }
        }
      } else if (typeof name === 'string') {
        if (data[name] === undefined) {
          data[name] = value;
          return;
        } else if (typeof data[name] === 'string') {
          data[name] = [data[name]];
        }
        if (!isArray(value)) {
          value = [value];
        }
        data[name] = (data[name] || []).concat(value);
      } else {
        throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
      }
    };
    URI.removeQuery = function(data, name, value) {
      var i,
          length,
          key;
      if (isArray(name)) {
        for (i = 0, length = name.length; i < length; i++) {
          data[name[i]] = undefined;
        }
      } else if (getType(name) === 'RegExp') {
        for (key in data) {
          if (name.test(key)) {
            data[key] = undefined;
          }
        }
      } else if (typeof name === 'object') {
        for (key in name) {
          if (hasOwn.call(name, key)) {
            URI.removeQuery(data, key, name[key]);
          }
        }
      } else if (typeof name === 'string') {
        if (value !== undefined) {
          if (getType(value) === 'RegExp') {
            if (!isArray(data[name]) && value.test(data[name])) {
              data[name] = undefined;
            } else {
              data[name] = filterArrayValues(data[name], value);
            }
          } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
            data[name] = undefined;
          } else if (isArray(data[name])) {
            data[name] = filterArrayValues(data[name], value);
          }
        } else {
          data[name] = undefined;
        }
      } else {
        throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');
      }
    };
    URI.hasQuery = function(data, name, value, withinArray) {
      switch (getType(name)) {
        case 'String':
          break;
        case 'RegExp':
          for (var key in data) {
            if (hasOwn.call(data, key)) {
              if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {
                return true;
              }
            }
          }
          return false;
        case 'Object':
          for (var _key in name) {
            if (hasOwn.call(name, _key)) {
              if (!URI.hasQuery(data, _key, name[_key])) {
                return false;
              }
            }
          }
          return true;
        default:
          throw new TypeError('URI.hasQuery() accepts a string, regular expression or object as the name parameter');
      }
      switch (getType(value)) {
        case 'Undefined':
          return name in data;
        case 'Boolean':
          var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
          return value === _booly;
        case 'Function':
          return !!value(data[name], name, data);
        case 'Array':
          if (!isArray(data[name])) {
            return false;
          }
          var op = withinArray ? arrayContains : arraysEqual;
          return op(data[name], value);
        case 'RegExp':
          if (!isArray(data[name])) {
            return Boolean(data[name] && data[name].match(value));
          }
          if (!withinArray) {
            return false;
          }
          return arrayContains(data[name], value);
        case 'Number':
          value = String(value);
        case 'String':
          if (!isArray(data[name])) {
            return data[name] === value;
          }
          if (!withinArray) {
            return false;
          }
          return arrayContains(data[name], value);
        default:
          throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
      }
    };
    URI.commonPath = function(one, two) {
      var length = Math.min(one.length, two.length);
      var pos;
      for (pos = 0; pos < length; pos++) {
        if (one.charAt(pos) !== two.charAt(pos)) {
          pos--;
          break;
        }
      }
      if (pos < 1) {
        return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
      }
      if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
        pos = one.substring(0, pos).lastIndexOf('/');
      }
      return one.substring(0, pos + 1);
    };
    URI.withinString = function(string, callback, options) {
      options || (options = {});
      var _start = options.start || URI.findUri.start;
      var _end = options.end || URI.findUri.end;
      var _trim = options.trim || URI.findUri.trim;
      var _attributeOpen = /[a-z0-9-]=["']?$/i;
      _start.lastIndex = 0;
      while (true) {
        var match = _start.exec(string);
        if (!match) {
          break;
        }
        var start = match.index;
        if (options.ignoreHtml) {
          var attributeOpen = string.slice(Math.max(start - 3, 0), start);
          if (attributeOpen && _attributeOpen.test(attributeOpen)) {
            continue;
          }
        }
        var end = start + string.slice(start).search(_end);
        var slice = string.slice(start, end).replace(_trim, '');
        if (options.ignore && options.ignore.test(slice)) {
          continue;
        }
        end = start + slice.length;
        var result = callback(slice, start, end, string);
        string = string.slice(0, start) + result + string.slice(end);
        _start.lastIndex = start + result.length;
      }
      _start.lastIndex = 0;
      return string;
    };
    URI.ensureValidHostname = function(v) {
      if (v.match(URI.invalid_hostname_characters)) {
        if (!punycode) {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-] and Punycode.js is not available');
        }
        if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
      }
    };
    URI.noConflict = function(removeAll) {
      if (removeAll) {
        var unconflicted = {URI: this.noConflict()};
        if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
          unconflicted.URITemplate = root.URITemplate.noConflict();
        }
        if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
          unconflicted.IPv6 = root.IPv6.noConflict();
        }
        if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
          unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
        }
        return unconflicted;
      } else if (root.URI === this) {
        root.URI = _URI;
      }
      return this;
    };
    p.build = function(deferBuild) {
      if (deferBuild === true) {
        this._deferred_build = true;
      } else if (deferBuild === undefined || this._deferred_build) {
        this._string = URI.build(this._parts);
        this._deferred_build = false;
      }
      return this;
    };
    p.clone = function() {
      return new URI(this);
    };
    p.valueOf = p.toString = function() {
      return this.build(false)._string;
    };
    function generateSimpleAccessor(_part) {
      return function(v, build) {
        if (v === undefined) {
          return this._parts[_part] || '';
        } else {
          this._parts[_part] = v || null;
          this.build(!build);
          return this;
        }
      };
    }
    function generatePrefixAccessor(_part, _key) {
      return function(v, build) {
        if (v === undefined) {
          return this._parts[_part] || '';
        } else {
          if (v !== null) {
            v = v + '';
            if (v.charAt(0) === _key) {
              v = v.substring(1);
            }
          }
          this._parts[_part] = v;
          this.build(!build);
          return this;
        }
      };
    }
    p.protocol = generateSimpleAccessor('protocol');
    p.username = generateSimpleAccessor('username');
    p.password = generateSimpleAccessor('password');
    p.hostname = generateSimpleAccessor('hostname');
    p.port = generateSimpleAccessor('port');
    p.query = generatePrefixAccessor('query', '?');
    p.fragment = generatePrefixAccessor('fragment', '#');
    p.search = function(v, build) {
      var t = this.query(v, build);
      return typeof t === 'string' && t.length ? ('?' + t) : t;
    };
    p.hash = function(v, build) {
      var t = this.fragment(v, build);
      return typeof t === 'string' && t.length ? ('#' + t) : t;
    };
    p.pathname = function(v, build) {
      if (v === undefined || v === true) {
        var res = this._parts.path || (this._parts.hostname ? '/' : '');
        return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
      } else {
        if (this._parts.urn) {
          this._parts.path = v ? URI.recodeUrnPath(v) : '';
        } else {
          this._parts.path = v ? URI.recodePath(v) : '/';
        }
        this.build(!build);
        return this;
      }
    };
    p.path = p.pathname;
    p.href = function(href, build) {
      var key;
      if (href === undefined) {
        return this.toString();
      }
      this._string = '';
      this._parts = URI._parts();
      var _URI = href instanceof URI;
      var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
      if (href.nodeName) {
        var attribute = URI.getDomAttribute(href);
        href = href[attribute] || '';
        _object = false;
      }
      if (!_URI && _object && href.pathname !== undefined) {
        href = href.toString();
      }
      if (typeof href === 'string' || href instanceof String) {
        this._parts = URI.parse(String(href), this._parts);
      } else if (_URI || _object) {
        var src = _URI ? href._parts : href;
        for (key in src) {
          if (hasOwn.call(this._parts, key)) {
            this._parts[key] = src[key];
          }
        }
      } else {
        throw new TypeError('invalid input');
      }
      this.build(!build);
      return this;
    };
    p.is = function(what) {
      var ip = false;
      var ip4 = false;
      var ip6 = false;
      var name = false;
      var sld = false;
      var idn = false;
      var punycode = false;
      var relative = !this._parts.urn;
      if (this._parts.hostname) {
        relative = false;
        ip4 = URI.ip4_expression.test(this._parts.hostname);
        ip6 = URI.ip6_expression.test(this._parts.hostname);
        ip = ip4 || ip6;
        name = !ip;
        sld = name && SLD && SLD.has(this._parts.hostname);
        idn = name && URI.idn_expression.test(this._parts.hostname);
        punycode = name && URI.punycode_expression.test(this._parts.hostname);
      }
      switch (what.toLowerCase()) {
        case 'relative':
          return relative;
        case 'absolute':
          return !relative;
        case 'domain':
        case 'name':
          return name;
        case 'sld':
          return sld;
        case 'ip':
          return ip;
        case 'ip4':
        case 'ipv4':
        case 'inet4':
          return ip4;
        case 'ip6':
        case 'ipv6':
        case 'inet6':
          return ip6;
        case 'idn':
          return idn;
        case 'url':
          return !this._parts.urn;
        case 'urn':
          return !!this._parts.urn;
        case 'punycode':
          return punycode;
      }
      return null;
    };
    var _protocol = p.protocol;
    var _port = p.port;
    var _hostname = p.hostname;
    p.protocol = function(v, build) {
      if (v !== undefined) {
        if (v) {
          v = v.replace(/:(\/\/)?$/, '');
          if (!v.match(URI.protocol_expression)) {
            throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
          }
        }
      }
      return _protocol.call(this, v, build);
    };
    p.scheme = p.protocol;
    p.port = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v !== undefined) {
        if (v === 0) {
          v = null;
        }
        if (v) {
          v += '';
          if (v.charAt(0) === ':') {
            v = v.substring(1);
          }
          if (v.match(/[^0-9]/)) {
            throw new TypeError('Port "' + v + '" contains characters other than [0-9]');
          }
        }
      }
      return _port.call(this, v, build);
    };
    p.hostname = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v !== undefined) {
        var x = {};
        var res = URI.parseHost(v, x);
        if (res !== '/') {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
        v = x.hostname;
      }
      return _hostname.call(this, v, build);
    };
    p.origin = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        var protocol = this.protocol();
        var authority = this.authority();
        if (!authority) {
          return '';
        }
        return (protocol ? protocol + '://' : '') + this.authority();
      } else {
        var origin = URI(v);
        this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
        return this;
      }
    };
    p.host = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        return this._parts.hostname ? URI.buildHost(this._parts) : '';
      } else {
        var res = URI.parseHost(v, this._parts);
        if (res !== '/') {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
        this.build(!build);
        return this;
      }
    };
    p.authority = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
      } else {
        var res = URI.parseAuthority(v, this._parts);
        if (res !== '/') {
          throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
        this.build(!build);
        return this;
      }
    };
    p.userinfo = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        if (!this._parts.username) {
          return '';
        }
        var t = URI.buildUserinfo(this._parts);
        return t.substring(0, t.length - 1);
      } else {
        if (v[v.length - 1] !== '@') {
          v += '@';
        }
        URI.parseUserinfo(v, this._parts);
        this.build(!build);
        return this;
      }
    };
    p.resource = function(v, build) {
      var parts;
      if (v === undefined) {
        return this.path() + this.search() + this.hash();
      }
      parts = URI.parse(v);
      this._parts.path = parts.path;
      this._parts.query = parts.query;
      this._parts.fragment = parts.fragment;
      this.build(!build);
      return this;
    };
    p.subdomain = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined) {
        if (!this._parts.hostname || this.is('IP')) {
          return '';
        }
        var end = this._parts.hostname.length - this.domain().length - 1;
        return this._parts.hostname.substring(0, end) || '';
      } else {
        var e = this._parts.hostname.length - this.domain().length;
        var sub = this._parts.hostname.substring(0, e);
        var replace = new RegExp('^' + escapeRegEx(sub));
        if (v && v.charAt(v.length - 1) !== '.') {
          v += '.';
        }
        if (v) {
          URI.ensureValidHostname(v);
        }
        this._parts.hostname = this._parts.hostname.replace(replace, v);
        this.build(!build);
        return this;
      }
    };
    p.domain = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (typeof v === 'boolean') {
        build = v;
        v = undefined;
      }
      if (v === undefined) {
        if (!this._parts.hostname || this.is('IP')) {
          return '';
        }
        var t = this._parts.hostname.match(/\./g);
        if (t && t.length < 2) {
          return this._parts.hostname;
        }
        var end = this._parts.hostname.length - this.tld(build).length - 1;
        end = this._parts.hostname.lastIndexOf('.', end - 1) + 1;
        return this._parts.hostname.substring(end) || '';
      } else {
        if (!v) {
          throw new TypeError('cannot set domain empty');
        }
        URI.ensureValidHostname(v);
        if (!this._parts.hostname || this.is('IP')) {
          this._parts.hostname = v;
        } else {
          var replace = new RegExp(escapeRegEx(this.domain()) + '$');
          this._parts.hostname = this._parts.hostname.replace(replace, v);
        }
        this.build(!build);
        return this;
      }
    };
    p.tld = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (typeof v === 'boolean') {
        build = v;
        v = undefined;
      }
      if (v === undefined) {
        if (!this._parts.hostname || this.is('IP')) {
          return '';
        }
        var pos = this._parts.hostname.lastIndexOf('.');
        var tld = this._parts.hostname.substring(pos + 1);
        if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
          return SLD.get(this._parts.hostname) || tld;
        }
        return tld;
      } else {
        var replace;
        if (!v) {
          throw new TypeError('cannot set TLD empty');
        } else if (v.match(/[^a-zA-Z0-9-]/)) {
          if (SLD && SLD.is(v)) {
            replace = new RegExp(escapeRegEx(this.tld()) + '$');
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          } else {
            throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
          }
        } else if (!this._parts.hostname || this.is('IP')) {
          throw new ReferenceError('cannot set TLD on non-domain host');
        } else {
          replace = new RegExp(escapeRegEx(this.tld()) + '$');
          this._parts.hostname = this._parts.hostname.replace(replace, v);
        }
        this.build(!build);
        return this;
      }
    };
    p.directory = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined || v === true) {
        if (!this._parts.path && !this._parts.hostname) {
          return '';
        }
        if (this._parts.path === '/') {
          return '/';
        }
        var end = this._parts.path.length - this.filename().length - 1;
        var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');
        return v ? URI.decodePath(res) : res;
      } else {
        var e = this._parts.path.length - this.filename().length;
        var directory = this._parts.path.substring(0, e);
        var replace = new RegExp('^' + escapeRegEx(directory));
        if (!this.is('relative')) {
          if (!v) {
            v = '/';
          }
          if (v.charAt(0) !== '/') {
            v = '/' + v;
          }
        }
        if (v && v.charAt(v.length - 1) !== '/') {
          v += '/';
        }
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
        this.build(!build);
        return this;
      }
    };
    p.filename = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined || v === true) {
        if (!this._parts.path || this._parts.path === '/') {
          return '';
        }
        var pos = this._parts.path.lastIndexOf('/');
        var res = this._parts.path.substring(pos + 1);
        return v ? URI.decodePathSegment(res) : res;
      } else {
        var mutatedDirectory = false;
        if (v.charAt(0) === '/') {
          v = v.substring(1);
        }
        if (v.match(/\.?\//)) {
          mutatedDirectory = true;
        }
        var replace = new RegExp(escapeRegEx(this.filename()) + '$');
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
        if (mutatedDirectory) {
          this.normalizePath(build);
        } else {
          this.build(!build);
        }
        return this;
      }
    };
    p.suffix = function(v, build) {
      if (this._parts.urn) {
        return v === undefined ? '' : this;
      }
      if (v === undefined || v === true) {
        if (!this._parts.path || this._parts.path === '/') {
          return '';
        }
        var filename = this.filename();
        var pos = filename.lastIndexOf('.');
        var s,
            res;
        if (pos === -1) {
          return '';
        }
        s = filename.substring(pos + 1);
        res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
        return v ? URI.decodePathSegment(res) : res;
      } else {
        if (v.charAt(0) === '.') {
          v = v.substring(1);
        }
        var suffix = this.suffix();
        var replace;
        if (!suffix) {
          if (!v) {
            return this;
          }
          this._parts.path += '.' + URI.recodePath(v);
        } else if (!v) {
          replace = new RegExp(escapeRegEx('.' + suffix) + '$');
        } else {
          replace = new RegExp(escapeRegEx(suffix) + '$');
        }
        if (replace) {
          v = URI.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
        }
        this.build(!build);
        return this;
      }
    };
    p.segment = function(segment, v, build) {
      var separator = this._parts.urn ? ':' : '/';
      var path = this.path();
      var absolute = path.substring(0, 1) === '/';
      var segments = path.split(separator);
      if (segment !== undefined && typeof segment !== 'number') {
        build = v;
        v = segment;
        segment = undefined;
      }
      if (segment !== undefined && typeof segment !== 'number') {
        throw new Error('Bad segment "' + segment + '", must be 0-based integer');
      }
      if (absolute) {
        segments.shift();
      }
      if (segment < 0) {
        segment = Math.max(segments.length + segment, 0);
      }
      if (v === undefined) {
        return segment === undefined ? segments : segments[segment];
      } else if (segment === null || segments[segment] === undefined) {
        if (isArray(v)) {
          segments = [];
          for (var i = 0,
              l = v.length; i < l; i++) {
            if (!v[i].length && (!segments.length || !segments[segments.length - 1].length)) {
              continue;
            }
            if (segments.length && !segments[segments.length - 1].length) {
              segments.pop();
            }
            segments.push(trimSlashes(v[i]));
          }
        } else if (v || typeof v === 'string') {
          v = trimSlashes(v);
          if (segments[segments.length - 1] === '') {
            segments[segments.length - 1] = v;
          } else {
            segments.push(v);
          }
        }
      } else {
        if (v) {
          segments[segment] = trimSlashes(v);
        } else {
          segments.splice(segment, 1);
        }
      }
      if (absolute) {
        segments.unshift('');
      }
      return this.path(segments.join(separator), build);
    };
    p.segmentCoded = function(segment, v, build) {
      var segments,
          i,
          l;
      if (typeof segment !== 'number') {
        build = v;
        v = segment;
        segment = undefined;
      }
      if (v === undefined) {
        segments = this.segment(segment, v, build);
        if (!isArray(segments)) {
          segments = segments !== undefined ? URI.decode(segments) : undefined;
        } else {
          for (i = 0, l = segments.length; i < l; i++) {
            segments[i] = URI.decode(segments[i]);
          }
        }
        return segments;
      }
      if (!isArray(v)) {
        v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
      } else {
        for (i = 0, l = v.length; i < l; i++) {
          v[i] = URI.encode(v[i]);
        }
      }
      return this.segment(segment, v, build);
    };
    var q = p.query;
    p.query = function(v, build) {
      if (v === true) {
        return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      } else if (typeof v === 'function') {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        var result = v.call(this, data);
        this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        this.build(!build);
        return this;
      } else if (v !== undefined && typeof v !== 'string') {
        this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        this.build(!build);
        return this;
      } else {
        return q.call(this, v, build);
      }
    };
    p.setQuery = function(name, value, build) {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      if (typeof name === 'string' || name instanceof String) {
        data[name] = value !== undefined ? value : null;
      } else if (typeof name === 'object') {
        for (var key in name) {
          if (hasOwn.call(name, key)) {
            data[key] = name[key];
          }
        }
      } else {
        throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
      }
      this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      if (typeof name !== 'string') {
        build = value;
      }
      this.build(!build);
      return this;
    };
    p.addQuery = function(name, value, build) {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      URI.addQuery(data, name, value === undefined ? null : value);
      this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      if (typeof name !== 'string') {
        build = value;
      }
      this.build(!build);
      return this;
    };
    p.removeQuery = function(name, value, build) {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      URI.removeQuery(data, name, value);
      this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      if (typeof name !== 'string') {
        build = value;
      }
      this.build(!build);
      return this;
    };
    p.hasQuery = function(name, value, withinArray) {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      return URI.hasQuery(data, name, value, withinArray);
    };
    p.setSearch = p.setQuery;
    p.addSearch = p.addQuery;
    p.removeSearch = p.removeQuery;
    p.hasSearch = p.hasQuery;
    p.normalize = function() {
      if (this._parts.urn) {
        return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
      }
      return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
    };
    p.normalizeProtocol = function(build) {
      if (typeof this._parts.protocol === 'string') {
        this._parts.protocol = this._parts.protocol.toLowerCase();
        this.build(!build);
      }
      return this;
    };
    p.normalizeHostname = function(build) {
      if (this._parts.hostname) {
        if (this.is('IDN') && punycode) {
          this._parts.hostname = punycode.toASCII(this._parts.hostname);
        } else if (this.is('IPv6') && IPv6) {
          this._parts.hostname = IPv6.best(this._parts.hostname);
        }
        this._parts.hostname = this._parts.hostname.toLowerCase();
        this.build(!build);
      }
      return this;
    };
    p.normalizePort = function(build) {
      if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
        this._parts.port = null;
        this.build(!build);
      }
      return this;
    };
    p.normalizePath = function(build) {
      var _path = this._parts.path;
      if (!_path) {
        return this;
      }
      if (this._parts.urn) {
        this._parts.path = URI.recodeUrnPath(this._parts.path);
        this.build(!build);
        return this;
      }
      if (this._parts.path === '/') {
        return this;
      }
      _path = URI.recodePath(_path);
      var _was_relative;
      var _leadingParents = '';
      var _parent,
          _pos;
      if (_path.charAt(0) !== '/') {
        _was_relative = true;
        _path = '/' + _path;
      }
      if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {
        _path += '/';
      }
      _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, '/').replace(/\/{2,}/g, '/');
      if (_was_relative) {
        _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
        if (_leadingParents) {
          _leadingParents = _leadingParents[0];
        }
      }
      while (true) {
        _parent = _path.search(/\/\.\.(\/|$)/);
        if (_parent === -1) {
          break;
        } else if (_parent === 0) {
          _path = _path.substring(3);
          continue;
        }
        _pos = _path.substring(0, _parent).lastIndexOf('/');
        if (_pos === -1) {
          _pos = _parent;
        }
        _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
      }
      if (_was_relative && this.is('relative')) {
        _path = _leadingParents + _path.substring(1);
      }
      this._parts.path = _path;
      this.build(!build);
      return this;
    };
    p.normalizePathname = p.normalizePath;
    p.normalizeQuery = function(build) {
      if (typeof this._parts.query === 'string') {
        if (!this._parts.query.length) {
          this._parts.query = null;
        } else {
          this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
        }
        this.build(!build);
      }
      return this;
    };
    p.normalizeFragment = function(build) {
      if (!this._parts.fragment) {
        this._parts.fragment = null;
        this.build(!build);
      }
      return this;
    };
    p.normalizeSearch = p.normalizeQuery;
    p.normalizeHash = p.normalizeFragment;
    p.iso8859 = function() {
      var e = URI.encode;
      var d = URI.decode;
      URI.encode = escape;
      URI.decode = decodeURIComponent;
      try {
        this.normalize();
      } finally {
        URI.encode = e;
        URI.decode = d;
      }
      return this;
    };
    p.unicode = function() {
      var e = URI.encode;
      var d = URI.decode;
      URI.encode = strictEncodeURIComponent;
      URI.decode = unescape;
      try {
        this.normalize();
      } finally {
        URI.encode = e;
        URI.decode = d;
      }
      return this;
    };
    p.readable = function() {
      var uri = this.clone();
      uri.username('').password('').normalize();
      var t = '';
      if (uri._parts.protocol) {
        t += uri._parts.protocol + '://';
      }
      if (uri._parts.hostname) {
        if (uri.is('punycode') && punycode) {
          t += punycode.toUnicode(uri._parts.hostname);
          if (uri._parts.port) {
            t += ':' + uri._parts.port;
          }
        } else {
          t += uri.host();
        }
      }
      if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
        t += '/';
      }
      t += uri.path(true);
      if (uri._parts.query) {
        var q = '';
        for (var i = 0,
            qp = uri._parts.query.split('&'),
            l = qp.length; i < l; i++) {
          var kv = (qp[i] || '').split('=');
          q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, '%26');
          if (kv[1] !== undefined) {
            q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, '%26');
          }
        }
        t += '?' + q.substring(1);
      }
      t += URI.decodeQuery(uri.hash(), true);
      return t;
    };
    p.absoluteTo = function(base) {
      var resolved = this.clone();
      var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
      var basedir,
          i,
          p;
      if (this._parts.urn) {
        throw new Error('URNs do not have any generally defined hierarchical components');
      }
      if (!(base instanceof URI)) {
        base = new URI(base);
      }
      if (!resolved._parts.protocol) {
        resolved._parts.protocol = base._parts.protocol;
      }
      if (this._parts.hostname) {
        return resolved;
      }
      for (i = 0; (p = properties[i]); i++) {
        resolved._parts[p] = base._parts[p];
      }
      if (!resolved._parts.path) {
        resolved._parts.path = base._parts.path;
        if (!resolved._parts.query) {
          resolved._parts.query = base._parts.query;
        }
      } else if (resolved._parts.path.substring(-2) === '..') {
        resolved._parts.path += '/';
      }
      if (resolved.path().charAt(0) !== '/') {
        basedir = base.directory();
        basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';
        resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
        resolved.normalizePath();
      }
      resolved.build();
      return resolved;
    };
    p.relativeTo = function(base) {
      var relative = this.clone().normalize();
      var relativeParts,
          baseParts,
          common,
          relativePath,
          basePath;
      if (relative._parts.urn) {
        throw new Error('URNs do not have any generally defined hierarchical components');
      }
      base = new URI(base).normalize();
      relativeParts = relative._parts;
      baseParts = base._parts;
      relativePath = relative.path();
      basePath = base.path();
      if (relativePath.charAt(0) !== '/') {
        throw new Error('URI is already relative');
      }
      if (basePath.charAt(0) !== '/') {
        throw new Error('Cannot calculate a URI relative to another relative URI');
      }
      if (relativeParts.protocol === baseParts.protocol) {
        relativeParts.protocol = null;
      }
      if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
        return relative.build();
      }
      if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
        return relative.build();
      }
      if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
        relativeParts.hostname = null;
        relativeParts.port = null;
      } else {
        return relative.build();
      }
      if (relativePath === basePath) {
        relativeParts.path = '';
        return relative.build();
      }
      common = URI.commonPath(relativePath, basePath);
      if (!common) {
        return relative.build();
      }
      var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, '').replace(/.*?\//g, '../');
      relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';
      return relative.build();
    };
    p.equals = function(uri) {
      var one = this.clone();
      var two = new URI(uri);
      var one_map = {};
      var two_map = {};
      var checked = {};
      var one_query,
          two_query,
          key;
      one.normalize();
      two.normalize();
      if (one.toString() === two.toString()) {
        return true;
      }
      one_query = one.query();
      two_query = two.query();
      one.query('');
      two.query('');
      if (one.toString() !== two.toString()) {
        return false;
      }
      if (one_query.length !== two_query.length) {
        return false;
      }
      one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
      two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
      for (key in one_map) {
        if (hasOwn.call(one_map, key)) {
          if (!isArray(one_map[key])) {
            if (one_map[key] !== two_map[key]) {
              return false;
            }
          } else if (!arraysEqual(one_map[key], two_map[key])) {
            return false;
          }
          checked[key] = true;
        }
      }
      for (key in two_map) {
        if (hasOwn.call(two_map, key)) {
          if (!checked[key]) {
            return false;
          }
        }
      }
      return true;
    };
    p.duplicateQueryParameters = function(v) {
      this._parts.duplicateQueryParameters = !!v;
      return this;
    };
    p.escapeQuerySpace = function(v) {
      this._parts.escapeQuerySpace = !!v;
      return this;
    };
    return URI;
  }));
  return module.exports;
});

System.registerDynamic("npm:urijs@1.17.1.js", ["npm:urijs@1.17.1/src/URI.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:urijs@1.17.1/src/URI.js');
  return module.exports;
});

System.registerDynamic("npm:zip-js@0.0.2/WebContent/zip.js", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    (function(obj) {
      "use strict";
      var ERR_BAD_FORMAT = "File format is not recognized.";
      var ERR_CRC = "CRC failed.";
      var ERR_ENCRYPTED = "File contains encrypted entry.";
      var ERR_ZIP64 = "File is using Zip64 (4gb+ file size).";
      var ERR_READ = "Error while reading zip file.";
      var ERR_WRITE = "Error while writing zip file.";
      var ERR_WRITE_DATA = "Error while writing file data.";
      var ERR_READ_DATA = "Error while reading file data.";
      var ERR_DUPLICATED_NAME = "File already exists.";
      var CHUNK_SIZE = 512 * 1024;
      var TEXT_PLAIN = "text/plain";
      var appendABViewSupported;
      try {
        appendABViewSupported = new Blob([new DataView(new ArrayBuffer(0))]).size === 0;
      } catch (e) {}
      function Crc32() {
        this.crc = -1;
      }
      Crc32.prototype.append = function append(data) {
        var crc = this.crc | 0,
            table = this.table;
        for (var offset = 0,
            len = data.length | 0; offset < len; offset++)
          crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];
        this.crc = crc;
      };
      Crc32.prototype.get = function get() {
        return ~this.crc;
      };
      Crc32.prototype.table = (function() {
        var i,
            j,
            t,
            table = [];
        for (i = 0; i < 256; i++) {
          t = i;
          for (j = 0; j < 8; j++)
            if (t & 1)
              t = (t >>> 1) ^ 0xEDB88320;
            else
              t = t >>> 1;
          table[i] = t;
        }
        return table;
      })();
      function NOOP() {}
      NOOP.prototype.append = function append(bytes, onprogress) {
        return bytes;
      };
      NOOP.prototype.flush = function flush() {};
      function blobSlice(blob, index, length) {
        if (index < 0 || length < 0 || index + length > blob.size)
          throw new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size);
        if (blob.slice)
          return blob.slice(index, index + length);
        else if (blob.webkitSlice)
          return blob.webkitSlice(index, index + length);
        else if (blob.mozSlice)
          return blob.mozSlice(index, index + length);
        else if (blob.msSlice)
          return blob.msSlice(index, index + length);
      }
      function getDataHelper(byteLength, bytes) {
        var dataBuffer,
            dataArray;
        dataBuffer = new ArrayBuffer(byteLength);
        dataArray = new Uint8Array(dataBuffer);
        if (bytes)
          dataArray.set(bytes, 0);
        return {
          buffer: dataBuffer,
          array: dataArray,
          view: new DataView(dataBuffer)
        };
      }
      function Reader() {}
      function TextReader(text) {
        var that = this,
            blobReader;
        function init(callback, onerror) {
          var blob = new Blob([text], {type: TEXT_PLAIN});
          blobReader = new BlobReader(blob);
          blobReader.init(function() {
            that.size = blobReader.size;
            callback();
          }, onerror);
        }
        function readUint8Array(index, length, callback, onerror) {
          blobReader.readUint8Array(index, length, callback, onerror);
        }
        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
      }
      TextReader.prototype = new Reader();
      TextReader.prototype.constructor = TextReader;
      function Data64URIReader(dataURI) {
        var that = this,
            dataStart;
        function init(callback) {
          var dataEnd = dataURI.length;
          while (dataURI.charAt(dataEnd - 1) == "=")
            dataEnd--;
          dataStart = dataURI.indexOf(",") + 1;
          that.size = Math.floor((dataEnd - dataStart) * 0.75);
          callback();
        }
        function readUint8Array(index, length, callback) {
          var i,
              data = getDataHelper(length);
          var start = Math.floor(index / 3) * 4;
          var end = Math.ceil((index + length) / 3) * 4;
          var bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));
          var delta = index - Math.floor(start / 4) * 3;
          for (i = delta; i < delta + length; i++)
            data.array[i - delta] = bytes.charCodeAt(i);
          callback(data.array);
        }
        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
      }
      Data64URIReader.prototype = new Reader();
      Data64URIReader.prototype.constructor = Data64URIReader;
      function BlobReader(blob) {
        var that = this;
        function init(callback) {
          that.size = blob.size;
          callback();
        }
        function readUint8Array(index, length, callback, onerror) {
          var reader = new FileReader();
          reader.onload = function(e) {
            callback(new Uint8Array(e.target.result));
          };
          reader.onerror = onerror;
          try {
            reader.readAsArrayBuffer(blobSlice(blob, index, length));
          } catch (e) {
            onerror(e);
          }
        }
        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
      }
      BlobReader.prototype = new Reader();
      BlobReader.prototype.constructor = BlobReader;
      function Writer() {}
      Writer.prototype.getData = function(callback) {
        callback(this.data);
      };
      function TextWriter(encoding) {
        var that = this,
            blob;
        function init(callback) {
          blob = new Blob([], {type: TEXT_PLAIN});
          callback();
        }
        function writeUint8Array(array, callback) {
          blob = new Blob([blob, appendABViewSupported ? array : array.buffer], {type: TEXT_PLAIN});
          callback();
        }
        function getData(callback, onerror) {
          var reader = new FileReader();
          reader.onload = function(e) {
            callback(e.target.result);
          };
          reader.onerror = onerror;
          reader.readAsText(blob, encoding);
        }
        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
      }
      TextWriter.prototype = new Writer();
      TextWriter.prototype.constructor = TextWriter;
      function Data64URIWriter(contentType) {
        var that = this,
            data = "",
            pending = "";
        function init(callback) {
          data += "data:" + (contentType || "") + ";base64,";
          callback();
        }
        function writeUint8Array(array, callback) {
          var i,
              delta = pending.length,
              dataString = pending;
          pending = "";
          for (i = 0; i < (Math.floor((delta + array.length) / 3) * 3) - delta; i++)
            dataString += String.fromCharCode(array[i]);
          for (; i < array.length; i++)
            pending += String.fromCharCode(array[i]);
          if (dataString.length > 2)
            data += obj.btoa(dataString);
          else
            pending = dataString;
          callback();
        }
        function getData(callback) {
          callback(data + obj.btoa(pending));
        }
        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
      }
      Data64URIWriter.prototype = new Writer();
      Data64URIWriter.prototype.constructor = Data64URIWriter;
      function BlobWriter(contentType) {
        var data = [],
            that = this;
        function init(callback) {
          callback();
        }
        function writeUint8Array(array, callback) {
          data.push(appendABViewSupported ? array : array.buffer);
          callback();
        }
        function getData(callback) {
          callback(new Blob(data, {type: contentType}));
        }
        that.init = init;
        that.writeUint8Array = writeUint8Array;
        that.getData = getData;
      }
      BlobWriter.prototype = new Writer();
      BlobWriter.prototype.constructor = BlobWriter;
      function launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {
        var chunkIndex = 0,
            index,
            outputSize,
            sn = initialMessage.sn,
            crc;
        function onflush() {
          worker.removeEventListener('message', onmessage, false);
          onend(outputSize, crc);
        }
        function onmessage(event) {
          var message = event.data,
              data = message.data,
              err = message.error;
          if (err) {
            err.toString = function() {
              return 'Error: ' + this.message;
            };
            onreaderror(err);
            return;
          }
          if (message.sn !== sn)
            return;
          if (typeof message.codecTime === 'number')
            worker.codecTime += message.codecTime;
          if (typeof message.crcTime === 'number')
            worker.crcTime += message.crcTime;
          switch (message.type) {
            case 'append':
              if (data) {
                outputSize += data.length;
                writer.writeUint8Array(data, function() {
                  step();
                }, onwriteerror);
              } else
                step();
              break;
            case 'flush':
              crc = message.crc;
              if (data) {
                outputSize += data.length;
                writer.writeUint8Array(data, function() {
                  onflush();
                }, onwriteerror);
              } else
                onflush();
              break;
            case 'progress':
              if (onprogress)
                onprogress(index + message.loaded, size);
              break;
            case 'importScripts':
            case 'newTask':
            case 'echo':
              break;
            default:
              console.warn('zip.js:launchWorkerProcess: unknown message: ', message);
          }
        }
        function step() {
          index = chunkIndex * CHUNK_SIZE;
          if (index <= size) {
            reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {
              if (onprogress)
                onprogress(index, size);
              var msg = index === 0 ? initialMessage : {sn: sn};
              msg.type = 'append';
              msg.data = array;
              try {
                worker.postMessage(msg, [array.buffer]);
              } catch (ex) {
                worker.postMessage(msg);
              }
              chunkIndex++;
            }, onreaderror);
          } else {
            worker.postMessage({
              sn: sn,
              type: 'flush'
            });
          }
        }
        outputSize = 0;
        worker.addEventListener('message', onmessage, false);
        step();
      }
      function launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {
        var chunkIndex = 0,
            index,
            outputSize = 0,
            crcInput = crcType === 'input',
            crcOutput = crcType === 'output',
            crc = new Crc32();
        function step() {
          var outputData;
          index = chunkIndex * CHUNK_SIZE;
          if (index < size)
            reader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {
              var outputData;
              try {
                outputData = process.append(inputData, function(loaded) {
                  if (onprogress)
                    onprogress(index + loaded, size);
                });
              } catch (e) {
                onreaderror(e);
                return;
              }
              if (outputData) {
                outputSize += outputData.length;
                writer.writeUint8Array(outputData, function() {
                  chunkIndex++;
                  setTimeout(step, 1);
                }, onwriteerror);
                if (crcOutput)
                  crc.append(outputData);
              } else {
                chunkIndex++;
                setTimeout(step, 1);
              }
              if (crcInput)
                crc.append(inputData);
              if (onprogress)
                onprogress(index, size);
            }, onreaderror);
          else {
            try {
              outputData = process.flush();
            } catch (e) {
              onreaderror(e);
              return;
            }
            if (outputData) {
              if (crcOutput)
                crc.append(outputData);
              outputSize += outputData.length;
              writer.writeUint8Array(outputData, function() {
                onend(outputSize, crc.get());
              }, onwriteerror);
            } else
              onend(outputSize, crc.get());
          }
        }
        step();
      }
      function inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
        var crcType = computeCrc32 ? 'output' : 'none';
        if (obj.zip.useWebWorkers) {
          var initialMessage = {
            sn: sn,
            codecClass: 'Inflater',
            crcType: crcType
          };
          launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
        } else
          launchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
      }
      function deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {
        var crcType = 'input';
        if (obj.zip.useWebWorkers) {
          var initialMessage = {
            sn: sn,
            options: {level: level},
            codecClass: 'Deflater',
            crcType: crcType
          };
          launchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);
        } else
          launchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror);
      }
      function copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {
        var crcType = 'input';
        if (obj.zip.useWebWorkers && computeCrc32) {
          var initialMessage = {
            sn: sn,
            codecClass: 'NOOP',
            crcType: crcType
          };
          launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);
        } else
          launchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);
      }
      function decodeASCII(str) {
        var i,
            out = "",
            charCode,
            extendedASCII = ['\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7', '\u00EA', '\u00EB', '\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5', '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9', '\u00FF', '\u00D6', '\u00DC', '\u00F8', '\u00A3', '\u00D8', '\u00D7', '\u0192', '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1', '\u00AA', '\u00BA', '\u00BF', '\u00AE', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB', '_', '_', '_', '\u00A6', '\u00A6', '\u00C1', '\u00C2', '\u00C0', '\u00A9', '\u00A6', '\u00A6', '+', '+', '\u00A2', '\u00A5', '+', '+', '-', '-', '+', '-', '+', '\u00E3', '\u00C3', '+', '+', '-', '-', '\u00A6', '-', '+', '\u00A4', '\u00F0', '\u00D0', '\u00CA', '\u00CB', '\u00C8', 'i', '\u00CD', '\u00CE', '\u00CF', '+', '+', '_', '_', '\u00A6', '\u00CC', '_', '\u00D3', '\u00DF', '\u00D4', '\u00D2', '\u00F5', '\u00D5', '\u00B5', '\u00FE', '\u00DE', '\u00DA', '\u00DB', '\u00D9', '\u00FD', '\u00DD', '\u00AF', '\u00B4', '\u00AD', '\u00B1', '_', '\u00BE', '\u00B6', '\u00A7', '\u00F7', '\u00B8', '\u00B0', '\u00A8', '\u00B7', '\u00B9', '\u00B3', '\u00B2', '_', ' '];
        for (i = 0; i < str.length; i++) {
          charCode = str.charCodeAt(i) & 0xFF;
          if (charCode > 127)
            out += extendedASCII[charCode - 128];
          else
            out += String.fromCharCode(charCode);
        }
        return out;
      }
      function decodeUTF8(string) {
        return decodeURIComponent(escape(string));
      }
      function getString(bytes) {
        var i,
            str = "";
        for (i = 0; i < bytes.length; i++)
          str += String.fromCharCode(bytes[i]);
        return str;
      }
      function getDate(timeRaw) {
        var date = (timeRaw & 0xffff0000) >> 16,
            time = timeRaw & 0x0000ffff;
        try {
          return new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5, (time & 0x001F) * 2, 0);
        } catch (e) {}
      }
      function readCommonHeader(entry, data, index, centralDirectory, onerror) {
        entry.version = data.view.getUint16(index, true);
        entry.bitFlag = data.view.getUint16(index + 2, true);
        entry.compressionMethod = data.view.getUint16(index + 4, true);
        entry.lastModDateRaw = data.view.getUint32(index + 6, true);
        entry.lastModDate = getDate(entry.lastModDateRaw);
        if ((entry.bitFlag & 0x01) === 0x01) {
          onerror(ERR_ENCRYPTED);
          return;
        }
        if (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {
          entry.crc32 = data.view.getUint32(index + 10, true);
          entry.compressedSize = data.view.getUint32(index + 14, true);
          entry.uncompressedSize = data.view.getUint32(index + 18, true);
        }
        if (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {
          onerror(ERR_ZIP64);
          return;
        }
        entry.filenameLength = data.view.getUint16(index + 22, true);
        entry.extraFieldLength = data.view.getUint16(index + 24, true);
      }
      function createZipReader(reader, callback, onerror) {
        var inflateSN = 0;
        function Entry() {}
        Entry.prototype.getData = function(writer, onend, onprogress, checkCrc32) {
          var that = this;
          function testCrc32(crc32) {
            var dataCrc32 = getDataHelper(4);
            dataCrc32.view.setUint32(0, crc32);
            return that.crc32 == dataCrc32.view.getUint32(0);
          }
          function getWriterData(uncompressedSize, crc32) {
            if (checkCrc32 && !testCrc32(crc32))
              onerror(ERR_CRC);
            else
              writer.getData(function(data) {
                onend(data);
              });
          }
          function onreaderror(err) {
            onerror(err || ERR_READ_DATA);
          }
          function onwriteerror(err) {
            onerror(err || ERR_WRITE_DATA);
          }
          reader.readUint8Array(that.offset, 30, function(bytes) {
            var data = getDataHelper(bytes.length, bytes),
                dataOffset;
            if (data.view.getUint32(0) != 0x504b0304) {
              onerror(ERR_BAD_FORMAT);
              return;
            }
            readCommonHeader(that, data, 4, false, onerror);
            dataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;
            writer.init(function() {
              if (that.compressionMethod === 0)
                copy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
              else
                inflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);
            }, onwriteerror);
          }, onreaderror);
        };
        function seekEOCDR(eocdrCallback) {
          var EOCDR_MIN = 22;
          if (reader.size < EOCDR_MIN) {
            onerror(ERR_BAD_FORMAT);
            return;
          }
          var ZIP_COMMENT_MAX = 256 * 256,
              EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;
          doSeek(EOCDR_MIN, function() {
            doSeek(Math.min(EOCDR_MAX, reader.size), function() {
              onerror(ERR_BAD_FORMAT);
            });
          });
          function doSeek(length, eocdrNotFoundCallback) {
            reader.readUint8Array(reader.size - length, length, function(bytes) {
              for (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {
                if (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {
                  eocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));
                  return;
                }
              }
              eocdrNotFoundCallback();
            }, function() {
              onerror(ERR_READ);
            });
          }
        }
        var zipReader = {
          getEntries: function(callback) {
            var worker = this._worker;
            seekEOCDR(function(dataView) {
              var datalength,
                  fileslength;
              datalength = dataView.getUint32(16, true);
              fileslength = dataView.getUint16(8, true);
              if (datalength < 0 || datalength >= reader.size) {
                onerror(ERR_BAD_FORMAT);
                return;
              }
              reader.readUint8Array(datalength, reader.size - datalength, function(bytes) {
                var i,
                    index = 0,
                    entries = [],
                    entry,
                    filename,
                    comment,
                    data = getDataHelper(bytes.length, bytes);
                for (i = 0; i < fileslength; i++) {
                  entry = new Entry();
                  entry._worker = worker;
                  if (data.view.getUint32(index) != 0x504b0102) {
                    onerror(ERR_BAD_FORMAT);
                    return;
                  }
                  readCommonHeader(entry, data, index + 6, true, onerror);
                  entry.commentLength = data.view.getUint16(index + 32, true);
                  entry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);
                  entry.offset = data.view.getUint32(index + 42, true);
                  filename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));
                  entry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);
                  if (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == "/")
                    entry.directory = true;
                  comment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength));
                  entry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);
                  entries.push(entry);
                  index += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;
                }
                callback(entries);
              }, function() {
                onerror(ERR_READ);
              });
            });
          },
          close: function(callback) {
            if (this._worker) {
              this._worker.terminate();
              this._worker = null;
            }
            if (callback)
              callback();
          },
          _worker: null
        };
        if (!obj.zip.useWebWorkers)
          callback(zipReader);
        else {
          createWorker('inflater', function(worker) {
            zipReader._worker = worker;
            callback(zipReader);
          }, function(err) {
            onerror(err);
          });
        }
      }
      function encodeUTF8(string) {
        return unescape(encodeURIComponent(string));
      }
      function getBytes(str) {
        var i,
            array = [];
        for (i = 0; i < str.length; i++)
          array.push(str.charCodeAt(i));
        return array;
      }
      function createZipWriter(writer, callback, onerror, dontDeflate) {
        var files = {},
            filenames = [],
            datalength = 0;
        var deflateSN = 0;
        function onwriteerror(err) {
          onerror(err || ERR_WRITE);
        }
        function onreaderror(err) {
          onerror(err || ERR_READ_DATA);
        }
        var zipWriter = {
          add: function(name, reader, onend, onprogress, options) {
            var header,
                filename,
                date;
            var worker = this._worker;
            function writeHeader(callback) {
              var data;
              date = options.lastModDate || new Date();
              header = getDataHelper(26);
              files[name] = {
                headerArray: header.array,
                directory: options.directory,
                filename: filename,
                offset: datalength,
                comment: getBytes(encodeUTF8(options.comment || ""))
              };
              header.view.setUint32(0, 0x14000808);
              if (options.version)
                header.view.setUint8(0, options.version);
              if (!dontDeflate && options.level !== 0 && !options.directory)
                header.view.setUint16(4, 0x0800);
              header.view.setUint16(6, (((date.getHours() << 6) | date.getMinutes()) << 5) | date.getSeconds() / 2, true);
              header.view.setUint16(8, ((((date.getFullYear() - 1980) << 4) | (date.getMonth() + 1)) << 5) | date.getDate(), true);
              header.view.setUint16(22, filename.length, true);
              data = getDataHelper(30 + filename.length);
              data.view.setUint32(0, 0x504b0304);
              data.array.set(header.array, 4);
              data.array.set(filename, 30);
              datalength += data.array.length;
              writer.writeUint8Array(data.array, callback, onwriteerror);
            }
            function writeFooter(compressedLength, crc32) {
              var footer = getDataHelper(16);
              datalength += compressedLength || 0;
              footer.view.setUint32(0, 0x504b0708);
              if (typeof crc32 != "undefined") {
                header.view.setUint32(10, crc32, true);
                footer.view.setUint32(4, crc32, true);
              }
              if (reader) {
                footer.view.setUint32(8, compressedLength, true);
                header.view.setUint32(14, compressedLength, true);
                footer.view.setUint32(12, reader.size, true);
                header.view.setUint32(18, reader.size, true);
              }
              writer.writeUint8Array(footer.array, function() {
                datalength += 16;
                onend();
              }, onwriteerror);
            }
            function writeFile() {
              options = options || {};
              name = name.trim();
              if (options.directory && name.charAt(name.length - 1) != "/")
                name += "/";
              if (files.hasOwnProperty(name)) {
                onerror(ERR_DUPLICATED_NAME);
                return;
              }
              filename = getBytes(encodeUTF8(name));
              filenames.push(name);
              writeHeader(function() {
                if (reader)
                  if (dontDeflate || options.level === 0)
                    copy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);
                  else
                    deflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);
                else
                  writeFooter();
              }, onwriteerror);
            }
            if (reader)
              reader.init(writeFile, onreaderror);
            else
              writeFile();
          },
          close: function(callback) {
            if (this._worker) {
              this._worker.terminate();
              this._worker = null;
            }
            var data,
                length = 0,
                index = 0,
                indexFilename,
                file;
            for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
              file = files[filenames[indexFilename]];
              length += 46 + file.filename.length + file.comment.length;
            }
            data = getDataHelper(length + 22);
            for (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {
              file = files[filenames[indexFilename]];
              data.view.setUint32(index, 0x504b0102);
              data.view.setUint16(index + 4, 0x1400);
              data.array.set(file.headerArray, index + 6);
              data.view.setUint16(index + 32, file.comment.length, true);
              if (file.directory)
                data.view.setUint8(index + 38, 0x10);
              data.view.setUint32(index + 42, file.offset, true);
              data.array.set(file.filename, index + 46);
              data.array.set(file.comment, index + 46 + file.filename.length);
              index += 46 + file.filename.length + file.comment.length;
            }
            data.view.setUint32(index, 0x504b0506);
            data.view.setUint16(index + 8, filenames.length, true);
            data.view.setUint16(index + 10, filenames.length, true);
            data.view.setUint32(index + 12, length, true);
            data.view.setUint32(index + 16, datalength, true);
            writer.writeUint8Array(data.array, function() {
              writer.getData(callback);
            }, onwriteerror);
          },
          _worker: null
        };
        if (!obj.zip.useWebWorkers)
          callback(zipWriter);
        else {
          createWorker('deflater', function(worker) {
            zipWriter._worker = worker;
            callback(zipWriter);
          }, function(err) {
            onerror(err);
          });
        }
      }
      function resolveURLs(urls) {
        var a = document.createElement('a');
        return urls.map(function(url) {
          a.href = url;
          return a.href;
        });
      }
      var DEFAULT_WORKER_SCRIPTS = {
        deflater: ['z-worker.js', 'deflate.js'],
        inflater: ['z-worker.js', 'inflate.js']
      };
      function createWorker(type, callback, onerror) {
        if (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {
          onerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));
          return;
        }
        var scripts;
        if (obj.zip.workerScripts) {
          scripts = obj.zip.workerScripts[type];
          if (!Array.isArray(scripts)) {
            onerror(new Error('zip.workerScripts.' + type + ' is not an array!'));
            return;
          }
          scripts = resolveURLs(scripts);
        } else {
          scripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);
          scripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];
        }
        var worker = new Worker(scripts[0]);
        worker.codecTime = worker.crcTime = 0;
        worker.postMessage({
          type: 'importScripts',
          scripts: scripts.slice(1)
        });
        worker.addEventListener('message', onmessage);
        function onmessage(ev) {
          var msg = ev.data;
          if (msg.error) {
            worker.terminate();
            onerror(msg.error);
            return;
          }
          if (msg.type === 'importScripts') {
            worker.removeEventListener('message', onmessage);
            worker.removeEventListener('error', errorHandler);
            callback(worker);
          }
        }
        worker.addEventListener('error', errorHandler);
        function errorHandler(err) {
          worker.terminate();
          onerror(err);
        }
      }
      function onerror_default(error) {
        console.error(error);
      }
      obj.zip = {
        Reader: Reader,
        Writer: Writer,
        BlobReader: BlobReader,
        Data64URIReader: Data64URIReader,
        TextReader: TextReader,
        BlobWriter: BlobWriter,
        Data64URIWriter: Data64URIWriter,
        TextWriter: TextWriter,
        createReader: function(reader, callback, onerror) {
          onerror = onerror || onerror_default;
          reader.init(function() {
            createZipReader(reader, callback, onerror);
          }, onerror);
        },
        createWriter: function(writer, callback, onerror, dontDeflate) {
          onerror = onerror || onerror_default;
          dontDeflate = !!dontDeflate;
          writer.init(function() {
            createZipWriter(writer, callback, onerror, dontDeflate);
          }, onerror);
        },
        useWebWorkers: true,
        workerScriptsPath: null,
        workerScripts: null
      };
    })(this);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:zip-js@0.0.2/WebContent/pako/codecs.js", ["npm:zip-js@0.0.2/WebContent/zip.js", "npm:pako@1.0.1.js"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, "zip", null);
  (function() {
    "format global";
    "deps ../zip.js";
    "deps pako";
    "exports zip";
    (function(global) {
      "use strict";
      function Codec(isDeflater, options) {
        var newOptions = {
          raw: true,
          chunkSize: 1024 * 1024
        };
        if (options && typeof options.level === 'number')
          newOptions.level = options.level;
        this._backEnd = isDeflater ? new pako.Deflate(newOptions) : new pako.Inflate(newOptions);
        this._chunks = [];
        this._dataLength = 0;
        this._backEnd.onData = this._onData.bind(this);
      }
      Codec.prototype._onData = function _onData(chunk) {
        this._chunks.push(chunk);
        this._dataLength += chunk.length;
      };
      Codec.prototype._fetchData = function _fetchData() {
        var be = this._backEnd;
        if (be.err !== 0)
          throw new Error(be.msg);
        var chunks = this._chunks;
        var data;
        if (chunks.length === 1)
          data = chunks[0];
        else if (chunks.length > 1) {
          data = new Uint8Array(this._dataLength);
          for (var i = 0,
              n = chunks.length,
              off = 0; i < n; i++) {
            var chunk = chunks[i];
            data.set(chunk, off);
            off += chunk.length;
          }
        }
        chunks.length = 0;
        this._dataLength = 0;
        return data;
      };
      Codec.prototype.append = function append(bytes, onprogress) {
        this._backEnd.push(bytes, false);
        return this._fetchData();
      };
      Codec.prototype.flush = function flush() {
        this._backEnd.push(new Uint8Array(0), true);
        return this._fetchData();
      };
      function Deflater(options) {
        Codec.call(this, true, options);
      }
      Deflater.prototype = Object.create(Codec.prototype);
      function Inflater() {
        Codec.call(this, false);
      }
      Inflater.prototype = Object.create(Codec.prototype);
      var env = global.zip || global;
      env.Deflater = env._pako_Deflater = Deflater;
      env.Inflater = env._pako_Inflater = Inflater;
    })(this);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:zip-js@0.0.2/WebContent/zip-fs.js", ["npm:zip-js@0.0.2/WebContent/pako/codecs.js"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal($__module.id, "zip", null);
  (function() {
    "format global";
    "deps ./pako/codecs.js";
    "exports zip";
    (function() {
      "use strict";
      var CHUNK_SIZE = 512 * 1024;
      var TextWriter = zip.TextWriter,
          BlobWriter = zip.BlobWriter,
          Data64URIWriter = zip.Data64URIWriter,
          Reader = zip.Reader,
          TextReader = zip.TextReader,
          BlobReader = zip.BlobReader,
          Data64URIReader = zip.Data64URIReader,
          createReader = zip.createReader,
          createWriter = zip.createWriter;
      function ZipBlobReader(entry) {
        var that = this,
            blobReader;
        function init(callback) {
          that.size = entry.uncompressedSize;
          callback();
        }
        function getData(callback) {
          if (that.data)
            callback();
          else
            entry.getData(new BlobWriter(), function(data) {
              that.data = data;
              blobReader = new BlobReader(data);
              callback();
            }, null, that.checkCrc32);
        }
        function readUint8Array(index, length, callback, onerror) {
          getData(function() {
            blobReader.readUint8Array(index, length, callback, onerror);
          }, onerror);
        }
        that.size = 0;
        that.init = init;
        that.readUint8Array = readUint8Array;
      }
      ZipBlobReader.prototype = new Reader();
      ZipBlobReader.prototype.constructor = ZipBlobReader;
      ZipBlobReader.prototype.checkCrc32 = false;
      function getTotalSize(entry) {
        var size = 0;
        function process(entry) {
          size += entry.uncompressedSize || 0;
          entry.children.forEach(process);
        }
        process(entry);
        return size;
      }
      function initReaders(entry, onend, onerror) {
        var index = 0;
        function next() {
          index++;
          if (index < entry.children.length)
            process(entry.children[index]);
          else
            onend();
        }
        function process(child) {
          if (child.directory)
            initReaders(child, next, onerror);
          else {
            child.reader = new child.Reader(child.data, onerror);
            child.reader.init(function() {
              child.uncompressedSize = child.reader.size;
              next();
            });
          }
        }
        if (entry.children.length)
          process(entry.children[index]);
        else
          onend();
      }
      function detach(entry) {
        var children = entry.parent.children;
        children.forEach(function(child, index) {
          if (child.id == entry.id)
            children.splice(index, 1);
        });
      }
      function exportZip(zipWriter, entry, onend, onprogress, totalSize) {
        var currentIndex = 0;
        function process(zipWriter, entry, onend, onprogress, totalSize) {
          var childIndex = 0;
          function exportChild() {
            var child = entry.children[childIndex];
            if (child)
              zipWriter.add(child.getFullname(), child.reader, function() {
                currentIndex += child.uncompressedSize || 0;
                process(zipWriter, child, function() {
                  childIndex++;
                  exportChild();
                }, onprogress, totalSize);
              }, function(index) {
                if (onprogress)
                  onprogress(currentIndex + index, totalSize);
              }, {
                directory: child.directory,
                version: child.zipVersion
              });
            else
              onend();
          }
          exportChild();
        }
        process(zipWriter, entry, onend, onprogress, totalSize);
      }
      function addFileEntry(zipEntry, fileEntry, onend, onerror) {
        function getChildren(fileEntry, callback) {
          if (fileEntry.isDirectory)
            fileEntry.createReader().readEntries(callback);
          if (fileEntry.isFile)
            callback([]);
        }
        function process(zipEntry, fileEntry, onend) {
          getChildren(fileEntry, function(children) {
            var childIndex = 0;
            function addChild(child) {
              function nextChild(childFileEntry) {
                process(childFileEntry, child, function() {
                  childIndex++;
                  processChild();
                });
              }
              if (child.isDirectory)
                nextChild(zipEntry.addDirectory(child.name));
              if (child.isFile)
                child.file(function(file) {
                  var childZipEntry = zipEntry.addBlob(child.name, file);
                  childZipEntry.uncompressedSize = file.size;
                  nextChild(childZipEntry);
                }, onerror);
            }
            function processChild() {
              var child = children[childIndex];
              if (child)
                addChild(child);
              else
                onend();
            }
            processChild();
          });
        }
        if (fileEntry.isDirectory)
          process(zipEntry, fileEntry, onend);
        else
          fileEntry.file(function(file) {
            zipEntry.addBlob(fileEntry.name, file);
            onend();
          }, onerror);
      }
      function getFileEntry(fileEntry, entry, onend, onprogress, onerror, totalSize, checkCrc32) {
        var currentIndex = 0;
        function process(fileEntry, entry, onend, onprogress, onerror, totalSize) {
          var childIndex = 0;
          function addChild(child) {
            function nextChild(childFileEntry) {
              currentIndex += child.uncompressedSize || 0;
              process(childFileEntry, child, function() {
                childIndex++;
                processChild();
              }, onprogress, onerror, totalSize);
            }
            if (child.directory)
              fileEntry.getDirectory(child.name, {create: true}, nextChild, onerror);
            else
              fileEntry.getFile(child.name, {create: true}, function(file) {
                child.getData(new zip.FileWriter(file, zip.getMimeType(child.name)), nextChild, function(index) {
                  if (onprogress)
                    onprogress(currentIndex + index, totalSize);
                }, checkCrc32);
              }, onerror);
          }
          function processChild() {
            var child = entry.children[childIndex];
            if (child)
              addChild(child);
            else
              onend();
          }
          processChild();
        }
        if (entry.directory)
          process(fileEntry, entry, onend, onprogress, onerror, totalSize);
        else
          entry.getData(new zip.FileWriter(fileEntry, zip.getMimeType(entry.name)), onend, onprogress, checkCrc32);
      }
      function resetFS(fs) {
        fs.entries = [];
        fs.root = new ZipDirectoryEntry(fs);
      }
      function bufferedCopy(reader, writer, onend, onprogress, onerror) {
        var chunkIndex = 0;
        function stepCopy() {
          var index = chunkIndex * CHUNK_SIZE;
          if (onprogress)
            onprogress(index, reader.size);
          if (index < reader.size)
            reader.readUint8Array(index, Math.min(CHUNK_SIZE, reader.size - index), function(array) {
              writer.writeUint8Array(new Uint8Array(array), function() {
                chunkIndex++;
                stepCopy();
              });
            }, onerror);
          else
            writer.getData(onend);
        }
        stepCopy();
      }
      function addChild(parent, name, params, directory) {
        if (parent.directory)
          return directory ? new ZipDirectoryEntry(parent.fs, name, params, parent) : new ZipFileEntry(parent.fs, name, params, parent);
        else
          throw "Parent entry is not a directory.";
      }
      function ZipEntry() {}
      ZipEntry.prototype = {
        init: function(fs, name, params, parent) {
          var that = this;
          if (fs.root && parent && parent.getChildByName(name))
            throw "Entry filename already exists.";
          if (!params)
            params = {};
          that.fs = fs;
          that.name = name;
          that.id = fs.entries.length;
          that.parent = parent;
          that.children = [];
          that.zipVersion = params.zipVersion || 0x14;
          that.uncompressedSize = 0;
          fs.entries.push(that);
          if (parent)
            that.parent.children.push(that);
        },
        getFileEntry: function(fileEntry, onend, onprogress, onerror, checkCrc32) {
          var that = this;
          initReaders(that, function() {
            getFileEntry(fileEntry, that, onend, onprogress, onerror, getTotalSize(that), checkCrc32);
          }, onerror);
        },
        moveTo: function(target) {
          var that = this;
          if (target.directory) {
            if (!target.isDescendantOf(that)) {
              if (that != target) {
                if (target.getChildByName(that.name))
                  throw "Entry filename already exists.";
                detach(that);
                that.parent = target;
                target.children.push(that);
              }
            } else
              throw "Entry is a ancestor of target entry.";
          } else
            throw "Target entry is not a directory.";
        },
        getFullname: function() {
          var that = this,
              fullname = that.name,
              entry = that.parent;
          while (entry) {
            fullname = (entry.name ? entry.name + "/" : "") + fullname;
            entry = entry.parent;
          }
          return fullname;
        },
        isDescendantOf: function(ancestor) {
          var entry = this.parent;
          while (entry && entry.id != ancestor.id)
            entry = entry.parent;
          return !!entry;
        }
      };
      ZipEntry.prototype.constructor = ZipEntry;
      var ZipFileEntryProto;
      function ZipFileEntry(fs, name, params, parent) {
        var that = this;
        ZipEntry.prototype.init.call(that, fs, name, params, parent);
        that.Reader = params.Reader;
        that.Writer = params.Writer;
        that.data = params.data;
        if (params.getData) {
          that.getData = params.getData;
        }
      }
      ZipFileEntry.prototype = ZipFileEntryProto = new ZipEntry();
      ZipFileEntryProto.constructor = ZipFileEntry;
      ZipFileEntryProto.getData = function(writer, onend, onprogress, onerror) {
        var that = this;
        if (!writer || (writer.constructor == that.Writer && that.data))
          onend(that.data);
        else {
          if (!that.reader)
            that.reader = new that.Reader(that.data, onerror);
          that.reader.init(function() {
            writer.init(function() {
              bufferedCopy(that.reader, writer, onend, onprogress, onerror);
            }, onerror);
          });
        }
      };
      ZipFileEntryProto.getText = function(onend, onprogress, checkCrc32, encoding) {
        this.getData(new TextWriter(encoding), onend, onprogress, checkCrc32);
      };
      ZipFileEntryProto.getBlob = function(mimeType, onend, onprogress, checkCrc32) {
        this.getData(new BlobWriter(mimeType), onend, onprogress, checkCrc32);
      };
      ZipFileEntryProto.getData64URI = function(mimeType, onend, onprogress, checkCrc32) {
        this.getData(new Data64URIWriter(mimeType), onend, onprogress, checkCrc32);
      };
      var ZipDirectoryEntryProto;
      function ZipDirectoryEntry(fs, name, params, parent) {
        var that = this;
        ZipEntry.prototype.init.call(that, fs, name, params, parent);
        that.directory = true;
      }
      ZipDirectoryEntry.prototype = ZipDirectoryEntryProto = new ZipEntry();
      ZipDirectoryEntryProto.constructor = ZipDirectoryEntry;
      ZipDirectoryEntryProto.addDirectory = function(name) {
        return addChild(this, name, null, true);
      };
      ZipDirectoryEntryProto.addText = function(name, text) {
        return addChild(this, name, {
          data: text,
          Reader: TextReader,
          Writer: TextWriter
        });
      };
      ZipDirectoryEntryProto.addBlob = function(name, blob) {
        return addChild(this, name, {
          data: blob,
          Reader: BlobReader,
          Writer: BlobWriter
        });
      };
      ZipDirectoryEntryProto.addData64URI = function(name, dataURI) {
        return addChild(this, name, {
          data: dataURI,
          Reader: Data64URIReader,
          Writer: Data64URIWriter
        });
      };
      ZipDirectoryEntryProto.addFileEntry = function(fileEntry, onend, onerror) {
        addFileEntry(this, fileEntry, onend, onerror);
      };
      ZipDirectoryEntryProto.addData = function(name, params) {
        return addChild(this, name, params);
      };
      ZipDirectoryEntryProto.importBlob = function(blob, onend, onerror) {
        this.importZip(new BlobReader(blob), onend, onerror);
      };
      ZipDirectoryEntryProto.importText = function(text, onend, onerror) {
        this.importZip(new TextReader(text), onend, onerror);
      };
      ZipDirectoryEntryProto.importData64URI = function(dataURI, onend, onerror) {
        this.importZip(new Data64URIReader(dataURI), onend, onerror);
      };
      ZipDirectoryEntryProto.exportBlob = function(onend, onprogress, onerror) {
        this.exportZip(new BlobWriter("application/zip"), onend, onprogress, onerror);
      };
      ZipDirectoryEntryProto.exportText = function(onend, onprogress, onerror) {
        this.exportZip(new TextWriter(), onend, onprogress, onerror);
      };
      ZipDirectoryEntryProto.exportFileEntry = function(fileEntry, onend, onprogress, onerror) {
        this.exportZip(new zip.FileWriter(fileEntry, "application/zip"), onend, onprogress, onerror);
      };
      ZipDirectoryEntryProto.exportData64URI = function(onend, onprogress, onerror) {
        this.exportZip(new Data64URIWriter("application/zip"), onend, onprogress, onerror);
      };
      ZipDirectoryEntryProto.importZip = function(reader, onend, onerror) {
        var that = this;
        createReader(reader, function(zipReader) {
          zipReader.getEntries(function(entries) {
            entries.forEach(function(entry) {
              var parent = that,
                  path = entry.filename.split("/"),
                  name = path.pop();
              path.forEach(function(pathPart) {
                parent = parent.getChildByName(pathPart) || new ZipDirectoryEntry(that.fs, pathPart, null, parent);
              });
              if (!entry.directory)
                addChild(parent, name, {
                  data: entry,
                  Reader: ZipBlobReader
                });
            });
            onend();
          });
        }, onerror);
      };
      ZipDirectoryEntryProto.exportZip = function(writer, onend, onprogress, onerror) {
        var that = this;
        initReaders(that, function() {
          createWriter(writer, function(zipWriter) {
            exportZip(zipWriter, that, function() {
              zipWriter.close(onend);
            }, onprogress, getTotalSize(that));
          }, onerror);
        }, onerror);
      };
      ZipDirectoryEntryProto.getChildByName = function(name) {
        var childIndex,
            child,
            that = this;
        for (childIndex = 0; childIndex < that.children.length; childIndex++) {
          child = that.children[childIndex];
          if (child.name == name)
            return child;
        }
      };
      function FS() {
        resetFS(this);
      }
      FS.prototype = {
        remove: function(entry) {
          detach(entry);
          this.entries[entry.id] = null;
        },
        find: function(fullname) {
          var index,
              path = fullname.split("/"),
              node = this.root;
          for (index = 0; node && index < path.length; index++)
            node = node.getChildByName(path[index]);
          return node;
        },
        getById: function(id) {
          return this.entries[id];
        },
        importBlob: function(blob, onend, onerror) {
          resetFS(this);
          this.root.importBlob(blob, onend, onerror);
        },
        importText: function(text, onend, onerror) {
          resetFS(this);
          this.root.importText(text, onend, onerror);
        },
        importData64URI: function(dataURI, onend, onerror) {
          resetFS(this);
          this.root.importData64URI(dataURI, onend, onerror);
        },
        exportBlob: function(onend, onprogress, onerror) {
          this.root.exportBlob(onend, onprogress, onerror);
        },
        exportText: function(onend, onprogress, onerror) {
          this.root.exportText(onend, onprogress, onerror);
        },
        exportFileEntry: function(fileEntry, onend, onprogress, onerror) {
          this.root.exportFileEntry(fileEntry, onend, onprogress, onerror);
        },
        exportData64URI: function(onend, onprogress, onerror) {
          this.root.exportData64URI(onend, onprogress, onerror);
        }
      };
      zip.fs = {
        FS: FS,
        ZipDirectoryEntry: ZipDirectoryEntry,
        ZipFileEntry: ZipFileEntry
      };
      zip.getMimeType = function() {
        return "application/octet-stream";
      };
    })();
  })();
  return _retrieveGlobal();
});

System.registerDynamic("npm:zip-js@0.0.2.js", ["npm:zip-js@0.0.2/WebContent/zip-fs.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:zip-js@0.0.2/WebContent/zip-fs.js');
  return module.exports;
});

System.registerDynamic("npm:kefir@3.2.2/dist/kefir.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (factory((global.Kefir = global.Kefir || {})));
  }(this, function(exports) {
    'use strict';
    var __commonjs_global = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this;
    function __commonjs(fn, module) {
      return module = {exports: {}}, fn(module, module.exports, __commonjs_global), module.exports;
    }
    function createObj(proto) {
      var F = function() {};
      F.prototype = proto;
      return new F();
    }
    function extend(target) {
      var length = arguments.length,
          i = void 0,
          prop = void 0;
      for (i = 1; i < length; i++) {
        for (prop in arguments[i]) {
          target[prop] = arguments[i][prop];
        }
      }
      return target;
    }
    function inherit(Child, Parent) {
      var length = arguments.length,
          i = void 0;
      Child.prototype = createObj(Parent.prototype);
      Child.prototype.constructor = Child;
      for (i = 2; i < length; i++) {
        extend(Child.prototype, arguments[i]);
      }
      return Child;
    }
    var NOTHING = ['<nothing>'];
    var END = 'end';
    var VALUE = 'value';
    var ERROR = 'error';
    var ANY = 'any';
    function concat(a, b) {
      var result = void 0,
          length = void 0,
          i = void 0,
          j = void 0;
      if (a.length === 0) {
        return b;
      }
      if (b.length === 0) {
        return a;
      }
      j = 0;
      result = new Array(a.length + b.length);
      length = a.length;
      for (i = 0; i < length; i++, j++) {
        result[j] = a[i];
      }
      length = b.length;
      for (i = 0; i < length; i++, j++) {
        result[j] = b[i];
      }
      return result;
    }
    function find(arr, value) {
      var length = arr.length,
          i = void 0;
      for (i = 0; i < length; i++) {
        if (arr[i] === value) {
          return i;
        }
      }
      return -1;
    }
    function findByPred(arr, pred) {
      var length = arr.length,
          i = void 0;
      for (i = 0; i < length; i++) {
        if (pred(arr[i])) {
          return i;
        }
      }
      return -1;
    }
    function cloneArray(input) {
      var length = input.length,
          result = new Array(length),
          i = void 0;
      for (i = 0; i < length; i++) {
        result[i] = input[i];
      }
      return result;
    }
    function remove(input, index) {
      var length = input.length,
          result = void 0,
          i = void 0,
          j = void 0;
      if (index >= 0 && index < length) {
        if (length === 1) {
          return [];
        } else {
          result = new Array(length - 1);
          for (i = 0, j = 0; i < length; i++) {
            if (i !== index) {
              result[j] = input[i];
              j++;
            }
          }
          return result;
        }
      } else {
        return input;
      }
    }
    function map(input, fn) {
      var length = input.length,
          result = new Array(length),
          i = void 0;
      for (i = 0; i < length; i++) {
        result[i] = fn(input[i]);
      }
      return result;
    }
    function forEach(arr, fn) {
      var length = arr.length,
          i = void 0;
      for (i = 0; i < length; i++) {
        fn(arr[i]);
      }
    }
    function fillArray(arr, value) {
      var length = arr.length,
          i = void 0;
      for (i = 0; i < length; i++) {
        arr[i] = value;
      }
    }
    function contains(arr, value) {
      return find(arr, value) !== -1;
    }
    function slide(cur, next, max) {
      var length = Math.min(max, cur.length + 1),
          offset = cur.length - length + 1,
          result = new Array(length),
          i = void 0;
      for (i = offset; i < length; i++) {
        result[i - offset] = cur[i];
      }
      result[length - 1] = next;
      return result;
    }
    function callSubscriber(type, fn, event) {
      if (type === ANY) {
        fn(event);
      } else if (type === event.type) {
        if (type === VALUE || type === ERROR) {
          fn(event.value);
        } else {
          fn();
        }
      }
    }
    function Dispatcher() {
      this._items = [];
      this._inLoop = 0;
      this._removedItems = null;
    }
    extend(Dispatcher.prototype, {
      add: function(type, fn) {
        this._items = concat(this._items, [{
          type: type,
          fn: fn
        }]);
        return this._items.length;
      },
      remove: function(type, fn) {
        var index = findByPred(this._items, function(x) {
          return x.type === type && x.fn === fn;
        });
        if (this._inLoop !== 0 && index !== -1) {
          if (this._removedItems === null) {
            this._removedItems = [];
          }
          this._removedItems.push(this._items[index]);
        }
        this._items = remove(this._items, index);
        return this._items.length;
      },
      dispatch: function(event) {
        this._inLoop++;
        for (var i = 0,
            items = this._items; i < items.length; i++) {
          if (this._items === null) {
            break;
          }
          if (this._removedItems !== null && contains(this._removedItems, items[i])) {
            continue;
          }
          callSubscriber(items[i].type, items[i].fn, event);
        }
        this._inLoop--;
        if (this._inLoop === 0) {
          this._removedItems = null;
        }
      },
      cleanup: function() {
        this._items = null;
      }
    });
    function Observable() {
      this._dispatcher = new Dispatcher();
      this._active = false;
      this._alive = true;
      this._activating = false;
      this._logHandlers = null;
    }
    extend(Observable.prototype, {
      _name: 'observable',
      _onActivation: function() {},
      _onDeactivation: function() {},
      _setActive: function(active) {
        if (this._active !== active) {
          this._active = active;
          if (active) {
            this._activating = true;
            this._onActivation();
            this._activating = false;
          } else {
            this._onDeactivation();
          }
        }
      },
      _clear: function() {
        this._setActive(false);
        this._dispatcher.cleanup();
        this._dispatcher = null;
        this._logHandlers = null;
      },
      _emit: function(type, x) {
        switch (type) {
          case VALUE:
            return this._emitValue(x);
          case ERROR:
            return this._emitError(x);
          case END:
            return this._emitEnd();
        }
      },
      _emitValue: function(value) {
        if (this._alive) {
          this._dispatcher.dispatch({
            type: VALUE,
            value: value
          });
        }
      },
      _emitError: function(value) {
        if (this._alive) {
          this._dispatcher.dispatch({
            type: ERROR,
            value: value
          });
        }
      },
      _emitEnd: function() {
        if (this._alive) {
          this._alive = false;
          this._dispatcher.dispatch({type: END});
          this._clear();
        }
      },
      _on: function(type, fn) {
        if (this._alive) {
          this._dispatcher.add(type, fn);
          this._setActive(true);
        } else {
          callSubscriber(type, fn, {type: END});
        }
        return this;
      },
      _off: function(type, fn) {
        if (this._alive) {
          var count = this._dispatcher.remove(type, fn);
          if (count === 0) {
            this._setActive(false);
          }
        }
        return this;
      },
      onValue: function(fn) {
        return this._on(VALUE, fn);
      },
      onError: function(fn) {
        return this._on(ERROR, fn);
      },
      onEnd: function(fn) {
        return this._on(END, fn);
      },
      onAny: function(fn) {
        return this._on(ANY, fn);
      },
      offValue: function(fn) {
        return this._off(VALUE, fn);
      },
      offError: function(fn) {
        return this._off(ERROR, fn);
      },
      offEnd: function(fn) {
        return this._off(END, fn);
      },
      offAny: function(fn) {
        return this._off(ANY, fn);
      },
      _ofSameType: function(A, B) {
        return A.prototype.getType() === this.getType() ? A : B;
      },
      setName: function(sourceObs, selfName) {
        this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;
        return this;
      },
      log: function() {
        var name = arguments.length <= 0 || arguments[0] === undefined ? this.toString() : arguments[0];
        var isCurrent = void 0;
        var handler = function(event) {
          var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';
          if (event.type === END) {
            console.log(name, type);
          } else {
            console.log(name, type, event.value);
          }
        };
        if (this._alive) {
          if (!this._logHandlers) {
            this._logHandlers = [];
          }
          this._logHandlers.push({
            name: name,
            handler: handler
          });
        }
        isCurrent = true;
        this.onAny(handler);
        isCurrent = false;
        return this;
      },
      offLog: function() {
        var name = arguments.length <= 0 || arguments[0] === undefined ? this.toString() : arguments[0];
        if (this._logHandlers) {
          var handlerIndex = findByPred(this._logHandlers, function(obj) {
            return obj.name === name;
          });
          if (handlerIndex !== -1) {
            this.offAny(this._logHandlers[handlerIndex].handler);
            this._logHandlers.splice(handlerIndex, 1);
          }
        }
        return this;
      }
    });
    Observable.prototype.toString = function() {
      return '[' + this._name + ']';
    };
    function Stream() {
      Observable.call(this);
    }
    inherit(Stream, Observable, {
      _name: 'stream',
      getType: function() {
        return 'stream';
      }
    });
    function Property() {
      Observable.call(this);
      this._currentEvent = null;
    }
    inherit(Property, Observable, {
      _name: 'property',
      _emitValue: function(value) {
        if (this._alive) {
          this._currentEvent = {
            type: VALUE,
            value: value
          };
          if (!this._activating) {
            this._dispatcher.dispatch({
              type: VALUE,
              value: value
            });
          }
        }
      },
      _emitError: function(value) {
        if (this._alive) {
          this._currentEvent = {
            type: ERROR,
            value: value
          };
          if (!this._activating) {
            this._dispatcher.dispatch({
              type: ERROR,
              value: value
            });
          }
        }
      },
      _emitEnd: function() {
        if (this._alive) {
          this._alive = false;
          if (!this._activating) {
            this._dispatcher.dispatch({type: END});
          }
          this._clear();
        }
      },
      _on: function(type, fn) {
        if (this._alive) {
          this._dispatcher.add(type, fn);
          this._setActive(true);
        }
        if (this._currentEvent !== null) {
          callSubscriber(type, fn, this._currentEvent);
        }
        if (!this._alive) {
          callSubscriber(type, fn, {type: END});
        }
        return this;
      },
      getType: function() {
        return 'property';
      }
    });
    var neverS = new Stream();
    neverS._emitEnd();
    neverS._name = 'never';
    function never() {
      return neverS;
    }
    function timeBased(mixin) {
      function AnonymousStream(wait, options) {
        var _this = this;
        Stream.call(this);
        this._wait = wait;
        this._intervalId = null;
        this._$onTick = function() {
          return _this._onTick();
        };
        this._init(options);
      }
      inherit(AnonymousStream, Stream, {
        _init: function() {},
        _free: function() {},
        _onTick: function() {},
        _onActivation: function() {
          this._intervalId = setInterval(this._$onTick, this._wait);
        },
        _onDeactivation: function() {
          if (this._intervalId !== null) {
            clearInterval(this._intervalId);
            this._intervalId = null;
          }
        },
        _clear: function() {
          Stream.prototype._clear.call(this);
          this._$onTick = null;
          this._free();
        }
      }, mixin);
      return AnonymousStream;
    }
    var S = timeBased({
      _name: 'later',
      _init: function(_ref) {
        var x = _ref.x;
        this._x = x;
      },
      _free: function() {
        this._x = null;
      },
      _onTick: function() {
        this._emitValue(this._x);
        this._emitEnd();
      }
    });
    function later(wait, x) {
      return new S(wait, {x: x});
    }
    var S$1 = timeBased({
      _name: 'interval',
      _init: function(_ref) {
        var x = _ref.x;
        this._x = x;
      },
      _free: function() {
        this._x = null;
      },
      _onTick: function() {
        this._emitValue(this._x);
      }
    });
    function interval(wait, x) {
      return new S$1(wait, {x: x});
    }
    var S$2 = timeBased({
      _name: 'sequentially',
      _init: function(_ref) {
        var xs = _ref.xs;
        this._xs = cloneArray(xs);
      },
      _free: function() {
        this._xs = null;
      },
      _onTick: function() {
        if (this._xs.length === 1) {
          this._emitValue(this._xs[0]);
          this._emitEnd();
        } else {
          this._emitValue(this._xs.shift());
        }
      }
    });
    function sequentially(wait, xs) {
      return xs.length === 0 ? never() : new S$2(wait, {xs: xs});
    }
    var S$3 = timeBased({
      _name: 'fromPoll',
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
      },
      _free: function() {
        this._fn = null;
      },
      _onTick: function() {
        var fn = this._fn;
        this._emitValue(fn());
      }
    });
    function fromPoll(wait, fn) {
      return new S$3(wait, {fn: fn});
    }
    function emitter(obs) {
      function value(x) {
        obs._emitValue(x);
        return obs._active;
      }
      function error(x) {
        obs._emitError(x);
        return obs._active;
      }
      function end() {
        obs._emitEnd();
        return obs._active;
      }
      function event(e) {
        obs._emit(e.type, e.value);
        return obs._active;
      }
      return {
        value: value,
        error: error,
        end: end,
        event: event,
        emit: value,
        emitEvent: event
      };
    }
    var S$4 = timeBased({
      _name: 'withInterval',
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
        this._emitter = emitter(this);
      },
      _free: function() {
        this._fn = null;
        this._emitter = null;
      },
      _onTick: function() {
        var fn = this._fn;
        fn(this._emitter);
      }
    });
    function withInterval(wait, fn) {
      return new S$4(wait, {fn: fn});
    }
    function S$5(fn) {
      Stream.call(this);
      this._fn = fn;
      this._unsubscribe = null;
    }
    inherit(S$5, Stream, {
      _name: 'stream',
      _onActivation: function() {
        var fn = this._fn;
        var unsubscribe = fn(emitter(this));
        this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;
        if (!this._active) {
          this._callUnsubscribe();
        }
      },
      _callUnsubscribe: function() {
        if (this._unsubscribe !== null) {
          this._unsubscribe();
          this._unsubscribe = null;
        }
      },
      _onDeactivation: function() {
        this._callUnsubscribe();
      },
      _clear: function() {
        Stream.prototype._clear.call(this);
        this._fn = null;
      }
    });
    function stream(fn) {
      return new S$5(fn);
    }
    function fromCallback(callbackConsumer) {
      var called = false;
      return stream(function(emitter) {
        if (!called) {
          callbackConsumer(function(x) {
            emitter.emit(x);
            emitter.end();
          });
          called = true;
        }
      }).setName('fromCallback');
    }
    function fromNodeCallback(callbackConsumer) {
      var called = false;
      return stream(function(emitter) {
        if (!called) {
          callbackConsumer(function(error, x) {
            if (error) {
              emitter.error(error);
            } else {
              emitter.emit(x);
            }
            emitter.end();
          });
          called = true;
        }
      }).setName('fromNodeCallback');
    }
    function spread(fn, length) {
      switch (length) {
        case 0:
          return function() {
            return fn();
          };
        case 1:
          return function(a) {
            return fn(a[0]);
          };
        case 2:
          return function(a) {
            return fn(a[0], a[1]);
          };
        case 3:
          return function(a) {
            return fn(a[0], a[1], a[2]);
          };
        case 4:
          return function(a) {
            return fn(a[0], a[1], a[2], a[3]);
          };
        default:
          return function(a) {
            return fn.apply(null, a);
          };
      }
    }
    function apply(fn, c, a) {
      var aLength = a ? a.length : 0;
      if (c == null) {
        switch (aLength) {
          case 0:
            return fn();
          case 1:
            return fn(a[0]);
          case 2:
            return fn(a[0], a[1]);
          case 3:
            return fn(a[0], a[1], a[2]);
          case 4:
            return fn(a[0], a[1], a[2], a[3]);
          default:
            return fn.apply(null, a);
        }
      } else {
        switch (aLength) {
          case 0:
            return fn.call(c);
          default:
            return fn.apply(c, a);
        }
      }
    }
    function fromSubUnsub(sub, unsub, transformer) {
      return stream(function(emitter) {
        var handler = transformer ? function() {
          emitter.emit(apply(transformer, this, arguments));
        } : function(x) {
          emitter.emit(x);
        };
        sub(handler);
        return function() {
          return unsub(handler);
        };
      }).setName('fromSubUnsub');
    }
    var pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];
    function fromEvents(target, eventName, transformer) {
      var sub = void 0,
          unsub = void 0;
      for (var i = 0; i < pairs.length; i++) {
        if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {
          sub = pairs[i][0];
          unsub = pairs[i][1];
          break;
        }
      }
      if (sub === undefined) {
        throw new Error('target don\'t support any of ' + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');
      }
      return fromSubUnsub(function(handler) {
        return target[sub](eventName, handler);
      }, function(handler) {
        return target[unsub](eventName, handler);
      }, transformer).setName('fromEvents');
    }
    function P(value) {
      this._currentEvent = {
        type: 'value',
        value: value,
        current: true
      };
    }
    inherit(P, Property, {
      _name: 'constant',
      _active: false,
      _activating: false,
      _alive: false,
      _dispatcher: null,
      _logHandlers: null
    });
    function constant(x) {
      return new P(x);
    }
    function P$1(value) {
      this._currentEvent = {
        type: 'error',
        value: value,
        current: true
      };
    }
    inherit(P$1, Property, {
      _name: 'constantError',
      _active: false,
      _activating: false,
      _alive: false,
      _dispatcher: null,
      _logHandlers: null
    });
    function constantError(x) {
      return new P$1(x);
    }
    function createConstructor(BaseClass, name) {
      return function AnonymousObservable(source, options) {
        var _this = this;
        BaseClass.call(this);
        this._source = source;
        this._name = source._name + '.' + name;
        this._init(options);
        this._$handleAny = function(event) {
          return _this._handleAny(event);
        };
      };
    }
    function createClassMethods(BaseClass) {
      return {
        _init: function() {},
        _free: function() {},
        _handleValue: function(x) {
          this._emitValue(x);
        },
        _handleError: function(x) {
          this._emitError(x);
        },
        _handleEnd: function() {
          this._emitEnd();
        },
        _handleAny: function(event) {
          switch (event.type) {
            case VALUE:
              return this._handleValue(event.value);
            case ERROR:
              return this._handleError(event.value);
            case END:
              return this._handleEnd();
          }
        },
        _onActivation: function() {
          this._source.onAny(this._$handleAny);
        },
        _onDeactivation: function() {
          this._source.offAny(this._$handleAny);
        },
        _clear: function() {
          BaseClass.prototype._clear.call(this);
          this._source = null;
          this._$handleAny = null;
          this._free();
        }
      };
    }
    function createStream(name, mixin) {
      var S = createConstructor(Stream, name);
      inherit(S, Stream, createClassMethods(Stream), mixin);
      return S;
    }
    function createProperty(name, mixin) {
      var P = createConstructor(Property, name);
      inherit(P, Property, createClassMethods(Property), mixin);
      return P;
    }
    var P$2 = createProperty('toProperty', {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._getInitialCurrent = fn;
      },
      _onActivation: function() {
        if (this._getInitialCurrent !== null) {
          var getInitial = this._getInitialCurrent;
          this._emitValue(getInitial());
        }
        this._source.onAny(this._$handleAny);
      }
    });
    function toProperty(obs) {
      var fn = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
      if (fn !== null && typeof fn !== 'function') {
        throw new Error('You should call toProperty() with a function or no arguments.');
      }
      return new P$2(obs, {fn: fn});
    }
    var S$6 = createStream('changes', {
      _handleValue: function(x) {
        if (!this._activating) {
          this._emitValue(x);
        }
      },
      _handleError: function(x) {
        if (!this._activating) {
          this._emitError(x);
        }
      }
    });
    function changes(obs) {
      return new S$6(obs);
    }
    function fromPromise(promise) {
      var called = false;
      var result = stream(function(emitter) {
        if (!called) {
          var onValue = function(x) {
            emitter.emit(x);
            emitter.end();
          };
          var onError = function(x) {
            emitter.error(x);
            emitter.end();
          };
          var _promise = promise.then(onValue, onError);
          if (_promise && typeof _promise.done === 'function') {
            _promise.done();
          }
          called = true;
        }
      });
      return toProperty(result, null).setName('fromPromise');
    }
    function getGlodalPromise() {
      if (typeof Promise === 'function') {
        return Promise;
      } else {
        throw new Error('There isn\'t default Promise, use shim or parameter');
      }
    }
    function toPromise(obs) {
      var Promise = arguments.length <= 1 || arguments[1] === undefined ? getGlodalPromise() : arguments[1];
      var last = null;
      return new Promise(function(resolve, reject) {
        obs.onAny(function(event) {
          if (event.type === END && last !== null) {
            (last.type === VALUE ? resolve : reject)(last.value);
            last = null;
          } else {
            last = event;
          }
        });
      });
    }
    var ponyfill = __commonjs(function(module) {
      'use strict';
      module.exports = function symbolObservablePonyfill(root) {
        var result;
        var Symbol = root.Symbol;
        if (typeof Symbol === 'function') {
          if (Symbol.observable) {
            result = Symbol.observable;
          } else {
            result = Symbol('observable');
            Symbol.observable = result;
          }
        } else {
          result = '@@observable';
        }
        return result;
      };
    });
    var require$$0 = (ponyfill && typeof ponyfill === 'object' && 'default' in ponyfill ? ponyfill['default'] : ponyfill);
    var index = __commonjs(function(module, exports, global) {
      'use strict';
      module.exports = require$$0(global || window || __commonjs_global);
    });
    var $$observable = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);
    function fromESObservable(_observable) {
      var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;
      return stream(function(emitter) {
        var unsub = observable.subscribe({
          error: function(error) {
            emitter.error(error);
            emitter.end();
          },
          next: function(value) {
            emitter.emit(value);
          },
          complete: function() {
            emitter.end();
          }
        });
        if (unsub.unsubscribe) {
          return function() {
            unsub.unsubscribe();
          };
        } else {
          return unsub;
        }
      }).setName('fromESObservable');
    }
    function ESObservable(observable) {
      this._observable = observable.takeErrors(1);
    }
    extend(ESObservable.prototype, {subscribe: function(observer) {
        var _this = this;
        var fn = function(event) {
          if (event.type === VALUE && observer.next) {
            observer.next(event.value);
          } else if (event.type === ERROR && observer.error) {
            observer.error(event.value);
          } else if (event.type === END && observer.complete) {
            observer.complete(event.value);
          }
        };
        this._observable.onAny(fn);
        return function() {
          return _this._observable.offAny(fn);
        };
      }});
    function toESObservable() {
      return new ESObservable(this);
    }
    var mixin = {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
      },
      _free: function() {
        this._fn = null;
      },
      _handleValue: function(x) {
        var fn = this._fn;
        this._emitValue(fn(x));
      }
    };
    var S$7 = createStream('map', mixin);
    var P$3 = createProperty('map', mixin);
    var id = function(x) {
      return x;
    };
    function map$1(obs) {
      var fn = arguments.length <= 1 || arguments[1] === undefined ? id : arguments[1];
      return new (obs._ofSameType(S$7, P$3))(obs, {fn: fn});
    }
    var mixin$1 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
      },
      _free: function() {
        this._fn = null;
      },
      _handleValue: function(x) {
        var fn = this._fn;
        if (fn(x)) {
          this._emitValue(x);
        }
      }
    };
    var S$8 = createStream('filter', mixin$1);
    var P$4 = createProperty('filter', mixin$1);
    var id$1 = function(x) {
      return x;
    };
    function filter(obs) {
      var fn = arguments.length <= 1 || arguments[1] === undefined ? id$1 : arguments[1];
      return new (obs._ofSameType(S$8, P$4))(obs, {fn: fn});
    }
    var mixin$2 = {
      _init: function(_ref) {
        var n = _ref.n;
        this._n = n;
        if (n <= 0) {
          this._emitEnd();
        }
      },
      _handleValue: function(x) {
        this._n--;
        this._emitValue(x);
        if (this._n === 0) {
          this._emitEnd();
        }
      }
    };
    var S$9 = createStream('take', mixin$2);
    var P$5 = createProperty('take', mixin$2);
    function take(obs, n) {
      return new (obs._ofSameType(S$9, P$5))(obs, {n: n});
    }
    var mixin$3 = {
      _init: function(_ref) {
        var n = _ref.n;
        this._n = n;
        if (n <= 0) {
          this._emitEnd();
        }
      },
      _handleError: function(x) {
        this._n--;
        this._emitError(x);
        if (this._n === 0) {
          this._emitEnd();
        }
      }
    };
    var S$10 = createStream('takeErrors', mixin$3);
    var P$6 = createProperty('takeErrors', mixin$3);
    function takeErrors(obs, n) {
      return new (obs._ofSameType(S$10, P$6))(obs, {n: n});
    }
    var mixin$4 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
      },
      _free: function() {
        this._fn = null;
      },
      _handleValue: function(x) {
        var fn = this._fn;
        if (fn(x)) {
          this._emitValue(x);
        } else {
          this._emitEnd();
        }
      }
    };
    var S$11 = createStream('takeWhile', mixin$4);
    var P$7 = createProperty('takeWhile', mixin$4);
    var id$2 = function(x) {
      return x;
    };
    function takeWhile(obs) {
      var fn = arguments.length <= 1 || arguments[1] === undefined ? id$2 : arguments[1];
      return new (obs._ofSameType(S$11, P$7))(obs, {fn: fn});
    }
    var mixin$5 = {
      _init: function() {
        this._lastValue = NOTHING;
      },
      _free: function() {
        this._lastValue = null;
      },
      _handleValue: function(x) {
        this._lastValue = x;
      },
      _handleEnd: function() {
        if (this._lastValue !== NOTHING) {
          this._emitValue(this._lastValue);
        }
        this._emitEnd();
      }
    };
    var S$12 = createStream('last', mixin$5);
    var P$8 = createProperty('last', mixin$5);
    function last(obs) {
      return new (obs._ofSameType(S$12, P$8))(obs);
    }
    var mixin$6 = {
      _init: function(_ref) {
        var n = _ref.n;
        this._n = Math.max(0, n);
      },
      _handleValue: function(x) {
        if (this._n === 0) {
          this._emitValue(x);
        } else {
          this._n--;
        }
      }
    };
    var S$13 = createStream('skip', mixin$6);
    var P$9 = createProperty('skip', mixin$6);
    function skip(obs, n) {
      return new (obs._ofSameType(S$13, P$9))(obs, {n: n});
    }
    var mixin$7 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
      },
      _free: function() {
        this._fn = null;
      },
      _handleValue: function(x) {
        var fn = this._fn;
        if (this._fn !== null && !fn(x)) {
          this._fn = null;
        }
        if (this._fn === null) {
          this._emitValue(x);
        }
      }
    };
    var S$14 = createStream('skipWhile', mixin$7);
    var P$10 = createProperty('skipWhile', mixin$7);
    var id$3 = function(x) {
      return x;
    };
    function skipWhile(obs) {
      var fn = arguments.length <= 1 || arguments[1] === undefined ? id$3 : arguments[1];
      return new (obs._ofSameType(S$14, P$10))(obs, {fn: fn});
    }
    var mixin$8 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
        this._prev = NOTHING;
      },
      _free: function() {
        this._fn = null;
        this._prev = null;
      },
      _handleValue: function(x) {
        var fn = this._fn;
        if (this._prev === NOTHING || !fn(this._prev, x)) {
          this._prev = x;
          this._emitValue(x);
        }
      }
    };
    var S$15 = createStream('skipDuplicates', mixin$8);
    var P$11 = createProperty('skipDuplicates', mixin$8);
    var eq = function(a, b) {
      return a === b;
    };
    function skipDuplicates(obs) {
      var fn = arguments.length <= 1 || arguments[1] === undefined ? eq : arguments[1];
      return new (obs._ofSameType(S$15, P$11))(obs, {fn: fn});
    }
    var mixin$9 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        var seed = _ref.seed;
        this._fn = fn;
        this._prev = seed;
      },
      _free: function() {
        this._prev = null;
        this._fn = null;
      },
      _handleValue: function(x) {
        if (this._prev !== NOTHING) {
          var fn = this._fn;
          this._emitValue(fn(this._prev, x));
        }
        this._prev = x;
      }
    };
    var S$16 = createStream('diff', mixin$9);
    var P$12 = createProperty('diff', mixin$9);
    function defaultFn(a, b) {
      return [a, b];
    }
    function diff(obs, fn) {
      var seed = arguments.length <= 2 || arguments[2] === undefined ? NOTHING : arguments[2];
      return new (obs._ofSameType(S$16, P$12))(obs, {
        fn: fn || defaultFn,
        seed: seed
      });
    }
    var P$13 = createProperty('scan', {
      _init: function(_ref) {
        var fn = _ref.fn;
        var seed = _ref.seed;
        this._fn = fn;
        this._seed = seed;
        if (seed !== NOTHING) {
          this._emitValue(seed);
        }
      },
      _free: function() {
        this._fn = null;
        this._seed = null;
      },
      _handleValue: function(x) {
        var fn = this._fn;
        if (this._currentEvent === null || this._currentEvent.type === ERROR) {
          this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));
        } else {
          this._emitValue(fn(this._currentEvent.value, x));
        }
      }
    });
    function scan(obs, fn) {
      var seed = arguments.length <= 2 || arguments[2] === undefined ? NOTHING : arguments[2];
      return new P$13(obs, {
        fn: fn,
        seed: seed
      });
    }
    var mixin$10 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
      },
      _free: function() {
        this._fn = null;
      },
      _handleValue: function(x) {
        var fn = this._fn;
        var xs = fn(x);
        for (var i = 0; i < xs.length; i++) {
          this._emitValue(xs[i]);
        }
      }
    };
    var S$17 = createStream('flatten', mixin$10);
    var id$4 = function(x) {
      return x;
    };
    function flatten(obs) {
      var fn = arguments.length <= 1 || arguments[1] === undefined ? id$4 : arguments[1];
      return new S$17(obs, {fn: fn});
    }
    var END_MARKER = {};
    var mixin$11 = {
      _init: function(_ref) {
        var _this = this;
        var wait = _ref.wait;
        this._wait = Math.max(0, wait);
        this._buff = [];
        this._$shiftBuff = function() {
          var value = _this._buff.shift();
          if (value === END_MARKER) {
            _this._emitEnd();
          } else {
            _this._emitValue(value);
          }
        };
      },
      _free: function() {
        this._buff = null;
        this._$shiftBuff = null;
      },
      _handleValue: function(x) {
        if (this._activating) {
          this._emitValue(x);
        } else {
          this._buff.push(x);
          setTimeout(this._$shiftBuff, this._wait);
        }
      },
      _handleEnd: function() {
        if (this._activating) {
          this._emitEnd();
        } else {
          this._buff.push(END_MARKER);
          setTimeout(this._$shiftBuff, this._wait);
        }
      }
    };
    var S$18 = createStream('delay', mixin$11);
    var P$14 = createProperty('delay', mixin$11);
    function delay(obs, wait) {
      return new (obs._ofSameType(S$18, P$14))(obs, {wait: wait});
    }
    var now = Date.now ? function() {
      return Date.now();
    } : function() {
      return new Date().getTime();
    };
    var mixin$12 = {
      _init: function(_ref) {
        var _this = this;
        var wait = _ref.wait;
        var leading = _ref.leading;
        var trailing = _ref.trailing;
        this._wait = Math.max(0, wait);
        this._leading = leading;
        this._trailing = trailing;
        this._trailingValue = null;
        this._timeoutId = null;
        this._endLater = false;
        this._lastCallTime = 0;
        this._$trailingCall = function() {
          return _this._trailingCall();
        };
      },
      _free: function() {
        this._trailingValue = null;
        this._$trailingCall = null;
      },
      _handleValue: function(x) {
        if (this._activating) {
          this._emitValue(x);
        } else {
          var curTime = now();
          if (this._lastCallTime === 0 && !this._leading) {
            this._lastCallTime = curTime;
          }
          var remaining = this._wait - (curTime - this._lastCallTime);
          if (remaining <= 0) {
            this._cancelTrailing();
            this._lastCallTime = curTime;
            this._emitValue(x);
          } else if (this._trailing) {
            this._cancelTrailing();
            this._trailingValue = x;
            this._timeoutId = setTimeout(this._$trailingCall, remaining);
          }
        }
      },
      _handleEnd: function() {
        if (this._activating) {
          this._emitEnd();
        } else {
          if (this._timeoutId) {
            this._endLater = true;
          } else {
            this._emitEnd();
          }
        }
      },
      _cancelTrailing: function() {
        if (this._timeoutId !== null) {
          clearTimeout(this._timeoutId);
          this._timeoutId = null;
        }
      },
      _trailingCall: function() {
        this._emitValue(this._trailingValue);
        this._timeoutId = null;
        this._trailingValue = null;
        this._lastCallTime = !this._leading ? 0 : now();
        if (this._endLater) {
          this._emitEnd();
        }
      }
    };
    var S$19 = createStream('throttle', mixin$12);
    var P$15 = createProperty('throttle', mixin$12);
    function throttle(obs, wait) {
      var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
      var _ref2$leading = _ref2.leading;
      var leading = _ref2$leading === undefined ? true : _ref2$leading;
      var _ref2$trailing = _ref2.trailing;
      var trailing = _ref2$trailing === undefined ? true : _ref2$trailing;
      return new (obs._ofSameType(S$19, P$15))(obs, {
        wait: wait,
        leading: leading,
        trailing: trailing
      });
    }
    var mixin$13 = {
      _init: function(_ref) {
        var _this = this;
        var wait = _ref.wait;
        var immediate = _ref.immediate;
        this._wait = Math.max(0, wait);
        this._immediate = immediate;
        this._lastAttempt = 0;
        this._timeoutId = null;
        this._laterValue = null;
        this._endLater = false;
        this._$later = function() {
          return _this._later();
        };
      },
      _free: function() {
        this._laterValue = null;
        this._$later = null;
      },
      _handleValue: function(x) {
        if (this._activating) {
          this._emitValue(x);
        } else {
          this._lastAttempt = now();
          if (this._immediate && !this._timeoutId) {
            this._emitValue(x);
          }
          if (!this._timeoutId) {
            this._timeoutId = setTimeout(this._$later, this._wait);
          }
          if (!this._immediate) {
            this._laterValue = x;
          }
        }
      },
      _handleEnd: function() {
        if (this._activating) {
          this._emitEnd();
        } else {
          if (this._timeoutId && !this._immediate) {
            this._endLater = true;
          } else {
            this._emitEnd();
          }
        }
      },
      _later: function() {
        var last = now() - this._lastAttempt;
        if (last < this._wait && last >= 0) {
          this._timeoutId = setTimeout(this._$later, this._wait - last);
        } else {
          this._timeoutId = null;
          if (!this._immediate) {
            this._emitValue(this._laterValue);
            this._laterValue = null;
          }
          if (this._endLater) {
            this._emitEnd();
          }
        }
      }
    };
    var S$20 = createStream('debounce', mixin$13);
    var P$16 = createProperty('debounce', mixin$13);
    function debounce(obs, wait) {
      var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
      var _ref2$immediate = _ref2.immediate;
      var immediate = _ref2$immediate === undefined ? false : _ref2$immediate;
      return new (obs._ofSameType(S$20, P$16))(obs, {
        wait: wait,
        immediate: immediate
      });
    }
    var mixin$14 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
      },
      _free: function() {
        this._fn = null;
      },
      _handleError: function(x) {
        var fn = this._fn;
        this._emitError(fn(x));
      }
    };
    var S$21 = createStream('mapErrors', mixin$14);
    var P$17 = createProperty('mapErrors', mixin$14);
    var id$5 = function(x) {
      return x;
    };
    function mapErrors(obs) {
      var fn = arguments.length <= 1 || arguments[1] === undefined ? id$5 : arguments[1];
      return new (obs._ofSameType(S$21, P$17))(obs, {fn: fn});
    }
    var mixin$15 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
      },
      _free: function() {
        this._fn = null;
      },
      _handleError: function(x) {
        var fn = this._fn;
        if (fn(x)) {
          this._emitError(x);
        }
      }
    };
    var S$22 = createStream('filterErrors', mixin$15);
    var P$18 = createProperty('filterErrors', mixin$15);
    var id$6 = function(x) {
      return x;
    };
    function filterErrors(obs) {
      var fn = arguments.length <= 1 || arguments[1] === undefined ? id$6 : arguments[1];
      return new (obs._ofSameType(S$22, P$18))(obs, {fn: fn});
    }
    var mixin$16 = {_handleValue: function() {}};
    var S$23 = createStream('ignoreValues', mixin$16);
    var P$19 = createProperty('ignoreValues', mixin$16);
    function ignoreValues(obs) {
      return new (obs._ofSameType(S$23, P$19))(obs);
    }
    var mixin$17 = {_handleError: function() {}};
    var S$24 = createStream('ignoreErrors', mixin$17);
    var P$20 = createProperty('ignoreErrors', mixin$17);
    function ignoreErrors(obs) {
      return new (obs._ofSameType(S$24, P$20))(obs);
    }
    var mixin$18 = {_handleEnd: function() {}};
    var S$25 = createStream('ignoreEnd', mixin$18);
    var P$21 = createProperty('ignoreEnd', mixin$18);
    function ignoreEnd(obs) {
      return new (obs._ofSameType(S$25, P$21))(obs);
    }
    var mixin$19 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
      },
      _free: function() {
        this._fn = null;
      },
      _handleEnd: function() {
        var fn = this._fn;
        this._emitValue(fn());
        this._emitEnd();
      }
    };
    var S$26 = createStream('beforeEnd', mixin$19);
    var P$22 = createProperty('beforeEnd', mixin$19);
    function beforeEnd(obs, fn) {
      return new (obs._ofSameType(S$26, P$22))(obs, {fn: fn});
    }
    var mixin$20 = {
      _init: function(_ref) {
        var min = _ref.min;
        var max = _ref.max;
        this._max = max;
        this._min = min;
        this._buff = [];
      },
      _free: function() {
        this._buff = null;
      },
      _handleValue: function(x) {
        this._buff = slide(this._buff, x, this._max);
        if (this._buff.length >= this._min) {
          this._emitValue(this._buff);
        }
      }
    };
    var S$27 = createStream('slidingWindow', mixin$20);
    var P$23 = createProperty('slidingWindow', mixin$20);
    function slidingWindow(obs, max) {
      var min = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
      return new (obs._ofSameType(S$27, P$23))(obs, {
        min: min,
        max: max
      });
    }
    var mixin$21 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        var flushOnEnd = _ref.flushOnEnd;
        this._fn = fn;
        this._flushOnEnd = flushOnEnd;
        this._buff = [];
      },
      _free: function() {
        this._buff = null;
      },
      _flush: function() {
        if (this._buff !== null && this._buff.length !== 0) {
          this._emitValue(this._buff);
          this._buff = [];
        }
      },
      _handleValue: function(x) {
        this._buff.push(x);
        var fn = this._fn;
        if (!fn(x)) {
          this._flush();
        }
      },
      _handleEnd: function() {
        if (this._flushOnEnd) {
          this._flush();
        }
        this._emitEnd();
      }
    };
    var S$28 = createStream('bufferWhile', mixin$21);
    var P$24 = createProperty('bufferWhile', mixin$21);
    var id$7 = function(x) {
      return x;
    };
    function bufferWhile(obs, fn) {
      var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
      var _ref2$flushOnEnd = _ref2.flushOnEnd;
      var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;
      return new (obs._ofSameType(S$28, P$24))(obs, {
        fn: fn || id$7,
        flushOnEnd: flushOnEnd
      });
    }
    var mixin$22 = {
      _init: function(_ref) {
        var count = _ref.count;
        var flushOnEnd = _ref.flushOnEnd;
        this._count = count;
        this._flushOnEnd = flushOnEnd;
        this._buff = [];
      },
      _free: function() {
        this._buff = null;
      },
      _flush: function() {
        if (this._buff !== null && this._buff.length !== 0) {
          this._emitValue(this._buff);
          this._buff = [];
        }
      },
      _handleValue: function(x) {
        this._buff.push(x);
        if (this._buff.length >= this._count) {
          this._flush();
        }
      },
      _handleEnd: function() {
        if (this._flushOnEnd) {
          this._flush();
        }
        this._emitEnd();
      }
    };
    var S$29 = createStream('bufferWithCount', mixin$22);
    var P$25 = createProperty('bufferWithCount', mixin$22);
    function bufferWhile$1(obs, count) {
      var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
      var _ref2$flushOnEnd = _ref2.flushOnEnd;
      var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;
      return new (obs._ofSameType(S$29, P$25))(obs, {
        count: count,
        flushOnEnd: flushOnEnd
      });
    }
    var mixin$23 = {
      _init: function(_ref) {
        var _this = this;
        var wait = _ref.wait;
        var count = _ref.count;
        var flushOnEnd = _ref.flushOnEnd;
        this._wait = wait;
        this._count = count;
        this._flushOnEnd = flushOnEnd;
        this._intervalId = null;
        this._$onTick = function() {
          return _this._flush();
        };
        this._buff = [];
      },
      _free: function() {
        this._$onTick = null;
        this._buff = null;
      },
      _flush: function() {
        if (this._buff !== null) {
          this._emitValue(this._buff);
          this._buff = [];
        }
      },
      _handleValue: function(x) {
        this._buff.push(x);
        if (this._buff.length >= this._count) {
          clearInterval(this._intervalId);
          this._flush();
          this._intervalId = setInterval(this._$onTick, this._wait);
        }
      },
      _handleEnd: function() {
        if (this._flushOnEnd && this._buff.length !== 0) {
          this._flush();
        }
        this._emitEnd();
      },
      _onActivation: function() {
        this._intervalId = setInterval(this._$onTick, this._wait);
        this._source.onAny(this._$handleAny);
      },
      _onDeactivation: function() {
        if (this._intervalId !== null) {
          clearInterval(this._intervalId);
          this._intervalId = null;
        }
        this._source.offAny(this._$handleAny);
      }
    };
    var S$30 = createStream('bufferWithTimeOrCount', mixin$23);
    var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);
    function bufferWithTimeOrCount(obs, wait, count) {
      var _ref2 = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
      var _ref2$flushOnEnd = _ref2.flushOnEnd;
      var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;
      return new (obs._ofSameType(S$30, P$26))(obs, {
        wait: wait,
        count: count,
        flushOnEnd: flushOnEnd
      });
    }
    function xformForObs(obs) {
      return {
        '@@transducer/step': function(res, input) {
          obs._emitValue(input);
          return null;
        },
        '@@transducer/result': function() {
          obs._emitEnd();
          return null;
        }
      };
    }
    var mixin$24 = {
      _init: function(_ref) {
        var transducer = _ref.transducer;
        this._xform = transducer(xformForObs(this));
      },
      _free: function() {
        this._xform = null;
      },
      _handleValue: function(x) {
        if (this._xform['@@transducer/step'](null, x) !== null) {
          this._xform['@@transducer/result'](null);
        }
      },
      _handleEnd: function() {
        this._xform['@@transducer/result'](null);
      }
    };
    var S$31 = createStream('transduce', mixin$24);
    var P$27 = createProperty('transduce', mixin$24);
    function transduce(obs, transducer) {
      return new (obs._ofSameType(S$31, P$27))(obs, {transducer: transducer});
    }
    var mixin$25 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._handler = fn;
        this._emitter = emitter(this);
      },
      _free: function() {
        this._handler = null;
        this._emitter = null;
      },
      _handleAny: function(event) {
        this._handler(this._emitter, event);
      }
    };
    var S$32 = createStream('withHandler', mixin$25);
    var P$28 = createProperty('withHandler', mixin$25);
    function withHandler(obs, fn) {
      return new (obs._ofSameType(S$32, P$28))(obs, {fn: fn});
    }
    function defaultErrorsCombinator(errors) {
      var latestError = void 0;
      for (var i = 0; i < errors.length; i++) {
        if (errors[i] !== undefined) {
          if (latestError === undefined || latestError.index < errors[i].index) {
            latestError = errors[i];
          }
        }
      }
      return latestError.error;
    }
    function Combine(active, passive, combinator) {
      var _this = this;
      Stream.call(this);
      this._activeCount = active.length;
      this._sources = concat(active, passive);
      this._combinator = combinator ? spread(combinator, this._sources.length) : function(x) {
        return x;
      };
      this._aliveCount = 0;
      this._latestValues = new Array(this._sources.length);
      this._latestErrors = new Array(this._sources.length);
      fillArray(this._latestValues, NOTHING);
      this._emitAfterActivation = false;
      this._endAfterActivation = false;
      this._latestErrorIndex = 0;
      this._$handlers = [];
      var _loop = function(i) {
        _this._$handlers.push(function(event) {
          return _this._handleAny(i, event);
        });
      };
      for (var i = 0; i < this._sources.length; i++) {
        _loop(i);
      }
    }
    inherit(Combine, Stream, {
      _name: 'combine',
      _onActivation: function() {
        this._aliveCount = this._activeCount;
        for (var i = this._activeCount; i < this._sources.length; i++) {
          this._sources[i].onAny(this._$handlers[i]);
        }
        for (var i = 0; i < this._activeCount; i++) {
          this._sources[i].onAny(this._$handlers[i]);
        }
        if (this._emitAfterActivation) {
          this._emitAfterActivation = false;
          this._emitIfFull();
        }
        if (this._endAfterActivation) {
          this._emitEnd();
        }
      },
      _onDeactivation: function() {
        var length = this._sources.length,
            i = void 0;
        for (i = 0; i < length; i++) {
          this._sources[i].offAny(this._$handlers[i]);
        }
      },
      _emitIfFull: function() {
        var hasAllValues = true;
        var hasErrors = false;
        var length = this._latestValues.length;
        var valuesCopy = new Array(length);
        var errorsCopy = new Array(length);
        for (var i = 0; i < length; i++) {
          valuesCopy[i] = this._latestValues[i];
          errorsCopy[i] = this._latestErrors[i];
          if (valuesCopy[i] === NOTHING) {
            hasAllValues = false;
          }
          if (errorsCopy[i] !== undefined) {
            hasErrors = true;
          }
        }
        if (hasAllValues) {
          var combinator = this._combinator;
          this._emitValue(combinator(valuesCopy));
        }
        if (hasErrors) {
          this._emitError(defaultErrorsCombinator(errorsCopy));
        }
      },
      _handleAny: function(i, event) {
        if (event.type === VALUE || event.type === ERROR) {
          if (event.type === VALUE) {
            this._latestValues[i] = event.value;
            this._latestErrors[i] = undefined;
          }
          if (event.type === ERROR) {
            this._latestValues[i] = NOTHING;
            this._latestErrors[i] = {
              index: this._latestErrorIndex++,
              error: event.value
            };
          }
          if (i < this._activeCount) {
            if (this._activating) {
              this._emitAfterActivation = true;
            } else {
              this._emitIfFull();
            }
          }
        } else {
          if (i < this._activeCount) {
            this._aliveCount--;
            if (this._aliveCount === 0) {
              if (this._activating) {
                this._endAfterActivation = true;
              } else {
                this._emitEnd();
              }
            }
          }
        }
      },
      _clear: function() {
        Stream.prototype._clear.call(this);
        this._sources = null;
        this._latestValues = null;
        this._latestErrors = null;
        this._combinator = null;
        this._$handlers = null;
      }
    });
    function combine(active) {
      var passive = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
      var combinator = arguments[2];
      if (typeof passive === 'function') {
        combinator = passive;
        passive = [];
      }
      return active.length === 0 ? never() : new Combine(active, passive, combinator);
    }
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };
    function Zip(sources, combinator) {
      var _this = this;
      Stream.call(this);
      this._buffers = map(sources, function(source) {
        return isArray(source) ? cloneArray(source) : [];
      });
      this._sources = map(sources, function(source) {
        return isArray(source) ? never() : source;
      });
      this._combinator = combinator ? spread(combinator, this._sources.length) : function(x) {
        return x;
      };
      this._aliveCount = 0;
      this._$handlers = [];
      var _loop = function(i) {
        _this._$handlers.push(function(event) {
          return _this._handleAny(i, event);
        });
      };
      for (var i = 0; i < this._sources.length; i++) {
        _loop(i);
      }
    }
    inherit(Zip, Stream, {
      _name: 'zip',
      _onActivation: function() {
        while (this._isFull()) {
          this._emit();
        }
        var length = this._sources.length;
        this._aliveCount = length;
        for (var i = 0; i < length && this._active; i++) {
          this._sources[i].onAny(this._$handlers[i]);
        }
      },
      _onDeactivation: function() {
        for (var i = 0; i < this._sources.length; i++) {
          this._sources[i].offAny(this._$handlers[i]);
        }
      },
      _emit: function() {
        var values = new Array(this._buffers.length);
        for (var i = 0; i < this._buffers.length; i++) {
          values[i] = this._buffers[i].shift();
        }
        var combinator = this._combinator;
        this._emitValue(combinator(values));
      },
      _isFull: function() {
        for (var i = 0; i < this._buffers.length; i++) {
          if (this._buffers[i].length === 0) {
            return false;
          }
        }
        return true;
      },
      _handleAny: function(i, event) {
        if (event.type === VALUE) {
          this._buffers[i].push(event.value);
          if (this._isFull()) {
            this._emit();
          }
        }
        if (event.type === ERROR) {
          this._emitError(event.value);
        }
        if (event.type === END) {
          this._aliveCount--;
          if (this._aliveCount === 0) {
            this._emitEnd();
          }
        }
      },
      _clear: function() {
        Stream.prototype._clear.call(this);
        this._sources = null;
        this._buffers = null;
        this._combinator = null;
        this._$handlers = null;
      }
    });
    function zip(observables, combinator) {
      return observables.length === 0 ? never() : new Zip(observables, combinator);
    }
    var id$8 = function(x) {
      return x;
    };
    function AbstractPool() {
      var _this = this;
      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var _ref$queueLim = _ref.queueLim;
      var queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim;
      var _ref$concurLim = _ref.concurLim;
      var concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim;
      var _ref$drop = _ref.drop;
      var drop = _ref$drop === undefined ? 'new' : _ref$drop;
      Stream.call(this);
      this._queueLim = queueLim < 0 ? -1 : queueLim;
      this._concurLim = concurLim < 0 ? -1 : concurLim;
      this._drop = drop;
      this._queue = [];
      this._curSources = [];
      this._$handleSubAny = function(event) {
        return _this._handleSubAny(event);
      };
      this._$endHandlers = [];
      this._currentlyAdding = null;
      if (this._concurLim === 0) {
        this._emitEnd();
      }
    }
    inherit(AbstractPool, Stream, {
      _name: 'abstractPool',
      _add: function(obj, toObs) {
        toObs = toObs || id$8;
        if (this._concurLim === -1 || this._curSources.length < this._concurLim) {
          this._addToCur(toObs(obj));
        } else {
          if (this._queueLim === -1 || this._queue.length < this._queueLim) {
            this._addToQueue(toObs(obj));
          } else if (this._drop === 'old') {
            this._removeOldest();
            this._add(obj, toObs);
          }
        }
      },
      _addAll: function(obss) {
        var _this2 = this;
        forEach(obss, function(obs) {
          return _this2._add(obs);
        });
      },
      _remove: function(obs) {
        if (this._removeCur(obs) === -1) {
          this._removeQueue(obs);
        }
      },
      _addToQueue: function(obs) {
        this._queue = concat(this._queue, [obs]);
      },
      _addToCur: function(obs) {
        if (this._active) {
          if (!obs._alive) {
            if (obs._currentEvent) {
              this._emit(obs._currentEvent.type, obs._currentEvent.value);
            }
            return;
          }
          this._currentlyAdding = obs;
          obs.onAny(this._$handleSubAny);
          this._currentlyAdding = null;
          if (obs._alive) {
            this._curSources = concat(this._curSources, [obs]);
            if (this._active) {
              this._subToEnd(obs);
            }
          }
        } else {
          this._curSources = concat(this._curSources, [obs]);
        }
      },
      _subToEnd: function(obs) {
        var _this3 = this;
        var onEnd = function() {
          return _this3._removeCur(obs);
        };
        this._$endHandlers.push({
          obs: obs,
          handler: onEnd
        });
        obs.onEnd(onEnd);
      },
      _subscribe: function(obs) {
        obs.onAny(this._$handleSubAny);
        if (this._active) {
          this._subToEnd(obs);
        }
      },
      _unsubscribe: function(obs) {
        obs.offAny(this._$handleSubAny);
        var onEndI = findByPred(this._$endHandlers, function(obj) {
          return obj.obs === obs;
        });
        if (onEndI !== -1) {
          obs.offEnd(this._$endHandlers[onEndI].handler);
          this._$endHandlers.splice(onEndI, 1);
        }
      },
      _handleSubAny: function(event) {
        if (event.type === VALUE) {
          this._emitValue(event.value);
        } else if (event.type === ERROR) {
          this._emitError(event.value);
        }
      },
      _removeQueue: function(obs) {
        var index = find(this._queue, obs);
        this._queue = remove(this._queue, index);
        return index;
      },
      _removeCur: function(obs) {
        if (this._active) {
          this._unsubscribe(obs);
        }
        var index = find(this._curSources, obs);
        this._curSources = remove(this._curSources, index);
        if (index !== -1) {
          if (this._queue.length !== 0) {
            this._pullQueue();
          } else if (this._curSources.length === 0) {
            this._onEmpty();
          }
        }
        return index;
      },
      _removeOldest: function() {
        this._removeCur(this._curSources[0]);
      },
      _pullQueue: function() {
        if (this._queue.length !== 0) {
          this._queue = cloneArray(this._queue);
          this._addToCur(this._queue.shift());
        }
      },
      _onActivation: function() {
        for (var i = 0,
            sources = this._curSources; i < sources.length && this._active; i++) {
          this._subscribe(sources[i]);
        }
      },
      _onDeactivation: function() {
        for (var i = 0,
            sources = this._curSources; i < sources.length; i++) {
          this._unsubscribe(sources[i]);
        }
        if (this._currentlyAdding !== null) {
          this._unsubscribe(this._currentlyAdding);
        }
      },
      _isEmpty: function() {
        return this._curSources.length === 0;
      },
      _onEmpty: function() {},
      _clear: function() {
        Stream.prototype._clear.call(this);
        this._queue = null;
        this._curSources = null;
        this._$handleSubAny = null;
        this._$endHandlers = null;
      }
    });
    function Merge(sources) {
      AbstractPool.call(this);
      this._addAll(sources);
      this._initialised = true;
    }
    inherit(Merge, AbstractPool, {
      _name: 'merge',
      _onEmpty: function() {
        if (this._initialised) {
          this._emitEnd();
        }
      }
    });
    function merge(observables) {
      return observables.length === 0 ? never() : new Merge(observables);
    }
    function S$33(generator) {
      var _this = this;
      Stream.call(this);
      this._generator = generator;
      this._source = null;
      this._inLoop = false;
      this._iteration = 0;
      this._$handleAny = function(event) {
        return _this._handleAny(event);
      };
    }
    inherit(S$33, Stream, {
      _name: 'repeat',
      _handleAny: function(event) {
        if (event.type === END) {
          this._source = null;
          this._getSource();
        } else {
          this._emit(event.type, event.value);
        }
      },
      _getSource: function() {
        if (!this._inLoop) {
          this._inLoop = true;
          var generator = this._generator;
          while (this._source === null && this._alive && this._active) {
            this._source = generator(this._iteration++);
            if (this._source) {
              this._source.onAny(this._$handleAny);
            } else {
              this._emitEnd();
            }
          }
          this._inLoop = false;
        }
      },
      _onActivation: function() {
        if (this._source) {
          this._source.onAny(this._$handleAny);
        } else {
          this._getSource();
        }
      },
      _onDeactivation: function() {
        if (this._source) {
          this._source.offAny(this._$handleAny);
        }
      },
      _clear: function() {
        Stream.prototype._clear.call(this);
        this._generator = null;
        this._source = null;
        this._$handleAny = null;
      }
    });
    function repeat(generator) {
      return new S$33(generator);
    }
    function concat$1(observables) {
      return repeat(function(index) {
        return observables.length > index ? observables[index] : false;
      }).setName('concat');
    }
    function Pool() {
      AbstractPool.call(this);
    }
    inherit(Pool, AbstractPool, {
      _name: 'pool',
      plug: function(obs) {
        this._add(obs);
        return this;
      },
      unplug: function(obs) {
        this._remove(obs);
        return this;
      }
    });
    function FlatMap(source, fn, options) {
      var _this = this;
      AbstractPool.call(this, options);
      this._source = source;
      this._fn = fn;
      this._mainEnded = false;
      this._lastCurrent = null;
      this._$handleMain = function(event) {
        return _this._handleMain(event);
      };
    }
    inherit(FlatMap, AbstractPool, {
      _onActivation: function() {
        AbstractPool.prototype._onActivation.call(this);
        if (this._active) {
          this._source.onAny(this._$handleMain);
        }
      },
      _onDeactivation: function() {
        AbstractPool.prototype._onDeactivation.call(this);
        this._source.offAny(this._$handleMain);
        this._hadNoEvSinceDeact = true;
      },
      _handleMain: function(event) {
        if (event.type === VALUE) {
          var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
          if (!sameCurr) {
            this._add(event.value, this._fn);
          }
          this._lastCurrent = event.value;
          this._hadNoEvSinceDeact = false;
        }
        if (event.type === ERROR) {
          this._emitError(event.value);
        }
        if (event.type === END) {
          if (this._isEmpty()) {
            this._emitEnd();
          } else {
            this._mainEnded = true;
          }
        }
      },
      _onEmpty: function() {
        if (this._mainEnded) {
          this._emitEnd();
        }
      },
      _clear: function() {
        AbstractPool.prototype._clear.call(this);
        this._source = null;
        this._lastCurrent = null;
        this._$handleMain = null;
      }
    });
    function FlatMapErrors(source, fn) {
      FlatMap.call(this, source, fn);
    }
    inherit(FlatMapErrors, FlatMap, {_handleMain: function(event) {
        if (event.type === ERROR) {
          var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
          if (!sameCurr) {
            this._add(event.value, this._fn);
          }
          this._lastCurrent = event.value;
          this._hadNoEvSinceDeact = false;
        }
        if (event.type === VALUE) {
          this._emitValue(event.value);
        }
        if (event.type === END) {
          if (this._isEmpty()) {
            this._emitEnd();
          } else {
            this._mainEnded = true;
          }
        }
      }});
    function createConstructor$1(BaseClass, name) {
      return function AnonymousObservable(primary, secondary, options) {
        var _this = this;
        BaseClass.call(this);
        this._primary = primary;
        this._secondary = secondary;
        this._name = primary._name + '.' + name;
        this._lastSecondary = NOTHING;
        this._$handleSecondaryAny = function(event) {
          return _this._handleSecondaryAny(event);
        };
        this._$handlePrimaryAny = function(event) {
          return _this._handlePrimaryAny(event);
        };
        this._init(options);
      };
    }
    function createClassMethods$1(BaseClass) {
      return {
        _init: function() {},
        _free: function() {},
        _handlePrimaryValue: function(x) {
          this._emitValue(x);
        },
        _handlePrimaryError: function(x) {
          this._emitError(x);
        },
        _handlePrimaryEnd: function() {
          this._emitEnd();
        },
        _handleSecondaryValue: function(x) {
          this._lastSecondary = x;
        },
        _handleSecondaryError: function(x) {
          this._emitError(x);
        },
        _handleSecondaryEnd: function() {},
        _handlePrimaryAny: function(event) {
          switch (event.type) {
            case VALUE:
              return this._handlePrimaryValue(event.value);
            case ERROR:
              return this._handlePrimaryError(event.value);
            case END:
              return this._handlePrimaryEnd(event.value);
          }
        },
        _handleSecondaryAny: function(event) {
          switch (event.type) {
            case VALUE:
              return this._handleSecondaryValue(event.value);
            case ERROR:
              return this._handleSecondaryError(event.value);
            case END:
              this._handleSecondaryEnd(event.value);
              this._removeSecondary();
          }
        },
        _removeSecondary: function() {
          if (this._secondary !== null) {
            this._secondary.offAny(this._$handleSecondaryAny);
            this._$handleSecondaryAny = null;
            this._secondary = null;
          }
        },
        _onActivation: function() {
          if (this._secondary !== null) {
            this._secondary.onAny(this._$handleSecondaryAny);
          }
          if (this._active) {
            this._primary.onAny(this._$handlePrimaryAny);
          }
        },
        _onDeactivation: function() {
          if (this._secondary !== null) {
            this._secondary.offAny(this._$handleSecondaryAny);
          }
          this._primary.offAny(this._$handlePrimaryAny);
        },
        _clear: function() {
          BaseClass.prototype._clear.call(this);
          this._primary = null;
          this._secondary = null;
          this._lastSecondary = null;
          this._$handleSecondaryAny = null;
          this._$handlePrimaryAny = null;
          this._free();
        }
      };
    }
    function createStream$1(name, mixin) {
      var S = createConstructor$1(Stream, name);
      inherit(S, Stream, createClassMethods$1(Stream), mixin);
      return S;
    }
    function createProperty$1(name, mixin) {
      var P = createConstructor$1(Property, name);
      inherit(P, Property, createClassMethods$1(Property), mixin);
      return P;
    }
    var mixin$26 = {
      _handlePrimaryValue: function(x) {
        if (this._lastSecondary !== NOTHING && this._lastSecondary) {
          this._emitValue(x);
        }
      },
      _handleSecondaryEnd: function() {
        if (this._lastSecondary === NOTHING || !this._lastSecondary) {
          this._emitEnd();
        }
      }
    };
    var S$34 = createStream$1('filterBy', mixin$26);
    var P$29 = createProperty$1('filterBy', mixin$26);
    function filterBy(primary, secondary) {
      return new (primary._ofSameType(S$34, P$29))(primary, secondary);
    }
    var id2 = function(_, x) {
      return x;
    };
    function sampledBy(passive, active, combinator) {
      var _combinator = combinator ? function(a, b) {
        return combinator(b, a);
      } : id2;
      return combine([active], [passive], _combinator).setName(passive, 'sampledBy');
    }
    var mixin$27 = {
      _handlePrimaryValue: function(x) {
        if (this._lastSecondary !== NOTHING) {
          this._emitValue(x);
        }
      },
      _handleSecondaryEnd: function() {
        if (this._lastSecondary === NOTHING) {
          this._emitEnd();
        }
      }
    };
    var S$35 = createStream$1('skipUntilBy', mixin$27);
    var P$30 = createProperty$1('skipUntilBy', mixin$27);
    function skipUntilBy(primary, secondary) {
      return new (primary._ofSameType(S$35, P$30))(primary, secondary);
    }
    var mixin$28 = {_handleSecondaryValue: function() {
        this._emitEnd();
      }};
    var S$36 = createStream$1('takeUntilBy', mixin$28);
    var P$31 = createProperty$1('takeUntilBy', mixin$28);
    function takeUntilBy(primary, secondary) {
      return new (primary._ofSameType(S$36, P$31))(primary, secondary);
    }
    var mixin$29 = {
      _init: function() {
        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        var _ref$flushOnEnd = _ref.flushOnEnd;
        var flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;
        this._buff = [];
        this._flushOnEnd = flushOnEnd;
      },
      _free: function() {
        this._buff = null;
      },
      _flush: function() {
        if (this._buff !== null) {
          this._emitValue(this._buff);
          this._buff = [];
        }
      },
      _handlePrimaryEnd: function() {
        if (this._flushOnEnd) {
          this._flush();
        }
        this._emitEnd();
      },
      _onActivation: function() {
        this._primary.onAny(this._$handlePrimaryAny);
        if (this._alive && this._secondary !== null) {
          this._secondary.onAny(this._$handleSecondaryAny);
        }
      },
      _handlePrimaryValue: function(x) {
        this._buff.push(x);
      },
      _handleSecondaryValue: function() {
        this._flush();
      },
      _handleSecondaryEnd: function() {
        if (!this._flushOnEnd) {
          this._emitEnd();
        }
      }
    };
    var S$37 = createStream$1('bufferBy', mixin$29);
    var P$32 = createProperty$1('bufferBy', mixin$29);
    function bufferBy(primary, secondary, options) {
      return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);
    }
    var mixin$30 = {
      _init: function() {
        var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        var _ref$flushOnEnd = _ref.flushOnEnd;
        var flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;
        var _ref$flushOnChange = _ref.flushOnChange;
        var flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;
        this._buff = [];
        this._flushOnEnd = flushOnEnd;
        this._flushOnChange = flushOnChange;
      },
      _free: function() {
        this._buff = null;
      },
      _flush: function() {
        if (this._buff !== null) {
          this._emitValue(this._buff);
          this._buff = [];
        }
      },
      _handlePrimaryEnd: function() {
        if (this._flushOnEnd) {
          this._flush();
        }
        this._emitEnd();
      },
      _handlePrimaryValue: function(x) {
        this._buff.push(x);
        if (this._lastSecondary !== NOTHING && !this._lastSecondary) {
          this._flush();
        }
      },
      _handleSecondaryEnd: function() {
        if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {
          this._emitEnd();
        }
      },
      _handleSecondaryValue: function(x) {
        if (this._flushOnChange && !x) {
          this._flush();
        }
        this._lastSecondary = x;
      }
    };
    var S$38 = createStream$1('bufferWhileBy', mixin$30);
    var P$33 = createProperty$1('bufferWhileBy', mixin$30);
    function bufferWhileBy(primary, secondary, options) {
      return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);
    }
    var f = function() {
      return false;
    };
    var t = function() {
      return true;
    };
    function awaiting(a, b) {
      var result = merge([map$1(a, t), map$1(b, f)]);
      result = skipDuplicates(result);
      result = toProperty(result, f);
      return result.setName(a, 'awaiting');
    }
    var mixin$31 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
      },
      _free: function() {
        this._fn = null;
      },
      _handleValue: function(x) {
        var fn = this._fn;
        var result = fn(x);
        if (result.convert) {
          this._emitError(result.error);
        } else {
          this._emitValue(x);
        }
      }
    };
    var S$39 = createStream('valuesToErrors', mixin$31);
    var P$34 = createProperty('valuesToErrors', mixin$31);
    var defFn = function(x) {
      return {
        convert: true,
        error: x
      };
    };
    function valuesToErrors(obs) {
      var fn = arguments.length <= 1 || arguments[1] === undefined ? defFn : arguments[1];
      return new (obs._ofSameType(S$39, P$34))(obs, {fn: fn});
    }
    var mixin$32 = {
      _init: function(_ref) {
        var fn = _ref.fn;
        this._fn = fn;
      },
      _free: function() {
        this._fn = null;
      },
      _handleError: function(x) {
        var fn = this._fn;
        var result = fn(x);
        if (result.convert) {
          this._emitValue(result.value);
        } else {
          this._emitError(x);
        }
      }
    };
    var S$40 = createStream('errorsToValues', mixin$32);
    var P$35 = createProperty('errorsToValues', mixin$32);
    var defFn$1 = function(x) {
      return {
        convert: true,
        value: x
      };
    };
    function errorsToValues(obs) {
      var fn = arguments.length <= 1 || arguments[1] === undefined ? defFn$1 : arguments[1];
      return new (obs._ofSameType(S$40, P$35))(obs, {fn: fn});
    }
    var mixin$33 = {_handleError: function(x) {
        this._emitError(x);
        this._emitEnd();
      }};
    var S$41 = createStream('endOnError', mixin$33);
    var P$36 = createProperty('endOnError', mixin$33);
    function endOnError(obs) {
      return new (obs._ofSameType(S$41, P$36))(obs);
    }
    Observable.prototype.toProperty = function(fn) {
      return toProperty(this, fn);
    };
    Observable.prototype.changes = function() {
      return changes(this);
    };
    Observable.prototype.toPromise = function(Promise) {
      return toPromise(this, Promise);
    };
    Observable.prototype.toESObservable = toESObservable;
    Observable.prototype[$$observable] = toESObservable;
    Observable.prototype.map = function(fn) {
      return map$1(this, fn);
    };
    Observable.prototype.filter = function(fn) {
      return filter(this, fn);
    };
    Observable.prototype.take = function(n) {
      return take(this, n);
    };
    Observable.prototype.takeErrors = function(n) {
      return takeErrors(this, n);
    };
    Observable.prototype.takeWhile = function(fn) {
      return takeWhile(this, fn);
    };
    Observable.prototype.last = function() {
      return last(this);
    };
    Observable.prototype.skip = function(n) {
      return skip(this, n);
    };
    Observable.prototype.skipWhile = function(fn) {
      return skipWhile(this, fn);
    };
    Observable.prototype.skipDuplicates = function(fn) {
      return skipDuplicates(this, fn);
    };
    Observable.prototype.diff = function(fn, seed) {
      return diff(this, fn, seed);
    };
    Observable.prototype.scan = function(fn, seed) {
      return scan(this, fn, seed);
    };
    Observable.prototype.flatten = function(fn) {
      return flatten(this, fn);
    };
    Observable.prototype.delay = function(wait) {
      return delay(this, wait);
    };
    Observable.prototype.throttle = function(wait, options) {
      return throttle(this, wait, options);
    };
    Observable.prototype.debounce = function(wait, options) {
      return debounce(this, wait, options);
    };
    Observable.prototype.mapErrors = function(fn) {
      return mapErrors(this, fn);
    };
    Observable.prototype.filterErrors = function(fn) {
      return filterErrors(this, fn);
    };
    Observable.prototype.ignoreValues = function() {
      return ignoreValues(this);
    };
    Observable.prototype.ignoreErrors = function() {
      return ignoreErrors(this);
    };
    Observable.prototype.ignoreEnd = function() {
      return ignoreEnd(this);
    };
    Observable.prototype.beforeEnd = function(fn) {
      return beforeEnd(this, fn);
    };
    Observable.prototype.slidingWindow = function(max, min) {
      return slidingWindow(this, max, min);
    };
    Observable.prototype.bufferWhile = function(fn, options) {
      return bufferWhile(this, fn, options);
    };
    Observable.prototype.bufferWithCount = function(count, options) {
      return bufferWhile$1(this, count, options);
    };
    Observable.prototype.bufferWithTimeOrCount = function(wait, count, options) {
      return bufferWithTimeOrCount(this, wait, count, options);
    };
    Observable.prototype.transduce = function(transducer) {
      return transduce(this, transducer);
    };
    Observable.prototype.withHandler = function(fn) {
      return withHandler(this, fn);
    };
    Observable.prototype.combine = function(other, combinator) {
      return combine([this, other], combinator);
    };
    Observable.prototype.zip = function(other, combinator) {
      return zip([this, other], combinator);
    };
    Observable.prototype.merge = function(other) {
      return merge([this, other]);
    };
    Observable.prototype.concat = function(other) {
      return concat$1([this, other]);
    };
    var pool = function() {
      return new Pool();
    };
    Observable.prototype.flatMap = function(fn) {
      return new FlatMap(this, fn).setName(this, 'flatMap');
    };
    Observable.prototype.flatMapLatest = function(fn) {
      return new FlatMap(this, fn, {
        concurLim: 1,
        drop: 'old'
      }).setName(this, 'flatMapLatest');
    };
    Observable.prototype.flatMapFirst = function(fn) {
      return new FlatMap(this, fn, {concurLim: 1}).setName(this, 'flatMapFirst');
    };
    Observable.prototype.flatMapConcat = function(fn) {
      return new FlatMap(this, fn, {
        queueLim: -1,
        concurLim: 1
      }).setName(this, 'flatMapConcat');
    };
    Observable.prototype.flatMapConcurLimit = function(fn, limit) {
      return new FlatMap(this, fn, {
        queueLim: -1,
        concurLim: limit
      }).setName(this, 'flatMapConcurLimit');
    };
    Observable.prototype.flatMapErrors = function(fn) {
      return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');
    };
    Observable.prototype.filterBy = function(other) {
      return filterBy(this, other);
    };
    Observable.prototype.sampledBy = function(other, combinator) {
      return sampledBy(this, other, combinator);
    };
    Observable.prototype.skipUntilBy = function(other) {
      return skipUntilBy(this, other);
    };
    Observable.prototype.takeUntilBy = function(other) {
      return takeUntilBy(this, other);
    };
    Observable.prototype.bufferBy = function(other, options) {
      return bufferBy(this, other, options);
    };
    Observable.prototype.bufferWhileBy = function(other, options) {
      return bufferWhileBy(this, other, options);
    };
    var DEPRECATION_WARNINGS = true;
    function dissableDeprecationWarnings() {
      DEPRECATION_WARNINGS = false;
    }
    function warn(msg) {
      if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {
        var msg2 = '\nHere is an Error object for you containing the call stack:';
        console.warn(msg, msg2, new Error());
      }
    }
    Observable.prototype.awaiting = function(other) {
      warn('You are using deprecated .awaiting() method, see https://github.com/rpominov/kefir/issues/145');
      return awaiting(this, other);
    };
    Observable.prototype.valuesToErrors = function(fn) {
      warn('You are using deprecated .valuesToErrors() method, see https://github.com/rpominov/kefir/issues/149');
      return valuesToErrors(this, fn);
    };
    Observable.prototype.errorsToValues = function(fn) {
      warn('You are using deprecated .errorsToValues() method, see https://github.com/rpominov/kefir/issues/149');
      return errorsToValues(this, fn);
    };
    Observable.prototype.endOnError = function() {
      warn('You are using deprecated .endOnError() method, see https://github.com/rpominov/kefir/issues/150');
      return endOnError(this);
    };
    var Kefir = {
      Observable: Observable,
      Stream: Stream,
      Property: Property,
      never: never,
      later: later,
      interval: interval,
      sequentially: sequentially,
      fromPoll: fromPoll,
      withInterval: withInterval,
      fromCallback: fromCallback,
      fromNodeCallback: fromNodeCallback,
      fromEvents: fromEvents,
      stream: stream,
      constant: constant,
      constantError: constantError,
      fromPromise: fromPromise,
      fromESObservable: fromESObservable,
      combine: combine,
      zip: zip,
      merge: merge,
      concat: concat$1,
      Pool: Pool,
      pool: pool,
      repeat: repeat
    };
    Kefir.Kefir = Kefir;
    exports.dissableDeprecationWarnings = dissableDeprecationWarnings;
    exports.Kefir = Kefir;
    exports.Observable = Observable;
    exports.Stream = Stream;
    exports.Property = Property;
    exports.never = never;
    exports.later = later;
    exports.interval = interval;
    exports.sequentially = sequentially;
    exports.fromPoll = fromPoll;
    exports.withInterval = withInterval;
    exports.fromCallback = fromCallback;
    exports.fromNodeCallback = fromNodeCallback;
    exports.fromEvents = fromEvents;
    exports.stream = stream;
    exports.constant = constant;
    exports.constantError = constantError;
    exports.fromPromise = fromPromise;
    exports.fromESObservable = fromESObservable;
    exports.combine = combine;
    exports.zip = zip;
    exports.merge = merge;
    exports.concat = concat$1;
    exports.Pool = Pool;
    exports.pool = pool;
    exports.repeat = repeat;
    exports['default'] = Kefir;
  }));
  return module.exports;
});

System.registerDynamic("npm:kefir@3.2.2.js", ["npm:kefir@3.2.2/dist/kefir.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:kefir@3.2.2/dist/kefir.js');
  return module.exports;
});

System.registerDynamic("npm:localforage@1.4.0/dist/localforage.js", ["github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(process) {
    (function() {
      var define,
          requireModule,
          $__require,
          requirejs;
      (function() {
        var registry = {},
            seen = {};
        define = function(name, deps, callback) {
          registry[name] = {
            deps: deps,
            callback: callback
          };
        };
        requirejs = $__require = requireModule = function(name) {
          requirejs._eak_seen = registry;
          if (seen[name]) {
            return seen[name];
          }
          seen[name] = {};
          if (!registry[name]) {
            throw new Error("Could not find module " + name);
          }
          var mod = registry[name],
              deps = mod.deps,
              callback = mod.callback,
              reified = [],
              exports;
          for (var i = 0,
              l = deps.length; i < l; i++) {
            if (deps[i] === 'exports') {
              reified.push(exports = {});
            } else {
              reified.push(requireModule(resolve(deps[i])));
            }
          }
          var value = callback.apply(this, reified);
          return seen[name] = exports || value;
          function resolve(child) {
            if (child.charAt(0) !== '.') {
              return child;
            }
            var parts = child.split("/");
            var parentBase = name.split("/").slice(0, -1);
            for (var i = 0,
                l = parts.length; i < l; i++) {
              var part = parts[i];
              if (part === '..') {
                parentBase.pop();
              } else if (part === '.') {
                continue;
              } else {
                parentBase.push(part);
              }
            }
            return parentBase.join("/");
          }
        };
      })();
      define("promise/all", ["./utils", "exports"], function(__dependency1__, __exports__) {
        "use strict";
        var isArray = __dependency1__.isArray;
        var isFunction = __dependency1__.isFunction;
        function all(promises) {
          var Promise = this;
          if (!isArray(promises)) {
            throw new TypeError('You must pass an array to all.');
          }
          return new Promise(function(resolve, reject) {
            var results = [],
                remaining = promises.length,
                promise;
            if (remaining === 0) {
              resolve([]);
            }
            function resolver(index) {
              return function(value) {
                resolveAll(index, value);
              };
            }
            function resolveAll(index, value) {
              results[index] = value;
              if (--remaining === 0) {
                resolve(results);
              }
            }
            for (var i = 0; i < promises.length; i++) {
              promise = promises[i];
              if (promise && isFunction(promise.then)) {
                promise.then(resolver(i), reject);
              } else {
                resolveAll(i, promise);
              }
            }
          });
        }
        __exports__.all = all;
      });
      define("promise/asap", ["exports"], function(__exports__) {
        "use strict";
        var browserGlobal = (typeof window !== 'undefined') ? window : {};
        var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
        var local = (typeof global !== 'undefined') ? global : (this === undefined ? window : this);
        function useNextTick() {
          return function() {
            process.nextTick(flush);
          };
        }
        function useMutationObserver() {
          var iterations = 0;
          var observer = new BrowserMutationObserver(flush);
          var node = document.createTextNode('');
          observer.observe(node, {characterData: true});
          return function() {
            node.data = (iterations = ++iterations % 2);
          };
        }
        function useSetTimeout() {
          return function() {
            local.setTimeout(flush, 1);
          };
        }
        var queue = [];
        function flush() {
          for (var i = 0; i < queue.length; i++) {
            var tuple = queue[i];
            var callback = tuple[0],
                arg = tuple[1];
            callback(arg);
          }
          queue = [];
        }
        var scheduleFlush;
        if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
          scheduleFlush = useNextTick();
        } else if (BrowserMutationObserver) {
          scheduleFlush = useMutationObserver();
        } else {
          scheduleFlush = useSetTimeout();
        }
        function asap(callback, arg) {
          var length = queue.push([callback, arg]);
          if (length === 1) {
            scheduleFlush();
          }
        }
        __exports__.asap = asap;
      });
      define("promise/config", ["exports"], function(__exports__) {
        "use strict";
        var config = {instrument: false};
        function configure(name, value) {
          if (arguments.length === 2) {
            config[name] = value;
          } else {
            return config[name];
          }
        }
        __exports__.config = config;
        __exports__.configure = configure;
      });
      define("promise/polyfill", ["./promise", "./utils", "exports"], function(__dependency1__, __dependency2__, __exports__) {
        "use strict";
        var RSVPPromise = __dependency1__.Promise;
        var isFunction = __dependency2__.isFunction;
        function polyfill() {
          var local;
          if (typeof global !== 'undefined') {
            local = global;
          } else if (typeof window !== 'undefined' && window.document) {
            local = window;
          } else {
            local = self;
          }
          var es6PromiseSupport = "Promise" in local && "resolve" in local.Promise && "reject" in local.Promise && "all" in local.Promise && "race" in local.Promise && (function() {
            var resolve;
            new local.Promise(function(r) {
              resolve = r;
            });
            return isFunction(resolve);
          }());
          if (!es6PromiseSupport) {
            local.Promise = RSVPPromise;
          }
        }
        __exports__.polyfill = polyfill;
      });
      define("promise/promise", ["./config", "./utils", "./all", "./race", "./resolve", "./reject", "./asap", "exports"], function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
        "use strict";
        var config = __dependency1__.config;
        var configure = __dependency1__.configure;
        var objectOrFunction = __dependency2__.objectOrFunction;
        var isFunction = __dependency2__.isFunction;
        var now = __dependency2__.now;
        var all = __dependency3__.all;
        var race = __dependency4__.race;
        var staticResolve = __dependency5__.resolve;
        var staticReject = __dependency6__.reject;
        var asap = __dependency7__.asap;
        var counter = 0;
        config.async = asap;
        function Promise(resolver) {
          if (!isFunction(resolver)) {
            throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
          }
          if (!(this instanceof Promise)) {
            throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
          }
          this._subscribers = [];
          invokeResolver(resolver, this);
        }
        function invokeResolver(resolver, promise) {
          function resolvePromise(value) {
            resolve(promise, value);
          }
          function rejectPromise(reason) {
            reject(promise, reason);
          }
          try {
            resolver(resolvePromise, rejectPromise);
          } catch (e) {
            rejectPromise(e);
          }
        }
        function invokeCallback(settled, promise, callback, detail) {
          var hasCallback = isFunction(callback),
              value,
              error,
              succeeded,
              failed;
          if (hasCallback) {
            try {
              value = callback(detail);
              succeeded = true;
            } catch (e) {
              failed = true;
              error = e;
            }
          } else {
            value = detail;
            succeeded = true;
          }
          if (handleThenable(promise, value)) {
            return;
          } else if (hasCallback && succeeded) {
            resolve(promise, value);
          } else if (failed) {
            reject(promise, error);
          } else if (settled === FULFILLED) {
            resolve(promise, value);
          } else if (settled === REJECTED) {
            reject(promise, value);
          }
        }
        var PENDING = void 0;
        var SEALED = 0;
        var FULFILLED = 1;
        var REJECTED = 2;
        function subscribe(parent, child, onFulfillment, onRejection) {
          var subscribers = parent._subscribers;
          var length = subscribers.length;
          subscribers[length] = child;
          subscribers[length + FULFILLED] = onFulfillment;
          subscribers[length + REJECTED] = onRejection;
        }
        function publish(promise, settled) {
          var child,
              callback,
              subscribers = promise._subscribers,
              detail = promise._detail;
          for (var i = 0; i < subscribers.length; i += 3) {
            child = subscribers[i];
            callback = subscribers[i + settled];
            invokeCallback(settled, child, callback, detail);
          }
          promise._subscribers = null;
        }
        Promise.prototype = {
          constructor: Promise,
          _state: undefined,
          _detail: undefined,
          _subscribers: undefined,
          then: function(onFulfillment, onRejection) {
            var promise = this;
            var thenPromise = new this.constructor(function() {});
            if (this._state) {
              var callbacks = arguments;
              config.async(function invokePromiseCallback() {
                invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
              });
            } else {
              subscribe(this, thenPromise, onFulfillment, onRejection);
            }
            return thenPromise;
          },
          'catch': function(onRejection) {
            return this.then(null, onRejection);
          }
        };
        Promise.all = all;
        Promise.race = race;
        Promise.resolve = staticResolve;
        Promise.reject = staticReject;
        function handleThenable(promise, value) {
          var then = null,
              resolved;
          try {
            if (promise === value) {
              throw new TypeError("A promises callback cannot return that same promise.");
            }
            if (objectOrFunction(value)) {
              then = value.then;
              if (isFunction(then)) {
                then.call(value, function(val) {
                  if (resolved) {
                    return true;
                  }
                  resolved = true;
                  if (value !== val) {
                    resolve(promise, val);
                  } else {
                    fulfill(promise, val);
                  }
                }, function(val) {
                  if (resolved) {
                    return true;
                  }
                  resolved = true;
                  reject(promise, val);
                });
                return true;
              }
            }
          } catch (error) {
            if (resolved) {
              return true;
            }
            reject(promise, error);
            return true;
          }
          return false;
        }
        function resolve(promise, value) {
          if (promise === value) {
            fulfill(promise, value);
          } else if (!handleThenable(promise, value)) {
            fulfill(promise, value);
          }
        }
        function fulfill(promise, value) {
          if (promise._state !== PENDING) {
            return;
          }
          promise._state = SEALED;
          promise._detail = value;
          config.async(publishFulfillment, promise);
        }
        function reject(promise, reason) {
          if (promise._state !== PENDING) {
            return;
          }
          promise._state = SEALED;
          promise._detail = reason;
          config.async(publishRejection, promise);
        }
        function publishFulfillment(promise) {
          publish(promise, promise._state = FULFILLED);
        }
        function publishRejection(promise) {
          publish(promise, promise._state = REJECTED);
        }
        __exports__.Promise = Promise;
      });
      define("promise/race", ["./utils", "exports"], function(__dependency1__, __exports__) {
        "use strict";
        var isArray = __dependency1__.isArray;
        function race(promises) {
          var Promise = this;
          if (!isArray(promises)) {
            throw new TypeError('You must pass an array to race.');
          }
          return new Promise(function(resolve, reject) {
            var results = [],
                promise;
            for (var i = 0; i < promises.length; i++) {
              promise = promises[i];
              if (promise && typeof promise.then === 'function') {
                promise.then(resolve, reject);
              } else {
                resolve(promise);
              }
            }
          });
        }
        __exports__.race = race;
      });
      define("promise/reject", ["exports"], function(__exports__) {
        "use strict";
        function reject(reason) {
          var Promise = this;
          return new Promise(function(resolve, reject) {
            reject(reason);
          });
        }
        __exports__.reject = reject;
      });
      define("promise/resolve", ["exports"], function(__exports__) {
        "use strict";
        function resolve(value) {
          if (value && typeof value === 'object' && value.constructor === this) {
            return value;
          }
          var Promise = this;
          return new Promise(function(resolve) {
            resolve(value);
          });
        }
        __exports__.resolve = resolve;
      });
      define("promise/utils", ["exports"], function(__exports__) {
        "use strict";
        function objectOrFunction(x) {
          return isFunction(x) || (typeof x === "object" && x !== null);
        }
        function isFunction(x) {
          return typeof x === "function";
        }
        function isArray(x) {
          return Object.prototype.toString.call(x) === "[object Array]";
        }
        var now = Date.now || function() {
          return new Date().getTime();
        };
        __exports__.objectOrFunction = objectOrFunction;
        __exports__.isFunction = isFunction;
        __exports__.isArray = isArray;
        __exports__.now = now;
      });
      requireModule('promise/polyfill').polyfill();
    }());
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
      else if (typeof define === 'function' && define.amd)
        define([], factory);
      else if (typeof exports === 'object')
        exports["localforage"] = factory();
      else
        root["localforage"] = factory();
    })(this, function() {
      return (function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
          };
          modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
          module.loaded = true;
          return module.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      })([function(module, exports, __webpack_require__) {
        'use strict';
        exports.__esModule = true;
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
          }
        }
        var localForage = (function(globalObject) {
          'use strict';
          var CustomDrivers = {};
          var DriverType = {
            INDEXEDDB: 'asyncStorage',
            LOCALSTORAGE: 'localStorageWrapper',
            WEBSQL: 'webSQLStorage'
          };
          var DefaultDriverOrder = [DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE];
          var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];
          var DefaultConfig = {
            description: '',
            driver: DefaultDriverOrder.slice(),
            name: 'localforage',
            size: 4980736,
            storeName: 'keyvaluepairs',
            version: 1.0
          };
          var driverSupport = (function(self) {
            var result = {};
            result[DriverType.INDEXEDDB] = !!(function() {
              try {
                var indexedDB = indexedDB || self.indexedDB || self.webkitIndexedDB || self.mozIndexedDB || self.OIndexedDB || self.msIndexedDB;
                if (typeof self.openDatabase !== 'undefined' && self.navigator && self.navigator.userAgent && /Safari/.test(self.navigator.userAgent) && !/Chrome/.test(self.navigator.userAgent)) {
                  return false;
                }
                return indexedDB && typeof indexedDB.open === 'function' && typeof self.IDBKeyRange !== 'undefined';
              } catch (e) {
                return false;
              }
            })();
            result[DriverType.WEBSQL] = !!(function() {
              try {
                return self.openDatabase;
              } catch (e) {
                return false;
              }
            })();
            result[DriverType.LOCALSTORAGE] = !!(function() {
              try {
                return self.localStorage && 'setItem' in self.localStorage && self.localStorage.setItem;
              } catch (e) {
                return false;
              }
            })();
            return result;
          })(globalObject);
          var isArray = Array.isArray || function(arg) {
            return Object.prototype.toString.call(arg) === '[object Array]';
          };
          function callWhenReady(localForageInstance, libraryMethod) {
            localForageInstance[libraryMethod] = function() {
              var _args = arguments;
              return localForageInstance.ready().then(function() {
                return localForageInstance[libraryMethod].apply(localForageInstance, _args);
              });
            };
          }
          function extend() {
            for (var i = 1; i < arguments.length; i++) {
              var arg = arguments[i];
              if (arg) {
                for (var key in arg) {
                  if (arg.hasOwnProperty(key)) {
                    if (isArray(arg[key])) {
                      arguments[0][key] = arg[key].slice();
                    } else {
                      arguments[0][key] = arg[key];
                    }
                  }
                }
              }
            }
            return arguments[0];
          }
          function isLibraryDriver(driverName) {
            for (var driver in DriverType) {
              if (DriverType.hasOwnProperty(driver) && DriverType[driver] === driverName) {
                return true;
              }
            }
            return false;
          }
          var LocalForage = (function() {
            function LocalForage(options) {
              _classCallCheck(this, LocalForage);
              this.INDEXEDDB = DriverType.INDEXEDDB;
              this.LOCALSTORAGE = DriverType.LOCALSTORAGE;
              this.WEBSQL = DriverType.WEBSQL;
              this._defaultConfig = extend({}, DefaultConfig);
              this._config = extend({}, this._defaultConfig, options);
              this._driverSet = null;
              this._initDriver = null;
              this._ready = false;
              this._dbInfo = null;
              this._wrapLibraryMethodsWithReady();
              this.setDriver(this._config.driver);
            }
            LocalForage.prototype.config = function config(options) {
              if (typeof options === 'object') {
                if (this._ready) {
                  return new Error("Can't call config() after localforage " + 'has been used.');
                }
                for (var i in options) {
                  if (i === 'storeName') {
                    options[i] = options[i].replace(/\W/g, '_');
                  }
                  this._config[i] = options[i];
                }
                if ('driver' in options && options.driver) {
                  this.setDriver(this._config.driver);
                }
                return true;
              } else if (typeof options === 'string') {
                return this._config[options];
              } else {
                return this._config;
              }
            };
            LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
              var promise = new Promise(function(resolve, reject) {
                try {
                  var driverName = driverObject._driver;
                  var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');
                  var namingError = new Error('Custom driver name already in use: ' + driverObject._driver);
                  if (!driverObject._driver) {
                    reject(complianceError);
                    return;
                  }
                  if (isLibraryDriver(driverObject._driver)) {
                    reject(namingError);
                    return;
                  }
                  var customDriverMethods = LibraryMethods.concat('_initStorage');
                  for (var i = 0; i < customDriverMethods.length; i++) {
                    var customDriverMethod = customDriverMethods[i];
                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {
                      reject(complianceError);
                      return;
                    }
                  }
                  var supportPromise = Promise.resolve(true);
                  if ('_support' in driverObject) {
                    if (driverObject._support && typeof driverObject._support === 'function') {
                      supportPromise = driverObject._support();
                    } else {
                      supportPromise = Promise.resolve(!!driverObject._support);
                    }
                  }
                  supportPromise.then(function(supportResult) {
                    driverSupport[driverName] = supportResult;
                    CustomDrivers[driverName] = driverObject;
                    resolve();
                  }, reject);
                } catch (e) {
                  reject(e);
                }
              });
              promise.then(callback, errorCallback);
              return promise;
            };
            LocalForage.prototype.driver = function driver() {
              return this._driver || null;
            };
            LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
              var self = this;
              var getDriverPromise = (function() {
                if (isLibraryDriver(driverName)) {
                  switch (driverName) {
                    case self.INDEXEDDB:
                      return new Promise(function(resolve, reject) {
                        resolve(__webpack_require__(1));
                      });
                    case self.LOCALSTORAGE:
                      return new Promise(function(resolve, reject) {
                        resolve(__webpack_require__(2));
                      });
                    case self.WEBSQL:
                      return new Promise(function(resolve, reject) {
                        resolve(__webpack_require__(4));
                      });
                  }
                } else if (CustomDrivers[driverName]) {
                  return Promise.resolve(CustomDrivers[driverName]);
                }
                return Promise.reject(new Error('Driver not found.'));
              })();
              getDriverPromise.then(callback, errorCallback);
              return getDriverPromise;
            };
            LocalForage.prototype.getSerializer = function getSerializer(callback) {
              var serializerPromise = new Promise(function(resolve, reject) {
                resolve(__webpack_require__(3));
              });
              if (callback && typeof callback === 'function') {
                serializerPromise.then(function(result) {
                  callback(result);
                });
              }
              return serializerPromise;
            };
            LocalForage.prototype.ready = function ready(callback) {
              var self = this;
              var promise = self._driverSet.then(function() {
                if (self._ready === null) {
                  self._ready = self._initDriver();
                }
                return self._ready;
              });
              promise.then(callback, callback);
              return promise;
            };
            LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
              var self = this;
              if (!isArray(drivers)) {
                drivers = [drivers];
              }
              var supportedDrivers = this._getSupportedDrivers(drivers);
              function setDriverToConfig() {
                self._config.driver = self.driver();
              }
              function initDriver(supportedDrivers) {
                return function() {
                  var currentDriverIndex = 0;
                  function driverPromiseLoop() {
                    while (currentDriverIndex < supportedDrivers.length) {
                      var driverName = supportedDrivers[currentDriverIndex];
                      currentDriverIndex++;
                      self._dbInfo = null;
                      self._ready = null;
                      return self.getDriver(driverName).then(function(driver) {
                        self._extend(driver);
                        setDriverToConfig();
                        self._ready = self._initStorage(self._config);
                        return self._ready;
                      })['catch'](driverPromiseLoop);
                    }
                    setDriverToConfig();
                    var error = new Error('No available storage method found.');
                    self._driverSet = Promise.reject(error);
                    return self._driverSet;
                  }
                  return driverPromiseLoop();
                };
              }
              var oldDriverSetDone = this._driverSet !== null ? this._driverSet['catch'](function() {
                return Promise.resolve();
              }) : Promise.resolve();
              this._driverSet = oldDriverSetDone.then(function() {
                var driverName = supportedDrivers[0];
                self._dbInfo = null;
                self._ready = null;
                return self.getDriver(driverName).then(function(driver) {
                  self._driver = driver._driver;
                  setDriverToConfig();
                  self._wrapLibraryMethodsWithReady();
                  self._initDriver = initDriver(supportedDrivers);
                });
              })['catch'](function() {
                setDriverToConfig();
                var error = new Error('No available storage method found.');
                self._driverSet = Promise.reject(error);
                return self._driverSet;
              });
              this._driverSet.then(callback, errorCallback);
              return this._driverSet;
            };
            LocalForage.prototype.supports = function supports(driverName) {
              return !!driverSupport[driverName];
            };
            LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
              extend(this, libraryMethodsAndProperties);
            };
            LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
              var supportedDrivers = [];
              for (var i = 0,
                  len = drivers.length; i < len; i++) {
                var driverName = drivers[i];
                if (this.supports(driverName)) {
                  supportedDrivers.push(driverName);
                }
              }
              return supportedDrivers;
            };
            LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
              for (var i = 0; i < LibraryMethods.length; i++) {
                callWhenReady(this, LibraryMethods[i]);
              }
            };
            LocalForage.prototype.createInstance = function createInstance(options) {
              return new LocalForage(options);
            };
            return LocalForage;
          })();
          return new LocalForage();
        })(typeof window !== 'undefined' ? window : self);
        exports['default'] = localForage;
        module.exports = exports['default'];
      }, function(module, exports) {
        'use strict';
        exports.__esModule = true;
        var asyncStorage = (function(globalObject) {
          'use strict';
          var indexedDB = indexedDB || globalObject.indexedDB || globalObject.webkitIndexedDB || globalObject.mozIndexedDB || globalObject.OIndexedDB || globalObject.msIndexedDB;
          if (!indexedDB) {
            return;
          }
          var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
          var supportsBlobs;
          var dbContexts;
          function _createBlob(parts, properties) {
            parts = parts || [];
            properties = properties || {};
            try {
              return new Blob(parts, properties);
            } catch (e) {
              if (e.name !== 'TypeError') {
                throw e;
              }
              var BlobBuilder = globalObject.BlobBuilder || globalObject.MSBlobBuilder || globalObject.MozBlobBuilder || globalObject.WebKitBlobBuilder;
              var builder = new BlobBuilder();
              for (var i = 0; i < parts.length; i += 1) {
                builder.append(parts[i]);
              }
              return builder.getBlob(properties.type);
            }
          }
          function _binStringToArrayBuffer(bin) {
            var length = bin.length;
            var buf = new ArrayBuffer(length);
            var arr = new Uint8Array(buf);
            for (var i = 0; i < length; i++) {
              arr[i] = bin.charCodeAt(i);
            }
            return buf;
          }
          function _blobAjax(url) {
            return new Promise(function(resolve, reject) {
              var xhr = new XMLHttpRequest();
              xhr.open('GET', url);
              xhr.withCredentials = true;
              xhr.responseType = 'arraybuffer';
              xhr.onreadystatechange = function() {
                if (xhr.readyState !== 4) {
                  return;
                }
                if (xhr.status === 200) {
                  return resolve({
                    response: xhr.response,
                    type: xhr.getResponseHeader('Content-Type')
                  });
                }
                reject({
                  status: xhr.status,
                  response: xhr.response
                });
              };
              xhr.send();
            });
          }
          function _checkBlobSupportWithoutCaching(idb) {
            return new Promise(function(resolve, reject) {
              var blob = _createBlob([''], {type: 'image/png'});
              var txn = idb.transaction([DETECT_BLOB_SUPPORT_STORE], 'readwrite');
              txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');
              txn.oncomplete = function() {
                var blobTxn = idb.transaction([DETECT_BLOB_SUPPORT_STORE], 'readwrite');
                var getBlobReq = blobTxn.objectStore(DETECT_BLOB_SUPPORT_STORE).get('key');
                getBlobReq.onerror = reject;
                getBlobReq.onsuccess = function(e) {
                  var storedBlob = e.target.result;
                  var url = URL.createObjectURL(storedBlob);
                  _blobAjax(url).then(function(res) {
                    resolve(!!(res && res.type === 'image/png'));
                  }, function() {
                    resolve(false);
                  }).then(function() {
                    URL.revokeObjectURL(url);
                  });
                };
              };
              txn.onerror = txn.onabort = reject;
            })['catch'](function() {
              return false;
            });
          }
          function _checkBlobSupport(idb) {
            if (typeof supportsBlobs === 'boolean') {
              return Promise.resolve(supportsBlobs);
            }
            return _checkBlobSupportWithoutCaching(idb).then(function(value) {
              supportsBlobs = value;
              return supportsBlobs;
            });
          }
          function _encodeBlob(blob) {
            return new Promise(function(resolve, reject) {
              var reader = new FileReader();
              reader.onerror = reject;
              reader.onloadend = function(e) {
                var base64 = btoa(e.target.result || '');
                resolve({
                  __local_forage_encoded_blob: true,
                  data: base64,
                  type: blob.type
                });
              };
              reader.readAsBinaryString(blob);
            });
          }
          function _decodeBlob(encodedBlob) {
            var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
            return _createBlob([arrayBuff], {type: encodedBlob.type});
          }
          function _isEncodedBlob(value) {
            return value && value.__local_forage_encoded_blob;
          }
          function _fullyReady(callback) {
            var self = this;
            var promise = self._initReady().then(function() {
              var dbContext = dbContexts[self._dbInfo.name];
              if (dbContext && dbContext.dbReady) {
                return dbContext.dbReady;
              }
            });
            promise.then(callback, callback);
            return promise;
          }
          function _deferReadiness(dbInfo) {
            var dbContext = dbContexts[dbInfo.name];
            var deferredOperation = {};
            deferredOperation.promise = new Promise(function(resolve) {
              deferredOperation.resolve = resolve;
            });
            dbContext.deferredOperations.push(deferredOperation);
            if (!dbContext.dbReady) {
              dbContext.dbReady = deferredOperation.promise;
            } else {
              dbContext.dbReady = dbContext.dbReady.then(function() {
                return deferredOperation.promise;
              });
            }
          }
          function _advanceReadiness(dbInfo) {
            var dbContext = dbContexts[dbInfo.name];
            var deferredOperation = dbContext.deferredOperations.pop();
            if (deferredOperation) {
              deferredOperation.resolve();
            }
          }
          function _initStorage(options) {
            var self = this;
            var dbInfo = {db: null};
            if (options) {
              for (var i in options) {
                dbInfo[i] = options[i];
              }
            }
            if (!dbContexts) {
              dbContexts = {};
            }
            var dbContext = dbContexts[dbInfo.name];
            if (!dbContext) {
              dbContext = {
                forages: [],
                db: null,
                dbReady: null,
                deferredOperations: []
              };
              dbContexts[dbInfo.name] = dbContext;
            }
            dbContext.forages.push(self);
            if (!self._initReady) {
              self._initReady = self.ready;
              self.ready = _fullyReady;
            }
            var initPromises = [];
            function ignoreErrors() {
              return Promise.resolve();
            }
            for (var j = 0; j < dbContext.forages.length; j++) {
              var forage = dbContext.forages[j];
              if (forage !== self) {
                initPromises.push(forage._initReady()['catch'](ignoreErrors));
              }
            }
            var forages = dbContext.forages.slice(0);
            return Promise.all(initPromises).then(function() {
              dbInfo.db = dbContext.db;
              return _getOriginalConnection(dbInfo);
            }).then(function(db) {
              dbInfo.db = db;
              if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
                return _getUpgradedConnection(dbInfo);
              }
              return db;
            }).then(function(db) {
              dbInfo.db = dbContext.db = db;
              self._dbInfo = dbInfo;
              for (var k = 0; k < forages.length; k++) {
                var forage = forages[k];
                if (forage !== self) {
                  forage._dbInfo.db = dbInfo.db;
                  forage._dbInfo.version = dbInfo.version;
                }
              }
            });
          }
          function _getOriginalConnection(dbInfo) {
            return _getConnection(dbInfo, false);
          }
          function _getUpgradedConnection(dbInfo) {
            return _getConnection(dbInfo, true);
          }
          function _getConnection(dbInfo, upgradeNeeded) {
            return new Promise(function(resolve, reject) {
              if (dbInfo.db) {
                if (upgradeNeeded) {
                  _deferReadiness(dbInfo);
                  dbInfo.db.close();
                } else {
                  return resolve(dbInfo.db);
                }
              }
              var dbArgs = [dbInfo.name];
              if (upgradeNeeded) {
                dbArgs.push(dbInfo.version);
              }
              var openreq = indexedDB.open.apply(indexedDB, dbArgs);
              if (upgradeNeeded) {
                openreq.onupgradeneeded = function(e) {
                  var db = openreq.result;
                  try {
                    db.createObjectStore(dbInfo.storeName);
                    if (e.oldVersion <= 1) {
                      db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                    }
                  } catch (ex) {
                    if (ex.name === 'ConstraintError') {
                      globalObject.console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                    } else {
                      throw ex;
                    }
                  }
                };
              }
              openreq.onerror = function() {
                reject(openreq.error);
              };
              openreq.onsuccess = function() {
                resolve(openreq.result);
                _advanceReadiness(dbInfo);
              };
            });
          }
          function _isUpgradeNeeded(dbInfo, defaultVersion) {
            if (!dbInfo.db) {
              return true;
            }
            var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
            var isDowngrade = dbInfo.version < dbInfo.db.version;
            var isUpgrade = dbInfo.version > dbInfo.db.version;
            if (isDowngrade) {
              if (dbInfo.version !== defaultVersion) {
                globalObject.console.warn('The database "' + dbInfo.name + '"' + ' can\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
              }
              dbInfo.version = dbInfo.db.version;
            }
            if (isUpgrade || isNewStore) {
              if (isNewStore) {
                var incVersion = dbInfo.db.version + 1;
                if (incVersion > dbInfo.version) {
                  dbInfo.version = incVersion;
                }
              }
              return true;
            }
            return false;
          }
          function getItem(key, callback) {
            var self = this;
            if (typeof key !== 'string') {
              globalObject.console.warn(key + ' used as a key, but it is not a string.');
              key = String(key);
            }
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
                var req = store.get(key);
                req.onsuccess = function() {
                  var value = req.result;
                  if (value === undefined) {
                    value = null;
                  }
                  if (_isEncodedBlob(value)) {
                    value = _decodeBlob(value);
                  }
                  resolve(value);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function iterate(iterator, callback) {
            var self = this;
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
                var req = store.openCursor();
                var iterationNumber = 1;
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (cursor) {
                    var value = cursor.value;
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    var result = iterator(value, cursor.key, iterationNumber++);
                    if (result !== void 0) {
                      resolve(result);
                    } else {
                      cursor['continue']();
                    }
                  } else {
                    resolve();
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function setItem(key, value, callback) {
            var self = this;
            if (typeof key !== 'string') {
              globalObject.console.warn(key + ' used as a key, but it is not a string.');
              key = String(key);
            }
            var promise = new Promise(function(resolve, reject) {
              var dbInfo;
              self.ready().then(function() {
                dbInfo = self._dbInfo;
                if (value instanceof Blob) {
                  return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                    if (blobSupport) {
                      return value;
                    }
                    return _encodeBlob(value);
                  });
                }
                return value;
              }).then(function(value) {
                var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
                var store = transaction.objectStore(dbInfo.storeName);
                if (value === null) {
                  value = undefined;
                }
                transaction.oncomplete = function() {
                  if (value === undefined) {
                    value = null;
                  }
                  resolve(value);
                };
                transaction.onabort = transaction.onerror = function() {
                  var err = req.error ? req.error : req.transaction.error;
                  reject(err);
                };
                var req = store.put(value, key);
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function removeItem(key, callback) {
            var self = this;
            if (typeof key !== 'string') {
              globalObject.console.warn(key + ' used as a key, but it is not a string.');
              key = String(key);
            }
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
                var store = transaction.objectStore(dbInfo.storeName);
                var req = store['delete'](key);
                transaction.oncomplete = function() {
                  resolve();
                };
                transaction.onerror = function() {
                  reject(req.error);
                };
                transaction.onabort = function() {
                  var err = req.error ? req.error : req.transaction.error;
                  reject(err);
                };
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function clear(callback) {
            var self = this;
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');
                var store = transaction.objectStore(dbInfo.storeName);
                var req = store.clear();
                transaction.oncomplete = function() {
                  resolve();
                };
                transaction.onabort = transaction.onerror = function() {
                  var err = req.error ? req.error : req.transaction.error;
                  reject(err);
                };
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function length(callback) {
            var self = this;
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
                var req = store.count();
                req.onsuccess = function() {
                  resolve(req.result);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function key(n, callback) {
            var self = this;
            var promise = new Promise(function(resolve, reject) {
              if (n < 0) {
                resolve(null);
                return;
              }
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
                var advanced = false;
                var req = store.openCursor();
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve(null);
                    return;
                  }
                  if (n === 0) {
                    resolve(cursor.key);
                  } else {
                    if (!advanced) {
                      advanced = true;
                      cursor.advance(n);
                    } else {
                      resolve(cursor.key);
                    }
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function keys(callback) {
            var self = this;
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);
                var req = store.openCursor();
                var keys = [];
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve(keys);
                    return;
                  }
                  keys.push(cursor.key);
                  cursor['continue']();
                };
                req.onerror = function() {
                  reject(req.error);
                };
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function executeCallback(promise, callback) {
            if (callback) {
              promise.then(function(result) {
                callback(null, result);
              }, function(error) {
                callback(error);
              });
            }
          }
          var asyncStorage = {
            _driver: 'asyncStorage',
            _initStorage: _initStorage,
            iterate: iterate,
            getItem: getItem,
            setItem: setItem,
            removeItem: removeItem,
            clear: clear,
            length: length,
            key: key,
            keys: keys
          };
          return asyncStorage;
        })(typeof window !== 'undefined' ? window : self);
        exports['default'] = asyncStorage;
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        exports.__esModule = true;
        var localStorageWrapper = (function(globalObject) {
          'use strict';
          var localStorage = null;
          try {
            if (!globalObject.localStorage || !('setItem' in globalObject.localStorage)) {
              return;
            }
            localStorage = globalObject.localStorage;
          } catch (e) {
            return;
          }
          function _initStorage(options) {
            var self = this;
            var dbInfo = {};
            if (options) {
              for (var i in options) {
                dbInfo[i] = options[i];
              }
            }
            dbInfo.keyPrefix = dbInfo.name + '/';
            if (dbInfo.storeName !== self._defaultConfig.storeName) {
              dbInfo.keyPrefix += dbInfo.storeName + '/';
            }
            self._dbInfo = dbInfo;
            return new Promise(function(resolve, reject) {
              resolve(__webpack_require__(3));
            }).then(function(lib) {
              dbInfo.serializer = lib;
              return Promise.resolve();
            });
          }
          function clear(callback) {
            var self = this;
            var promise = self.ready().then(function() {
              var keyPrefix = self._dbInfo.keyPrefix;
              for (var i = localStorage.length - 1; i >= 0; i--) {
                var key = localStorage.key(i);
                if (key.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key);
                }
              }
            });
            executeCallback(promise, callback);
            return promise;
          }
          function getItem(key, callback) {
            var self = this;
            if (typeof key !== 'string') {
              globalObject.console.warn(key + ' used as a key, but it is not a string.');
              key = String(key);
            }
            var promise = self.ready().then(function() {
              var dbInfo = self._dbInfo;
              var result = localStorage.getItem(dbInfo.keyPrefix + key);
              if (result) {
                result = dbInfo.serializer.deserialize(result);
              }
              return result;
            });
            executeCallback(promise, callback);
            return promise;
          }
          function iterate(iterator, callback) {
            var self = this;
            var promise = self.ready().then(function() {
              var dbInfo = self._dbInfo;
              var keyPrefix = dbInfo.keyPrefix;
              var keyPrefixLength = keyPrefix.length;
              var length = localStorage.length;
              var iterationNumber = 1;
              for (var i = 0; i < length; i++) {
                var key = localStorage.key(i);
                if (key.indexOf(keyPrefix) !== 0) {
                  continue;
                }
                var value = localStorage.getItem(key);
                if (value) {
                  value = dbInfo.serializer.deserialize(value);
                }
                value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);
                if (value !== void 0) {
                  return value;
                }
              }
            });
            executeCallback(promise, callback);
            return promise;
          }
          function key(n, callback) {
            var self = this;
            var promise = self.ready().then(function() {
              var dbInfo = self._dbInfo;
              var result;
              try {
                result = localStorage.key(n);
              } catch (error) {
                result = null;
              }
              if (result) {
                result = result.substring(dbInfo.keyPrefix.length);
              }
              return result;
            });
            executeCallback(promise, callback);
            return promise;
          }
          function keys(callback) {
            var self = this;
            var promise = self.ready().then(function() {
              var dbInfo = self._dbInfo;
              var length = localStorage.length;
              var keys = [];
              for (var i = 0; i < length; i++) {
                if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {
                  keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));
                }
              }
              return keys;
            });
            executeCallback(promise, callback);
            return promise;
          }
          function length(callback) {
            var self = this;
            var promise = self.keys().then(function(keys) {
              return keys.length;
            });
            executeCallback(promise, callback);
            return promise;
          }
          function removeItem(key, callback) {
            var self = this;
            if (typeof key !== 'string') {
              globalObject.console.warn(key + ' used as a key, but it is not a string.');
              key = String(key);
            }
            var promise = self.ready().then(function() {
              var dbInfo = self._dbInfo;
              localStorage.removeItem(dbInfo.keyPrefix + key);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function setItem(key, value, callback) {
            var self = this;
            if (typeof key !== 'string') {
              globalObject.console.warn(key + ' used as a key, but it is not a string.');
              key = String(key);
            }
            var promise = self.ready().then(function() {
              if (value === undefined) {
                value = null;
              }
              var originalValue = value;
              return new Promise(function(resolve, reject) {
                var dbInfo = self._dbInfo;
                dbInfo.serializer.serialize(value, function(value, error) {
                  if (error) {
                    reject(error);
                  } else {
                    try {
                      localStorage.setItem(dbInfo.keyPrefix + key, value);
                      resolve(originalValue);
                    } catch (e) {
                      if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                        reject(e);
                      }
                      reject(e);
                    }
                  }
                });
              });
            });
            executeCallback(promise, callback);
            return promise;
          }
          function executeCallback(promise, callback) {
            if (callback) {
              promise.then(function(result) {
                callback(null, result);
              }, function(error) {
                callback(error);
              });
            }
          }
          var localStorageWrapper = {
            _driver: 'localStorageWrapper',
            _initStorage: _initStorage,
            iterate: iterate,
            getItem: getItem,
            setItem: setItem,
            removeItem: removeItem,
            clear: clear,
            length: length,
            key: key,
            keys: keys
          };
          return localStorageWrapper;
        })(typeof window !== 'undefined' ? window : self);
        exports['default'] = localStorageWrapper;
        module.exports = exports['default'];
      }, function(module, exports) {
        'use strict';
        exports.__esModule = true;
        var localforageSerializer = (function(globalObject) {
          'use strict';
          var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
          var BLOB_TYPE_PREFIX = '~~local_forage_type~';
          var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
          var SERIALIZED_MARKER = '__lfsc__:';
          var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
          var TYPE_ARRAYBUFFER = 'arbf';
          var TYPE_BLOB = 'blob';
          var TYPE_INT8ARRAY = 'si08';
          var TYPE_UINT8ARRAY = 'ui08';
          var TYPE_UINT8CLAMPEDARRAY = 'uic8';
          var TYPE_INT16ARRAY = 'si16';
          var TYPE_INT32ARRAY = 'si32';
          var TYPE_UINT16ARRAY = 'ur16';
          var TYPE_UINT32ARRAY = 'ui32';
          var TYPE_FLOAT32ARRAY = 'fl32';
          var TYPE_FLOAT64ARRAY = 'fl64';
          var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
          function _createBlob(parts, properties) {
            parts = parts || [];
            properties = properties || {};
            try {
              return new Blob(parts, properties);
            } catch (err) {
              if (err.name !== 'TypeError') {
                throw err;
              }
              var BlobBuilder = globalObject.BlobBuilder || globalObject.MSBlobBuilder || globalObject.MozBlobBuilder || globalObject.WebKitBlobBuilder;
              var builder = new BlobBuilder();
              for (var i = 0; i < parts.length; i += 1) {
                builder.append(parts[i]);
              }
              return builder.getBlob(properties.type);
            }
          }
          function serialize(value, callback) {
            var valueString = '';
            if (value) {
              valueString = value.toString();
            }
            if (value && (value.toString() === '[object ArrayBuffer]' || value.buffer && value.buffer.toString() === '[object ArrayBuffer]')) {
              var buffer;
              var marker = SERIALIZED_MARKER;
              if (value instanceof ArrayBuffer) {
                buffer = value;
                marker += TYPE_ARRAYBUFFER;
              } else {
                buffer = value.buffer;
                if (valueString === '[object Int8Array]') {
                  marker += TYPE_INT8ARRAY;
                } else if (valueString === '[object Uint8Array]') {
                  marker += TYPE_UINT8ARRAY;
                } else if (valueString === '[object Uint8ClampedArray]') {
                  marker += TYPE_UINT8CLAMPEDARRAY;
                } else if (valueString === '[object Int16Array]') {
                  marker += TYPE_INT16ARRAY;
                } else if (valueString === '[object Uint16Array]') {
                  marker += TYPE_UINT16ARRAY;
                } else if (valueString === '[object Int32Array]') {
                  marker += TYPE_INT32ARRAY;
                } else if (valueString === '[object Uint32Array]') {
                  marker += TYPE_UINT32ARRAY;
                } else if (valueString === '[object Float32Array]') {
                  marker += TYPE_FLOAT32ARRAY;
                } else if (valueString === '[object Float64Array]') {
                  marker += TYPE_FLOAT64ARRAY;
                } else {
                  callback(new Error('Failed to get type for BinaryArray'));
                }
              }
              callback(marker + bufferToString(buffer));
            } else if (valueString === '[object Blob]') {
              var fileReader = new FileReader();
              fileReader.onload = function() {
                var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);
                callback(SERIALIZED_MARKER + TYPE_BLOB + str);
              };
              fileReader.readAsArrayBuffer(value);
            } else {
              try {
                callback(JSON.stringify(value));
              } catch (e) {
                console.error("Couldn't convert value into a JSON string: ", value);
                callback(null, e);
              }
            }
          }
          function deserialize(value) {
            if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
              return JSON.parse(value);
            }
            var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
            var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
            var blobType;
            if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
              var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
              blobType = matcher[1];
              serializedString = serializedString.substring(matcher[0].length);
            }
            var buffer = stringToBuffer(serializedString);
            switch (type) {
              case TYPE_ARRAYBUFFER:
                return buffer;
              case TYPE_BLOB:
                return _createBlob([buffer], {type: blobType});
              case TYPE_INT8ARRAY:
                return new Int8Array(buffer);
              case TYPE_UINT8ARRAY:
                return new Uint8Array(buffer);
              case TYPE_UINT8CLAMPEDARRAY:
                return new Uint8ClampedArray(buffer);
              case TYPE_INT16ARRAY:
                return new Int16Array(buffer);
              case TYPE_UINT16ARRAY:
                return new Uint16Array(buffer);
              case TYPE_INT32ARRAY:
                return new Int32Array(buffer);
              case TYPE_UINT32ARRAY:
                return new Uint32Array(buffer);
              case TYPE_FLOAT32ARRAY:
                return new Float32Array(buffer);
              case TYPE_FLOAT64ARRAY:
                return new Float64Array(buffer);
              default:
                throw new Error('Unkown type: ' + type);
            }
          }
          function stringToBuffer(serializedString) {
            var bufferLength = serializedString.length * 0.75;
            var len = serializedString.length;
            var i;
            var p = 0;
            var encoded1,
                encoded2,
                encoded3,
                encoded4;
            if (serializedString[serializedString.length - 1] === '=') {
              bufferLength--;
              if (serializedString[serializedString.length - 2] === '=') {
                bufferLength--;
              }
            }
            var buffer = new ArrayBuffer(bufferLength);
            var bytes = new Uint8Array(buffer);
            for (i = 0; i < len; i += 4) {
              encoded1 = BASE_CHARS.indexOf(serializedString[i]);
              encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
              encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
              encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
              bytes[p++] = encoded1 << 2 | encoded2 >> 4;
              bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
              bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
            }
            return buffer;
          }
          function bufferToString(buffer) {
            var bytes = new Uint8Array(buffer);
            var base64String = '';
            var i;
            for (i = 0; i < bytes.length; i += 3) {
              base64String += BASE_CHARS[bytes[i] >> 2];
              base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
              base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
              base64String += BASE_CHARS[bytes[i + 2] & 63];
            }
            if (bytes.length % 3 === 2) {
              base64String = base64String.substring(0, base64String.length - 1) + '=';
            } else if (bytes.length % 3 === 1) {
              base64String = base64String.substring(0, base64String.length - 2) + '==';
            }
            return base64String;
          }
          var localforageSerializer = {
            serialize: serialize,
            deserialize: deserialize,
            stringToBuffer: stringToBuffer,
            bufferToString: bufferToString
          };
          return localforageSerializer;
        })(typeof window !== 'undefined' ? window : self);
        exports['default'] = localforageSerializer;
        module.exports = exports['default'];
      }, function(module, exports, __webpack_require__) {
        'use strict';
        exports.__esModule = true;
        var webSQLStorage = (function(globalObject) {
          'use strict';
          var openDatabase = globalObject.openDatabase;
          if (!openDatabase) {
            return;
          }
          function _initStorage(options) {
            var self = this;
            var dbInfo = {db: null};
            if (options) {
              for (var i in options) {
                dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
              }
            }
            var dbInfoPromise = new Promise(function(resolve, reject) {
              try {
                dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
              } catch (e) {
                return reject(e);
              }
              dbInfo.db.transaction(function(t) {
                t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function() {
                  self._dbInfo = dbInfo;
                  resolve();
                }, function(t, error) {
                  reject(error);
                });
              });
            });
            return new Promise(function(resolve, reject) {
              resolve(__webpack_require__(3));
            }).then(function(lib) {
              dbInfo.serializer = lib;
              return dbInfoPromise;
            });
          }
          function getItem(key, callback) {
            var self = this;
            if (typeof key !== 'string') {
              globalObject.console.warn(key + ' used as a key, but it is not a string.');
              key = String(key);
            }
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                  t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function(t, results) {
                    var result = results.rows.length ? results.rows.item(0).value : null;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    resolve(result);
                  }, function(t, error) {
                    reject(error);
                  });
                });
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function iterate(iterator, callback) {
            var self = this;
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                  t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function(t, results) {
                    var rows = results.rows;
                    var length = rows.length;
                    for (var i = 0; i < length; i++) {
                      var item = rows.item(i);
                      var result = item.value;
                      if (result) {
                        result = dbInfo.serializer.deserialize(result);
                      }
                      result = iterator(result, item.key, i + 1);
                      if (result !== void 0) {
                        resolve(result);
                        return;
                      }
                    }
                    resolve();
                  }, function(t, error) {
                    reject(error);
                  });
                });
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function setItem(key, value, callback) {
            var self = this;
            if (typeof key !== 'string') {
              globalObject.console.warn(key + ' used as a key, but it is not a string.');
              key = String(key);
            }
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                if (value === undefined) {
                  value = null;
                }
                var originalValue = value;
                var dbInfo = self._dbInfo;
                dbInfo.serializer.serialize(value, function(value, error) {
                  if (error) {
                    reject(error);
                  } else {
                    dbInfo.db.transaction(function(t) {
                      t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function() {
                        resolve(originalValue);
                      }, function(t, error) {
                        reject(error);
                      });
                    }, function(sqlError) {
                      if (sqlError.code === sqlError.QUOTA_ERR) {
                        reject(sqlError);
                      }
                    });
                  }
                });
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function removeItem(key, callback) {
            var self = this;
            if (typeof key !== 'string') {
              globalObject.console.warn(key + ' used as a key, but it is not a string.');
              key = String(key);
            }
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                  t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function() {
                    resolve();
                  }, function(t, error) {
                    reject(error);
                  });
                });
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function clear(callback) {
            var self = this;
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                  t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function() {
                    resolve();
                  }, function(t, error) {
                    reject(error);
                  });
                });
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function length(callback) {
            var self = this;
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                  t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function(t, results) {
                    var result = results.rows.item(0).c;
                    resolve(result);
                  }, function(t, error) {
                    reject(error);
                  });
                });
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function key(n, callback) {
            var self = this;
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                  t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function(t, results) {
                    var result = results.rows.length ? results.rows.item(0).key : null;
                    resolve(result);
                  }, function(t, error) {
                    reject(error);
                  });
                });
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function keys(callback) {
            var self = this;
            var promise = new Promise(function(resolve, reject) {
              self.ready().then(function() {
                var dbInfo = self._dbInfo;
                dbInfo.db.transaction(function(t) {
                  t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function(t, results) {
                    var keys = [];
                    for (var i = 0; i < results.rows.length; i++) {
                      keys.push(results.rows.item(i).key);
                    }
                    resolve(keys);
                  }, function(t, error) {
                    reject(error);
                  });
                });
              })['catch'](reject);
            });
            executeCallback(promise, callback);
            return promise;
          }
          function executeCallback(promise, callback) {
            if (callback) {
              promise.then(function(result) {
                callback(null, result);
              }, function(error) {
                callback(error);
              });
            }
          }
          var webSQLStorage = {
            _driver: 'webSQLStorage',
            _initStorage: _initStorage,
            iterate: iterate,
            getItem: getItem,
            setItem: setItem,
            removeItem: removeItem,
            clear: clear,
            length: length,
            key: key,
            keys: keys
          };
          return webSQLStorage;
        })(typeof window !== 'undefined' ? window : self);
        exports['default'] = webSQLStorage;
        module.exports = exports['default'];
      }]);
    });
    ;
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  return module.exports;
});

System.registerDynamic("npm:localforage@1.4.0.js", ["npm:localforage@1.4.0/dist/localforage.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:localforage@1.4.0/dist/localforage.js');
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/zlib/trees.js", ["npm:pako@1.0.1/lib/utils/common.js", "github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    'use strict';
    var utils = $__require('npm:pako@1.0.1/lib/utils/common.js');
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = (w) & 0xff;
      s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > (Buf_size - length)) {
        s.bi_buf |= (value << s.bi_valid) & 0xffff;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> (Buf_size - s.bi_valid);
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= (value << s.bi_valid) & 0xffff;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n,
          m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1 << extra_lbits[code]); n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1 << extra_dbits[code]); n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return (tree[_n2] < tree[_m2] || (tree[_n2] === tree[_m2] && depth[n] <= depth[m]));
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n,
          m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = (s.heap_len >> 1); n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 0xffff;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 0xf3ffc07f;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if ((black_mask & 1) && (s.dyn_ltree[n * 2] !== 0)) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb,
          static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = (s.opt_len + 3 + 7) >>> 3;
        static_lenb = (s.static_len + 3 + 7) >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return (s.last_lit === s.lit_bufsize - 1);
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  return module.exports;
});

System.registerDynamic("npm:base64-js@0.0.8/lib/b64.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  ;
  (function(exports) {
    'use strict';
    var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
    var PLUS = '+'.charCodeAt(0);
    var SLASH = '/'.charCodeAt(0);
    var NUMBER = '0'.charCodeAt(0);
    var LOWER = 'a'.charCodeAt(0);
    var UPPER = 'A'.charCodeAt(0);
    var PLUS_URL_SAFE = '-'.charCodeAt(0);
    var SLASH_URL_SAFE = '_'.charCodeAt(0);
    function decode(elt) {
      var code = elt.charCodeAt(0);
      if (code === PLUS || code === PLUS_URL_SAFE)
        return 62;
      if (code === SLASH || code === SLASH_URL_SAFE)
        return 63;
      if (code < NUMBER)
        return -1;
      if (code < NUMBER + 10)
        return code - NUMBER + 26 + 26;
      if (code < UPPER + 26)
        return code - UPPER;
      if (code < LOWER + 26)
        return code - LOWER + 26;
    }
    function b64ToByteArray(b64) {
      var i,
          j,
          l,
          tmp,
          placeHolders,
          arr;
      if (b64.length % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }
      var len = b64.length;
      placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
      arr = new Arr(b64.length * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? b64.length - 4 : b64.length;
      var L = 0;
      function push(v) {
        arr[L++] = v;
      }
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
        push((tmp & 0xFF0000) >> 16);
        push((tmp & 0xFF00) >> 8);
        push(tmp & 0xFF);
      }
      if (placeHolders === 2) {
        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
        push(tmp & 0xFF);
      } else if (placeHolders === 1) {
        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
        push((tmp >> 8) & 0xFF);
        push(tmp & 0xFF);
      }
      return arr;
    }
    function uint8ToBase64(uint8) {
      var i,
          extraBytes = uint8.length % 3,
          output = "",
          temp,
          length;
      function encode(num) {
        return lookup.charAt(num);
      }
      function tripletToBase64(num) {
        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
      }
      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output += tripletToBase64(temp);
      }
      switch (extraBytes) {
        case 1:
          temp = uint8[uint8.length - 1];
          output += encode(temp >> 2);
          output += encode((temp << 4) & 0x3F);
          output += '==';
          break;
        case 2:
          temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
          output += encode(temp >> 10);
          output += encode((temp >> 4) & 0x3F);
          output += encode((temp << 2) & 0x3F);
          output += '=';
          break;
      }
      return output;
    }
    exports.toByteArray = b64ToByteArray;
    exports.fromByteArray = uint8ToBase64;
  }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
  return module.exports;
});

System.registerDynamic("npm:base64-js@0.0.8.js", ["npm:base64-js@0.0.8/lib/b64.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:base64-js@0.0.8/lib/b64.js');
  return module.exports;
});

System.registerDynamic("npm:ieee754@1.1.6/index.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e,
        m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity);
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e,
        m,
        c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  };
  return module.exports;
});

System.registerDynamic("npm:ieee754@1.1.6.js", ["npm:ieee754@1.1.6/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:ieee754@1.1.6/index.js');
  return module.exports;
});

System.registerDynamic("npm:isarray@1.0.0/index.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toString = {}.toString;
  module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == '[object Array]';
  };
  return module.exports;
});

System.registerDynamic("npm:isarray@1.0.0.js", ["npm:isarray@1.0.0/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:isarray@1.0.0/index.js');
  return module.exports;
});

System.registerDynamic("npm:buffer@3.6.0/index.js", ["npm:base64-js@0.0.8.js", "npm:ieee754@1.1.6.js", "npm:isarray@1.0.0.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var base64 = $__require('npm:base64-js@0.0.8.js');
  var ieee754 = $__require('npm:ieee754@1.1.6.js');
  var isArray = $__require('npm:isarray@1.0.0.js');
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192;
  var rootParent = {};
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
  function typedArraySupport() {
    function Bar() {}
    try {
      var arr = new Uint8Array(1);
      arr.foo = function() {
        return 42;
      };
      arr.constructor = Bar;
      return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0;
    } catch (e) {
      return false;
    }
  }
  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      if (arguments.length > 1)
        return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      this.length = 0;
      this.parent = undefined;
    }
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }
    return fromObject(this, arg);
  }
  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '')
      encoding = 'utf8';
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);
    that.write(string, encoding);
    return that;
  }
  function fromObject(that, object) {
    if (Buffer.isBuffer(object))
      return fromBuffer(that, object);
    if (isArray(object))
      return fromArray(that, object);
    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }
    if (typeof ArrayBuffer !== 'undefined') {
      if (object.buffer instanceof ArrayBuffer) {
        return fromTypedArray(that, object);
      }
      if (object instanceof ArrayBuffer) {
        return fromArrayBuffer(that, object);
      }
    }
    if (object.length)
      return fromArrayLike(that, object);
    return fromJsonObject(that, object);
  }
  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }
  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      array.byteLength;
      that = Buffer._augment(new Uint8Array(array));
    } else {
      that = fromTypedArray(that, new Uint8Array(array));
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromJsonObject(that, object) {
    var array;
    var length = 0;
    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  } else {
    Buffer.prototype.length = undefined;
    Buffer.prototype.parent = undefined;
  }
  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = Buffer._augment(new Uint8Array(length));
      that.__proto__ = Buffer.prototype;
    } else {
      that.length = length;
      that._isBuffer = true;
    }
    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool)
      that.parent = rootParent;
    return that;
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer))
      return new SlowBuffer(subject, encoding);
    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }
  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };
  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i])
        break;
      ++i;
    }
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!isArray(list))
      throw new TypeError('list argument must be an Array of Buffers.');
    if (list.length === 0) {
      return new Buffer(0);
    }
    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }
    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };
  function byteLength(string, encoding) {
    if (typeof string !== 'string')
      string = '' + string;
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'ascii':
        case 'binary':
        case 'raw':
        case 'raws':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;
    if (!encoding)
      encoding = 'utf8';
    if (start < 0)
      start = 0;
    if (end > this.length)
      end = this.length;
    if (end <= start)
      return '';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'binary':
          return binarySlice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0)
      return '';
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max)
        str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };
  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return 0;
    return Buffer.compare(this, b);
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff)
      byteOffset = 0x7fffffff;
    else if (byteOffset < -0x80000000)
      byteOffset = -0x80000000;
    byteOffset >>= 0;
    if (this.length === 0)
      return -1;
    if (byteOffset >= this.length)
      return -1;
    if (byteOffset < 0)
      byteOffset = Math.max(this.length + byteOffset, 0);
    if (typeof val === 'string') {
      if (val.length === 0)
        return -1;
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }
    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === val.length)
            return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }
    throw new TypeError('val must be string, number or Buffer');
  };
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new Error('Invalid hex string');
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined)
          encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }
    if (!encoding)
      encoding = 'utf8';
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
          return asciiWrite(this, string, offset, length);
        case 'binary':
          return binaryWrite(this, string, offset, length);
        case 'base64':
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte,
            thirdByte,
            fourthByte,
            tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 0x1000;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }
    if (newBuf.length)
      newBuf.parent = this.parent || this;
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }
    return val;
  };
  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8);
  };
  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1];
  };
  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
  };
  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80))
      return (this[offset]);
    return ((0xff - this[offset] + 1) * -1);
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
  }
  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffffffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }
  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0)
      value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
    if (offset < 0)
      throw new RangeError('index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
      throw new RangeError('sourceStart out of bounds');
    if (end < 0)
      throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; i--) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      for (i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value)
      value = 0;
    if (!start)
      start = 0;
    if (!end)
      end = this.length;
    if (end < start)
      throw new RangeError('end < start');
    if (end === start)
      return;
    if (this.length === 0)
      return;
    if (start < 0 || start >= this.length)
      throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length)
      throw new RangeError('end out of bounds');
    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }
    return this;
  };
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return (new Buffer(this)).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0,
            len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };
  var BP = Buffer.prototype;
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;
    arr._set = arr.set;
    arr.get = BP.get;
    arr.set = BP.set;
    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;
    return arr;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
      return '';
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }
  function toHex(n) {
    if (n < 16)
      return '0' + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; i++) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (!leadSurrogate) {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1)
            bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(0xEF, 0xBF, 0xBD);
      }
      leadSurrogate = null;
      if (codePoint < 0x80) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c,
        hi,
        lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if ((i + offset >= dst.length) || (i >= src.length))
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  return module.exports;
});

System.registerDynamic("npm:buffer@3.6.0.js", ["npm:buffer@3.6.0/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:buffer@3.6.0/index.js');
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-buffer@0.1.0/index.js", ["npm:buffer@3.6.0.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = System._nodeRequire ? System._nodeRequire('buffer') : $__require('npm:buffer@3.6.0.js');
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-buffer@0.1.0.js", ["github:jspm/nodelibs-buffer@0.1.0/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('github:jspm/nodelibs-buffer@0.1.0/index.js');
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/zlib/deflate.js", ["npm:pako@1.0.1/lib/utils/common.js", "npm:pako@1.0.1/lib/zlib/trees.js", "npm:pako@1.0.1/lib/zlib/adler32.js", "npm:pako@1.0.1/lib/zlib/crc32.js", "npm:pako@1.0.1/lib/zlib/messages.js", "github:jspm/nodelibs-buffer@0.1.0.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(Buffer) {
    'use strict';
    var utils = $__require('npm:pako@1.0.1/lib/utils/common.js');
    var trees = $__require('npm:pako@1.0.1/lib/zlib/trees.js');
    var adler32 = $__require('npm:pako@1.0.1/lib/zlib/adler32.js');
    var crc32 = $__require('npm:pako@1.0.1/lib/zlib/crc32.js');
    var msg = $__require('npm:pako@1.0.1/lib/zlib/messages.js');
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
    var PRESET_DICT = 0x20;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 0x03;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return ((f) << 1) - ((f) > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
      s.pending_buf[s.pending++] = b & 0xff;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p,
          n,
          m,
          more,
          str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = (m >= _w_size ? m - _w_size : 0);
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = (m >= _w_size ? m - _w_size : 0);
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 0xffff;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan,
          strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
      strm.adler = (s.wrap === 2) ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << (memLevel + 6);
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = s.lit_bufsize >> 1;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush,
          s;
      var beg,
          val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || (!strm.input && strm.avail_in !== 0) || (s.status === FINISH_STATE && flush !== Z_FINISH)) {
        return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0));
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
            put_byte(s, s.gzhead.time & 0xff);
            put_byte(s, (s.gzhead.time >> 8) & 0xff);
            put_byte(s, (s.gzhead.time >> 16) & 0xff);
            put_byte(s, (s.gzhead.time >> 24) & 0xff);
            put_byte(s, s.level === 9 ? 2 : (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0));
            put_byte(s, s.gzhead.os & 0xff);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 0xff);
              put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= (level_flags << 6);
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - (header % 31);
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 0xff);
            put_byte(s, (strm.adler >> 8) & 0xff);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
        var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) : (s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush));
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        put_byte(s, (strm.adler >> 16) & 0xff);
        put_byte(s, (strm.adler >> 24) & 0xff);
        put_byte(s, strm.total_in & 0xff);
        put_byte(s, (strm.total_in >> 8) & 0xff);
        put_byte(s, (strm.total_in >> 16) & 0xff);
        put_byte(s, (strm.total_in >> 24) & 0xff);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str,
          n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = 'pako deflate (from Nodeca project)';
  })($__require('github:jspm/nodelibs-buffer@0.1.0.js').Buffer);
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/deflate.js", ["npm:pako@1.0.1/lib/zlib/deflate.js", "npm:pako@1.0.1/lib/utils/common.js", "npm:pako@1.0.1/lib/utils/strings.js", "npm:pako@1.0.1/lib/zlib/messages.js", "npm:pako@1.0.1/lib/zlib/zstream.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var zlib_deflate = $__require('npm:pako@1.0.1/lib/zlib/deflate.js');
  var utils = $__require('npm:pako@1.0.1/lib/utils/common.js');
  var strings = $__require('npm:pako@1.0.1/lib/utils/strings.js');
  var msg = $__require('npm:pako@1.0.1/lib/zlib/messages.js');
  var ZStream = $__require('npm:pako@1.0.1/lib/zlib/zstream.js');
  var toString = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  function Deflate(options) {
    if (!(this instanceof Deflate))
      return new Deflate(options);
    this.options = utils.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ''
    }, options || {});
    var opt = this.options;
    if (opt.raw && (opt.windowBits > 0)) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = '';
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === 'string') {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function(data, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status,
        _mode;
    if (this.ended) {
      return false;
    }
    _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);
    if (typeof data === 'string') {
      strm.input = strings.string2buf(data);
    } else if (toString.call(data) === '[object ArrayBuffer]') {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
        if (this.options.to === 'string') {
          this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === 'string') {
        this.result = this.chunks.join('');
      } else {
        this.result = utils.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg;
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate(input, options);
  }
  exports.Deflate = Deflate;
  exports.deflate = deflate;
  exports.deflateRaw = deflateRaw;
  exports.gzip = gzip;
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/zlib/adler32.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  function adler32(adler, buf, len, pos) {
    var s1 = (adler & 0xffff) | 0,
        s2 = ((adler >>> 16) & 0xffff) | 0,
        n = 0;
    while (len !== 0) {
      n = len > 2000 ? 2000 : len;
      len -= n;
      do {
        s1 = (s1 + buf[pos++]) | 0;
        s2 = (s2 + s1) | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return (s1 | (s2 << 16)) | 0;
  }
  module.exports = adler32;
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/zlib/crc32.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  function makeTable() {
    var c,
        table = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
      }
      table[n] = c;
    }
    return table;
  }
  var crcTable = makeTable();
  function crc32(crc, buf, len, pos) {
    var t = crcTable,
        end = pos + len;
    crc ^= -1;
    for (var i = pos; i < end; i++) {
      crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }
    return (crc ^ (-1));
  }
  module.exports = crc32;
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/zlib/inffast.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var BAD = 30;
  var TYPE = 12;
  module.exports = function inflate_fast(strm, start) {
    var state;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist;
    var from;
    var from_source;
    var input,
        output;
    state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top: do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen: for (; ; ) {
        op = here >>> 24;
        hold >>>= op;
        bits -= op;
        op = (here >>> 16) & 0xff;
        if (op === 0) {
          output[_out++] = here & 0xffff;
        } else if (op & 16) {
          len = here & 0xffff;
          op &= 15;
          if (op) {
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
            }
            len += hold & ((1 << op) - 1);
            hold >>>= op;
            bits -= op;
          }
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = dcode[hold & dmask];
          dodist: for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = (here >>> 16) & 0xff;
            if (op & 16) {
              dist = here & 0xffff;
              op &= 15;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
              }
              dist += hold & ((1 << op) - 1);
              if (dist > dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break top;
              }
              hold >>>= op;
              bits -= op;
              op = _out - beg;
              if (dist > op) {
                op = dist - op;
                if (op > whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD;
                    break top;
                  }
                }
                from = 0;
                from_source = s_window;
                if (wnext === 0) {
                  from += wsize - op;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;
                    from_source = output;
                  }
                } else if (wnext < op) {
                  from += wsize + wnext - op;
                  op -= wnext;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = 0;
                    if (wnext < len) {
                      op = wnext;
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;
                      from_source = output;
                    }
                  }
                } else {
                  from += wnext - op;
                  if (op < len) {
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;
                    from_source = output;
                  }
                }
                while (len > 2) {
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  len -= 3;
                }
                if (len) {
                  output[_out++] = from_source[from++];
                  if (len > 1) {
                    output[_out++] = from_source[from++];
                  }
                }
              } else {
                from = _out - dist;
                do {
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  len -= 3;
                } while (len > 2);
                if (len) {
                  output[_out++] = output[from++];
                  if (len > 1) {
                    output[_out++] = output[from++];
                  }
                }
              }
            } else if ((op & 64) === 0) {
              here = dcode[(here & 0xffff) + (hold & ((1 << op) - 1))];
              continue dodist;
            } else {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break top;
            }
            break;
          }
        } else if ((op & 64) === 0) {
          here = lcode[(here & 0xffff) + (hold & ((1 << op) - 1))];
          continue dolen;
        } else if (op & 32) {
          state.mode = TYPE;
          break top;
        } else {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break top;
        }
        break;
      }
    } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
    strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
    state.hold = hold;
    state.bits = bits;
    return;
  };
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/zlib/inftrees.js", ["npm:pako@1.0.1/lib/utils/common.js", "github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    'use strict';
    var utils = $__require('npm:pako@1.0.1/lib/utils/common.js');
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
    var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
    var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
    var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0,
          max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits,
          here_op,
          here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = (1 << 24) | (64 << 16) | 0;
        table[table_index++] = (1 << 24) | (64 << 16) | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }
      var i = 0;
      for (; ; ) {
        i++;
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << (len - drop);
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;
        } while (fill !== 0);
        incr = 1 << (len - 1);
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if ((type === LENS && used > ENOUGH_LENS) || (type === DISTS && used > ENOUGH_DISTS)) {
            return 1;
          }
          low = huff & mask;
          table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;
      }
      opts.bits = root;
      return 0;
    };
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/zlib/inflate.js", ["npm:pako@1.0.1/lib/utils/common.js", "npm:pako@1.0.1/lib/zlib/adler32.js", "npm:pako@1.0.1/lib/zlib/crc32.js", "npm:pako@1.0.1/lib/zlib/inffast.js", "npm:pako@1.0.1/lib/zlib/inftrees.js", "github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    'use strict';
    var utils = $__require('npm:pako@1.0.1/lib/utils/common.js');
    var adler32 = $__require('npm:pako@1.0.1/lib/zlib/adler32.js');
    var crc32 = $__require('npm:pako@1.0.1/lib/zlib/crc32.js');
    var inflate_fast = $__require('npm:pako@1.0.1/lib/zlib/inffast.js');
    var inflate_table = $__require('npm:pako@1.0.1/lib/zlib/inftrees.js');
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (((q >>> 24) & 0xff) + ((q >>> 8) & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24));
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = '';
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix,
        distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {bits: 9});
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {bits: 5});
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input,
          output;
      var next;
      var put;
      var have,
          left;
      var hold;
      var bits;
      var _in,
          _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits,
          here_op,
          here_val;
      var last_bits,
          last_op,
          last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!strm || !strm.state || !strm.output || (!strm.input && strm.avail_in !== 0)) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave: for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((state.wrap & 2) && hold === 0x8b1f) {
              state.check = 0;
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || (((hold & 0xff) << 8) + (hold >> 8)) % 31) {
              strm.msg = 'incorrect header check';
              state.mode = BAD;
              break;
            }
            if ((hold & 0x0f) !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 0x0f) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            } else if (len > state.wbits) {
              strm.msg = 'invalid window size';
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            strm.adler = state.check = 1;
            state.mode = hold & 0x200 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 0xff) !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            if (state.flags & 0xe000) {
              strm.msg = 'unknown header flags set';
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = ((hold >> 8) & 1);
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              hbuf[2] = (hold >>> 16) & 0xff;
              hbuf[3] = (hold >>> 24) & 0xff;
              state.check = crc32(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = (hold & 0xff);
              state.head.os = (hold >> 8);
            }
            if (state.flags & 0x0200) {
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          case EXLEN:
            if (state.flags & 0x0400) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 0x0200) {
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          case EXTRA:
            if (state.flags & 0x0400) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(state.head.extra, input, next, copy, len);
                }
                if (state.flags & 0x0200) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          case NAME:
            if (state.flags & 0x0800) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && (state.length < 65536)) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          case COMMENT:
            if (state.flags & 0x1000) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && (state.length < 65536)) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          case HCRC:
            if (state.flags & 0x0200) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.check & 0xffff)) {
                strm.msg = 'header crc mismatch';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = ((state.flags >> 9) & 1);
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = (hold & 0x01);
            hold >>>= 1;
            bits -= 1;
            switch ((hold & 0x03)) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = 'invalid block type';
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
              strm.msg = 'invalid stored block lengths';
              state.mode = BAD;
              break;
            }
            state.length = hold & 0xffff;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case COPY_:
            state.mode = COPY;
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 0x1f) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 0x1f) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 0x0f) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = 'too many length or distance symbols';
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = (hold & 0x07);
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = {bits: state.lenbits};
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid code lengths set';
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & ((1 << state.lenbits) - 1)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;
                if ((here_bits) <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = 'invalid bit length repeat';
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 0x03);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 0x07);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 0x7f);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = 'invalid bit length repeat';
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = 'invalid code -- missing end-of-block';
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = {bits: state.lenbits};
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid literal/lengths set';
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = {bits: state.distbits};
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = 'invalid distances set';
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          case LEN_:
            state.mode = LEN;
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & ((1 << state.lenbits) - 1)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;
                if ((last_bits + here_bits) <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = 'invalid literal/length code';
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & ((1 << state.extra) - 1);
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & ((1 << state.distbits) - 1)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;
              if ((here_bits) <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;
                if ((last_bits + here_bits) <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = (here_op) & 15;
            state.mode = DISTEXT;
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & ((1 << state.extra) - 1);
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check = (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
              }
              _out = left;
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = 'incorrect data check';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state.total & 0xffffffff)) {
                strm.msg = 'incorrect length check';
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          default:
            return Z_STREAM_ERROR;
        }
      }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || (_out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH))) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = 'pako inflate (from Nodeca project)';
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/utils/common.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var TYPED_OK = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Int32Array !== 'undefined');
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== 'object') {
        throw new TypeError(source + 'must be non-object');
      }
      for (var p in source) {
        if (source.hasOwnProperty(p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      if (src.subarray && dest.subarray) {
        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      var i,
          l,
          len,
          pos,
          chunk,
          result;
      len = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l = chunks.length; i < l; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function(dest, src, src_offs, len, dest_offs) {
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src[src_offs + i];
      }
    },
    flattenChunks: function(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on) {
    if (on) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/utils/strings.js", ["npm:pako@1.0.1/lib/utils/common.js", "github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    'use strict';
    var utils = $__require('npm:pako@1.0.1/lib/utils/common.js');
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (var q = 0; q < 256; q++) {
      _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
    }
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str) {
      var buf,
          c,
          c2,
          m_pos,
          i,
          str_len = str.length,
          buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 0xfc00) === 0xdc00) {
            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
            m_pos++;
          }
        }
        if (c < 0x80) {
          buf[i++] = c;
        } else if (c < 0x800) {
          buf[i++] = 0xC0 | (c >>> 6);
          buf[i++] = 0x80 | (c & 0x3f);
        } else if (c < 0x10000) {
          buf[i++] = 0xE0 | (c >>> 12);
          buf[i++] = 0x80 | (c >>> 6 & 0x3f);
          buf[i++] = 0x80 | (c & 0x3f);
        } else {
          buf[i++] = 0xf0 | (c >>> 18);
          buf[i++] = 0x80 | (c >>> 12 & 0x3f);
          buf[i++] = 0x80 | (c >>> 6 & 0x3f);
          buf[i++] = 0x80 | (c & 0x3f);
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65537) {
        if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = '';
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0,
          len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports.buf2string = function(buf, max) {
      var i,
          out,
          c,
          c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 0x80) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 0xfffd;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        while (c_len > 1 && i < len) {
          c = (c << 6) | (buf[i++] & 0x3f);
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 0xfffd;
          continue;
        }
        if (c < 0x10000) {
          utf16buf[out++] = c;
        } else {
          c -= 0x10000;
          utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
          utf16buf[out++] = 0xdc00 | (c & 0x3ff);
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return (pos + _utf8len[buf[pos]] > max) ? pos : max;
    };
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/zlib/messages.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    2: 'need dictionary',
    1: 'stream end',
    0: '',
    '-1': 'file error',
    '-2': 'stream error',
    '-3': 'data error',
    '-4': 'insufficient memory',
    '-5': 'buffer error',
    '-6': 'incompatible version'
  };
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/zlib/zstream.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = '';
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  module.exports = ZStream;
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/zlib/gzheader.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = '';
    this.comment = '';
    this.hcrc = 0;
    this.done = false;
  }
  module.exports = GZheader;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2/browser.js", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2.js", ["npm:process@0.11.2/browser.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:process@0.11.2/browser.js');
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2/index.js", ["npm:process@0.11.2.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = System._nodeRequire ? process : $__require('npm:process@0.11.2.js');
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2.js", ["github:jspm/nodelibs-process@0.1.2/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('github:jspm/nodelibs-process@0.1.2/index.js');
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/inflate.js", ["npm:pako@1.0.1/lib/zlib/inflate.js", "npm:pako@1.0.1/lib/utils/common.js", "npm:pako@1.0.1/lib/utils/strings.js", "npm:pako@1.0.1/lib/zlib/constants.js", "npm:pako@1.0.1/lib/zlib/messages.js", "npm:pako@1.0.1/lib/zlib/zstream.js", "npm:pako@1.0.1/lib/zlib/gzheader.js", "github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  (function(process) {
    'use strict';
    var zlib_inflate = $__require('npm:pako@1.0.1/lib/zlib/inflate.js');
    var utils = $__require('npm:pako@1.0.1/lib/utils/common.js');
    var strings = $__require('npm:pako@1.0.1/lib/utils/strings.js');
    var c = $__require('npm:pako@1.0.1/lib/zlib/constants.js');
    var msg = $__require('npm:pako@1.0.1/lib/zlib/messages.js');
    var ZStream = $__require('npm:pako@1.0.1/lib/zlib/zstream.js');
    var GZheader = $__require('npm:pako@1.0.1/lib/zlib/gzheader.js');
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ''
      }, options || {});
      var opt = this.options;
      if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if ((opt.windowBits >= 0) && (opt.windowBits < 16) && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = '';
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status,
          _mode;
      var next_out_utf8,
          tail,
          utf8str;
      var dict;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);
      if (typeof data === 'string') {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === '[object ArrayBuffer]') {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          if (typeof dictionary === 'string') {
            dict = strings.string2buf(dictionary);
          } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
            dict = new Uint8Array(dictionary);
          } else {
            dict = dictionary;
          }
          status = zlib_inflate.inflateSetDictionary(this.strm, dict);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {
            if (this.options.to === 'string') {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === 'string') {
          this.result = this.chunks.join('');
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg;
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/lib/zlib/constants.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
  };
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1/index.js", ["npm:pako@1.0.1/lib/utils/common.js", "npm:pako@1.0.1/lib/deflate.js", "npm:pako@1.0.1/lib/inflate.js", "npm:pako@1.0.1/lib/zlib/constants.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var assign = $__require('npm:pako@1.0.1/lib/utils/common.js').assign;
  var deflate = $__require('npm:pako@1.0.1/lib/deflate.js');
  var inflate = $__require('npm:pako@1.0.1/lib/inflate.js');
  var constants = $__require('npm:pako@1.0.1/lib/zlib/constants.js');
  var pako = {};
  assign(pako, deflate, inflate, constants);
  module.exports = pako;
  return module.exports;
});

System.registerDynamic("npm:pako@1.0.1.js", ["npm:pako@1.0.1/index.js"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('npm:pako@1.0.1/index.js');
  return module.exports;
});

System.register('lib/main.js', ['npm:babel-runtime@5.8.38/helpers/sliced-to-array.js', 'npm:babel-runtime@5.8.38/core-js/promise.js', 'npm:babel-runtime@5.8.38/core-js/array/from.js', 'npm:babel-runtime@5.8.38/core-js/get-iterator.js', 'npm:babel-runtime@5.8.38/core-js/map.js', 'npm:babel-runtime@5.8.38/core-js/set.js', 'github:juris-m/citeproc-js@1.1.101.js', 'npm:urijs@1.17.1.js', 'npm:zip-js@0.0.2.js', 'npm:kefir@3.2.2.js', 'npm:localforage@1.4.0.js', 'npm:pako@1.0.1.js'], function (_export) {
  var _slicedToArray, _Promise, _Array$from, _getIterator, _Map, _Set, CSL, URI, zip, Kefir, localforage, pako, progressEmitter;

  function progress(value) {
    if (progressEmitter) progressEmitter.emit(value);
  }

  function setupProgress() {
    var progress = document.querySelector('#progress');
    var progressStream = Kefir.stream(function (emitter) {
      progressEmitter = emitter;
    });

    progressStream.onValue(function (value) {
      progress.textContent = value;
    });
  }

  function zoteroUri(apiKey, type, value) {
    return URI("https://api.zotero.org").directory(type + 's/' + value + '/items').addSearch({ v: 3,
      format: 'csljson',
      key: apiKey });
  }

  function localeUrl(language) {
    return '/locales/locales-' + language + '.xml';
  }

  function flatten(arr) {
    var empty = [];
    return empty.concat.apply(empty, arr);
  }

  function _generateDocx(zipFS, xmlFilesByPath, cites, formatted) {
    var serializer = new XMLSerializer();

    return _Promise.all(_Array$from(xmlFilesByPath).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2);

      var path = _ref2[0];
      var xmlPromise = _ref2[1];

      return xmlPromise.then(function (xml) {
        var xmlCites = cites.filter(function (cite) {
          return cite.xml === xml;
        });

        // Update the text properties ...
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = _getIterator(xmlCites), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var cite = _step.value;

            var instrText = cite.node;
            var str = formatted.get(instrText);

            cite.json.properties.formattedCitation = str;
            cite.json.properties.plainCitation = str;

            // Write the updated JSON back into the XML
            instrText.textContent = ' ADDIN ZOTERO_ITEM CSL_CITATION ' + JSON.stringify(cite.json);

            /* We have to carefully traverse the node tree in order
               to update the field's contents. */
            var firstR = instrText.parentElement;

            var seenSeparator = false;
            var textWritten = false;
            var toRemove = [];
            for (var presentR = firstR; presentR && presentR.querySelector('fldChar[*|fldCharType="end"]') == null; presentR = presentR.nextElementSibling) {
              if (textWritten) {
                toRemove.push(presentR);
              } else if (seenSeparator) {
                var text;
                if (text = presentR.querySelector('t')) {
                  text.textContent = str;
                  textWritten = true;
                }
              } else {
                seenSeparator = presentR.querySelector('fldChar[*|fldCharType="separate"]');
              }

              if (!seenSeparator && presentR.localName != 'r') {
                toRemove.push(presentR);
              }
            }

            // Delete all these nodes
            toRemove.forEach(function (r) {
              return r.remove();
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return [path, xml];
      });
    })).then(function (pairs) {
      // Write XML back to the zip
      pairs.forEach(function (_ref3) {
        var _ref32 = _slicedToArray(_ref3, 2);

        var path = _ref32[0];
        var xml = _ref32[1];

        var _path$split = path.split('/');

        var _path$split2 = _slicedToArray(_path$split, 2);

        var dir = _path$split2[0];
        var name = _path$split2[1];

        zipFS.remove(zipFS.find(path));
        zipFS.find(dir).addText(name, serializer.serializeToString(xml));
      });
    }).then(function () {
      return new _Promise(function (res, rej) {
        var exported = function exported(blob) {
          progress("Got blob", blob);

          try {
            // Change the mime type
            res(new Blob([blob], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' }));
          } catch (e) {
            rej(e);
          }
        };
        progress("zipping ...");
        zipFS.exportBlob(exported, function (i) {
          progress("Progress " + i);
        }, rej);
      });
    });
  }

  function requestFromZotero(creds, ids) {
    var _creds = _slicedToArray(creds, 3);

    var userIds = _creds[0];
    var groupIds = _creds[1];
    var apiKey = _creds[2];

    var uris = userIds.split(/\s+/).filter(function (id) {
      return id.length > 0;
    }).map(function (userId) {
      return zoteroUri(apiKey, 'user', userId);
    }).concat(groupIds.split(/\s+/).filter(function (id) {
      return id.length > 0;
    }).map(function (groupId) {
      return zoteroUri(apiKey, 'group', groupId);
    }));

    var promises = [];

    progress('fetching from zotero ...');

    // Items can be requested 50 at a time.

    var _loop = function (offset) {
      var subset = ids.slice(offset, offset + 50);
      uris.forEach(function (uri) {
        promises.push(fetch(uri.clone().addSearch({ itemKey: subset.join(',') }).toString()));
      });
    };

    for (var offset = 0; offset < ids.length; offset = offset + 50) {
      _loop(offset);
    }

    return _Promise.all(promises.map(function (promise) {
      return promise.then(function (request) {
        return request.json();
      });
    })).then(function (jsons) {
      return flatten(jsons.map(function (json) {
        return json.items;
      }));
    });
  }

  function processor(style) {
    var languages = ['en-GB', 'en-US'];

    return _Promise.all(languages.map(function (language) {
      return fetch(localeUrl(language)).then(function (response) {
        return response.text();
      }).then(function (text) {
        return [language, text];
      });
    })).then(function (pairs) {
      var locales = new _Map(pairs);
      return {
        engine: function engine() {
          var citations = new _Map();
          var engine = new CSL.Engine({
            retrieveLocale: locales.get.bind(locales),
            retrieveItem: citations.get.bind(citations)
          }, style);

          return [engine, citations];
        },

        compile: function compile(creds, cites) {
          var _this = this;

          // Create a set of unique cite ids.
          var citeIds = new _Set(flatten(cites.map(function (_ref4) {
            var ids = _ref4.ids;
            return ids;
          })));
          return requestFromZotero(creds, _Array$from(citeIds)).then(function (items) {

            // Create a new engine.

            var _engine = _this.engine();

            var _engine2 = _slicedToArray(_engine, 2);

            var engine = _engine2[0];
            var citations = _engine2[1];

            // Add the items into the map.  Replace the ids with
            // shortened ones.
            items.forEach(function (item) {
              var id = item.id.match(/\/([^\/]*)$/)[1];
              item.id = id;
              citations.set(id, item);
            });

            // Now process each citation
            progress('appendCitationCluster ...');

            // This dodgy-as loop uses setTimeout in order to prevent
            // warnings about long-running scripts.  I'm sure this could
            // get busted somehow.
            var lastPromise = _Promise.resolve(new Array(cites.length));
            for (var offset = 0; offset < cites.length; offset = offset + 20) {

              // Force a new scope
              (function (cites) {
                lastPromise = lastPromise.then(function (formattedCitations) {
                  return new _Promise(function (res, rej) {
                    setTimeout(function () {
                      try {
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                          for (var _iterator2 = _getIterator(cites), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            var cite = _step2.value;

                            var cluster = { citationItems: cite.ids.map(function (id) {
                                return { id: id };
                              }),
                              properties: { noteIndex: 0 } };

                            engine.appendCitationCluster(cluster).forEach(function (_ref5) {
                              var _ref52 = _slicedToArray(_ref5, 2);

                              var k = _ref52[0];
                              var v = _ref52[1];

                              formattedCitations[k] = v;
                            });
                          }
                        } catch (err) {
                          _didIteratorError2 = true;
                          _iteratorError2 = err;
                        } finally {
                          try {
                            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                              _iterator2['return']();
                            }
                          } finally {
                            if (_didIteratorError2) {
                              throw _iteratorError2;
                            }
                          }
                        }

                        res(formattedCitations);
                      } catch (e) {
                        rej(e);
                      }
                    });
                  });
                });
              })(cites.slice(offset, offset + 20));
            }

            return lastPromise.then(function (formattedCitations) {
              // Create a map from nodes to formatted cites
              var formatted = new _Map();
              for (i in formattedCitations) {
                formatted.set(cites[i].node, formattedCitations[i]);
              }

              progress('makeBibliography ...');
              var bibliography = engine.makeBibliography();

              return { formatted: formatted,
                bibliography: bibliography };
            });
          });
        }
      };
    });
  }

  function processFiles(files, creds) {

    progress("processFiles ...");

    return loadCSL().then(processor).then(function (csl) {
      var parser = new DOMParser();

      progress('loading docx files ...');

      // A list of file paths, mapping to zip objects
      var zipFiles = new _Map(files.map(function (file) {
        var zipPromise = new _Promise(function (res, rej) {
          var zipFS = new zip.fs.FS();
          var imported = function imported() {
            return res(zipFS);
          };
          zipFS.importBlob(file, imported, rej);
        });

        return [file.name, zipPromise];
      }));

      // These are paths to look for inside the zip.
      var xmlFilePaths = ['word/document.xml', 'word/footnotes.xml'];

      progress('extracting XML ...');

      // This is a nested map of zip files to XML file names to parsed
      // XML, as a promise.
      var xmlFilesPromise = _Promise.all(_Array$from(zipFiles.values()).map(function (zipPromise) {
        return zipPromise.then(function (zipFS) {
          return _Promise.all(xmlFilePaths.map(function (path) {
            var xmlPromise = new _Promise(function (res, rej) {
              try {
                zipFS.find(path).getText(res);
              } catch (e) {
                rej(e);
              }
            }).then(function (document) {
              return parser.parseFromString(document, 'text/xml');
            });

            return [path, xmlPromise];
          })).then(function (xmlPairs) {
            return [zipFS, new _Map(xmlPairs)];
          });
        });
      })).then(function (zipPairs) {
        return new _Map(zipPairs);
      });

      // This is a list of cite objects, which record the node where
      // the citation data is, the xml file that the node belongs to,
      // and the citation itself.
      var citesPromise = xmlFilesPromise.then(function (zipMap) {
        return _Promise.all(_Array$from(zipMap.values()).map(function (xmlByPath) {
          return _Promise.all(_Array$from(xmlByPath.values()).map(function (xmlPromise) {
            return xmlPromise.then(function (xml) {
              return _Array$from(xml.querySelectorAll('instrText')).filter(function (node) {
                return node.textContent.match(/^\s*ADDIN ZOTERO_ITEM CSL_CITATION/);
              }).map(function (node) {
                var jsonPart = node.textContent.match(/^\s*ADDIN ZOTERO_ITEM CSL_CITATION\s*({.*})\s*$/)[1];
                var json = JSON.parse(jsonPart);
                var ids = flatten(json.citationItems.map(function (item) {
                  return item.uris;
                })).map(function (uri) {
                  var matches = uri.match(/\/([^\/]*)$/);
                  return matches ? matches[1] : null;
                });

                return { ids: ids,
                  node: node,
                  json: json,
                  xml: xml };
              });
            });
          })).then(function (citesByXmlFile) {
            return flatten(citesByXmlFile);
          });
        })).then(function (citesByFile) {
          return flatten(citesByFile);
        });
      });

      // Do the processing
      return citesPromise.then(function (cites) {
        return csl.compile(creds, cites).then(function (result) {
          var _result$bibliography = _slicedToArray(result.bibliography, 2);

          var obj = _result$bibliography[0];
          var items = _result$bibliography[1];

          return {
            zipFiles: zipFiles,
            bibliography: obj.bibstart + items.join('') + obj.bibend,
            cites: cites,
            formatted: result.formatted,
            generateDocx: function generateDocx(name) {
              var _this2 = this;

              return this.zipFiles.get(name).then(function (zipFS) {
                return xmlFilesPromise.then(function (zipMap) {
                  var xmlFilesByPath = zipMap.get(zipFS);

                  return _generateDocx(zipFS, xmlFilesByPath, _this2.cites, _this2.formatted);
                });
              });
            }
          };
        });
      });
    });
  }

  function loadZoteroCredentials() {
    return localforage.getItem('zoteroCredentials').then(function (creds) {
      return creds ? creds : [null, null, null];
    });
  }

  function saveZoteroCredentials(creds) {
    return localforage.setItem('zoteroCredentials', creds);
  }

  function loadCSL() {
    return localforage.getItem('csl');
  }

  function saveCSL(csl) {
    return localforage.setItem('csl', csl);
  }

  function initApplication() {
    var bibliography = document.querySelector('#bibliography');
    var filesInput = document.querySelector('#docx-files');

    var go = document.querySelector('#go');

    var userIdsInput = document.querySelector('#user-ids');
    var groupIdsInput = document.querySelector('#group-ids');
    var apiKeyInput = document.querySelector('#api-key');
    var saveButton = document.querySelector('#save-zotero');

    var cslStatus = document.querySelector('#csl-status');
    var cslFileInput = document.querySelector('#csl-file');
    var cslURLInput = document.querySelector('#csl-url');
    var cslInputRadios = document.forms['style-file'].elements['csl'];
    var cslGetButton = document.querySelector('#get-csl');

    _Promise.all([loadCSL().then(function (csl) {
      var cslFileStream = Kefir.fromEvents(cslFileInput, 'change', function (ev) {
        return ev.target.files[0];
      }).toProperty(function () {
        return cslFileInput.files[0];
      });

      var cslURLStream = Kefir.fromEvents(cslURLInput, 'input', function (ev) {
        return ev.target.value;
      }).toProperty(function () {
        return cslURLInput.value;
      });

      var cslInputStream = Kefir.merge(_Array$from(cslInputRadios).map(function (input) {
        return Kefir.fromEvents(input, 'change');
      })).map(function () {
        return cslInputRadios.value;
      }).toProperty(function () {
        return cslInputRadios.value;
      });

      var cslSourceStream = Kefir.combine([cslFileStream, cslURLStream, cslInputStream], function (file, url, input) {
        if (input == 'file') {
          return file;
        } else if (input == 'url' && url.length > 0) {
          return url;
        } else {
          return null;
        }
      }).toProperty();

      var cslGetStream = Kefir.fromEvents(cslGetButton, 'click');

      var cslNewStream = cslSourceStream.sampledBy(cslGetStream).flatMapFirst(function (thing) {
        if (thing instanceof File) {
          return Kefir.fromPromise(new _Promise(function (res, rej) {
            var reader = new FileReader();

            reader.onload = function () {
              res(reader.result);
            };
            reader.onerror = rej;

            reader.readAsText(thing);
          }));
        } else if (thing) {
          progress('Fetching ' + thing);
          return Kefir.fromPromise(fetch(thing).then(function (result) {
            return result.text();
          }));
        } else {
          return Kefir.constantError('no input');
        }
      });

      var cslSavedStream = cslNewStream.ignoreErrors().flatMapFirst(function (csl) {
        return Kefir.fromPromise(saveCSL(csl));
      });

      cslSavedStream.onValue(function (csl) {
        progress('saved CSL');
      });

      var cslStream = cslSavedStream.toProperty(function () {
        return csl;
      });

      var cslStatusStream = cslStream.map(function (csl) {
        if (csl) {
          try {
            var parser = new DOMParser();
            var xml = parser.parseFromString(csl, 'text/xml');
            var title = xml.querySelector('info > title');
            return "Using " + title.textContent;
          } catch (e) {
            return "File has been uploaded but is not valid CSL";
          }
        } else {
          return "No CSL file";
        }
      });

      cslStatusStream.onValue(function (status) {
        cslStatus.textContent = status;
      });

      return cslStream;
    }), loadZoteroCredentials().then(function (_ref6) {
      var _ref62 = _slicedToArray(_ref6, 3);

      var userIds = _ref62[0];
      var groupIds = _ref62[1];
      var apiKey = _ref62[2];

      userIdsInput.value = userIds;
      var userIdsStream = Kefir.fromEvents(userIdsInput, 'input', function (ev) {
        return ev.target.value;
      }).toProperty(function () {
        return userIdsInput.value;
      });

      groupIdsInput.value = groupIds;
      var groupIdsStream = Kefir.fromEvents(groupIdsInput, 'input', function (ev) {
        return ev.target.value;
      }).toProperty(function () {
        return groupIdsInput.value;
      });

      apiKeyInput.value = apiKey;
      var apiKeyStream = Kefir.fromEvents(apiKeyInput, 'input', function (ev) {
        return ev.target.value;
      }).toProperty(function () {
        return apiKeyInput.value;
      });

      var saveClickStream = Kefir.fromEvents(saveButton, 'click');

      var credentialStream = Kefir.combine([userIdsStream, groupIdsStream, apiKeyStream]).toProperty();

      var saveCredentialStream = credentialStream.sampledBy(saveClickStream);

      var completedSaveStream = saveCredentialStream.flatMapFirst(function (credentials) {
        return Kefir.fromPromise(saveZoteroCredentials(credentials));
      });

      completedSaveStream.onAny(function (saved) {
        progress('saved');
      });

      // Whenever a save begins, we disable the button.  Whenever a
      // save completes or fails, we re-enable the button.
      var saveDisabled = Kefir.merge([saveCredentialStream.map(function () {
        return true;
      }), completedSaveStream.map(function () {
        return false;
      })]).toProperty(function () {
        return false;
      });

      saveDisabled.onValue(function (disabled) {
        saveButton.disabled = disabled;
      });

      return credentialStream;
    })]).then(function (_ref7) {
      var _ref72 = _slicedToArray(_ref7, 2);

      var cslStream = _ref72[0];
      var credentialStream = _ref72[1];

      // This streams clicks to the go button
      var goStream = Kefir.fromEvents(go, 'click');

      // This represents the currently selected file set.
      var filesStream = Kefir.fromEvents(filesInput, 'change', function (ev) {
        return ev.target.files;
      }).toProperty(function () {
        return filesInput.files;
      }).map(function (fileList) {
        return _Array$from(fileList);
      });

      // Returns the result of processing when 'go' is clicked.
      var processedFilesStream = Kefir.combine([filesStream, credentialStream]).sampledBy(goStream).flatMapFirst(function (_ref8) {
        var _ref82 = _slicedToArray(_ref8, 2);

        var files = _ref82[0];
        var creds = _ref82[1];

        return Kefir.fromPromise(processFiles(files, creds));
      });

      // Whenever processing begins, we disable the button.  Whenever
      // processing completes or fails, we re-enable the button.
      var haveDetailsStream = Kefir.combine([filesStream, credentialStream, cslStream], function (files, credentials, csl) {
        return files.length > 0 && csl && credentials.every(function (cred) {
          return cred && cred.length > 0;
        });
      }).toProperty();

      var goDisabled = Kefir.merge([goStream.map(function () {
        return true;
      }), processedFilesStream.map(function () {
        return false;
      })]).toProperty(function () {
        return false;
      }).combine(haveDetailsStream, function (goDisabled, haveDetails) {
        return goDisabled || !haveDetails;
      });

      goDisabled.onValue(function (disabled) {
        go.disabled = disabled;
      });

      // This is used to display the results.  Whenever "go" is
      // clicked, we blank out the bib.
      var bibliographyStream = Kefir.merge([goStream.map(function () {
        return '';
      }), processedFilesStream.map(function (result) {
        return result.bibliography;
      })]).toProperty(function () {
        return '';
      });

      // Display the bibliography
      bibliographyStream.onValue(function (bib) {
        bibliography.innerHTML = '<h3>Bibliography</h3>' + bib;
      });

      return processedFilesStream;
    }).then(function (processedFilesStream) {
      var links = document.querySelector('#links');

      // This is a stream of lists of files to display.
      var fileListStream = processedFilesStream.map(function (result) {
        return _Array$from(result.zipFiles.keys()).map(function (name) {
          return {
            name: name,
            generateDocx: function generateDocx() {
              return result.generateDocx(this.name);
            }
          };
        });
      });

      // This is a stream of lists of elements that display the docx
      // files.
      var elementListStream = fileListStream.map(function (files) {
        return files.map(function (file) {
          var elt = document.createElement('li');
          elt.innerHTML = '\n            <div class="name"></div>\n            <div>\n              <button class="generate">Generate DOCX</button>\n            </div>\n            <div class="download"></div>';

          elt.querySelector('.name').textContent = file.name;
          var generateButton = elt.querySelector('button.generate');
          var downloadArea = elt.querySelector('.download');

          var generateClickStream = Kefir.fromEvents(generateButton, 'click');

          // Only ever generate the docx once.
          var docxStream = generateClickStream.take(1).flatMapFirst(function () {
            progress('generating ...');
            return Kefir.fromPromise(file.generateDocx());
          });

          docxStream.map(function (blob) {
            return URL.createObjectURL(blob);
          }).onValue(function (url) {
            var a = document.createElement('a');
            a.setAttribute('href', url);
            a.setAttribute('download', file.name);
            a.textContent = 'Download';
            downloadArea.appendChild(a);
          });

          return elt;
        });
      });

      elementListStream.slidingWindow(2).onValue(function (eltSets) {
        // Remove any old elements.
        if (eltSets.length > 1) {
          var oldElts = flatten(eltSets.slice(0, eltSets.length - 1));
          oldElts.forEach(function (elt) {
            var a;
            if (a = elt.querySelector('a[href]')) URL.revokeObjectURL(a.getAttribute('href'));
            elt.remove();
          });
        }

        // Add the new elements.
        elts = eltSets[eltSets.length - 1];
        elts.forEach(function (elt) {
          return links.appendChild(elt);
        });
      });
    });
  }

  return {
    setters: [function (_npmBabelRuntime5838HelpersSlicedToArrayJs) {
      _slicedToArray = _npmBabelRuntime5838HelpersSlicedToArrayJs['default'];
    }, function (_npmBabelRuntime5838CoreJsPromiseJs) {
      _Promise = _npmBabelRuntime5838CoreJsPromiseJs['default'];
    }, function (_npmBabelRuntime5838CoreJsArrayFromJs) {
      _Array$from = _npmBabelRuntime5838CoreJsArrayFromJs['default'];
    }, function (_npmBabelRuntime5838CoreJsGetIteratorJs) {
      _getIterator = _npmBabelRuntime5838CoreJsGetIteratorJs['default'];
    }, function (_npmBabelRuntime5838CoreJsMapJs) {
      _Map = _npmBabelRuntime5838CoreJsMapJs['default'];
    }, function (_npmBabelRuntime5838CoreJsSetJs) {
      _Set = _npmBabelRuntime5838CoreJsSetJs['default'];
    }, function (_githubJurisMCiteprocJs11101Js) {
      CSL = _githubJurisMCiteprocJs11101Js.CSL;
    }, function (_npmUrijs1171Js) {
      URI = _npmUrijs1171Js['default'];
    }, function (_npmZipJs002Js) {
      zip = _npmZipJs002Js['default'];
    }, function (_npmKefir322Js) {
      Kefir = _npmKefir322Js['default'];
    }, function (_npmLocalforage140Js) {
      localforage = _npmLocalforage140Js['default'];
    }, function (_npmPako101Js) {
      pako = _npmPako101Js['default'];
    }],
    execute: function () {

      // This is a dirty hack ...
      'use strict';

      zip.useWebWorkers = false;
      window.pako = pako;

      // This is a simple function to display progress.
      if (document.readyState == "interactive") {
        setupProgress();
        initApplication();
      } else {
        document.addEventListener('readystatechange', function (ev) {
          if (document.readyState == "interactive") initApplication();
        });
      }
    }
  };
});
